<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[（大合集）各种排序算法的介绍与实现]]></title>
      <url>/2017/06/05/2017-06-5-sort_agrithon/</url>
      <content type="html"><![CDATA[<p><strong>写在前边</strong>：这篇文章又臭又长，纯属个人无聊总结之作，如果您恰好看见了，有恰好有兴趣，建议您沐浴更衣，濯手焚香，静心阅读。</p>
<p>[TOC]</p>
<p>排序算法在计算机界是很基础，很重要的，对人类也是至关重要的，没有排序算法，就难以把人类分成三六九等，区别对待了，那样的世界是多么恐怖啊。</p>
<p>为了演示方便，此文排序的对象都是一个int类型的vector，其中交换两个元素，采用了位运算，至于为什么，第一是我恰好会，第二是，我认为这三行写在一起有一种独特的美感。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vec[i]=vec[j]^vec[i];</div><div class="line">vec[j]=vec[j]^vec[i];</div><div class="line">vec[i]=vec[j]^vec[i];</div></pre></td></tr></table></figure></p>
<p> (看起来似乎有点画蛇添足了，还不如。sort()……)。</p>
<h2 id="1-菜鸟排序"><a href="#1-菜鸟排序" class="headerlink" title="1.菜鸟排序"></a>1.菜鸟排序</h2><p>这个排序算法，是所有学生最开始接触编程的时候碰到的一个算法，其地位就像是&gt;hello world！&lt;在IT界的地位一般，所以必须放在开头。</p>
<p>其思想相当接近大多数常人的思维，从前向后，对每个位置，都从当前位置开始，向后面扫描，如果发现一个元素比当前位置的值大，就把它，交换过来。</p>
<p>这个算法，大约进行（n到1求和）次比较操作，所以复杂度是O(n^2)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">noob sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">noob_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">		<span class="keyword">int</span> i,j;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size()<span class="number">-1</span>;i++)</div><div class="line">  &#123;</div><div class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;vec.size();j++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(vec[j]&gt;vec[i])</div><div class="line">		&#123;</div><div class="line">			vec[i]=vec[j]^vec[i];</div><div class="line">			vec[j]=vec[j]^vec[i];</div><div class="line">			vec[i]=vec[j]^vec[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-选择排序（selected-sort）"><a href="#2-选择排序（selected-sort）" class="headerlink" title="2. 选择排序（selected sort）"></a>2. 选择排序（selected sort）</h2><p>一般同学们学到了上面那个算法，老师们就会指出，其中的很多交换是不必要的，如果我们先找出当前元素后面最大或者最小的元素，就能只用一次交换将一个元素放到正确的位置。于是就有了如下算法，用一个变量存储，后边的元素中最大或最小的元素下标，在遍历完之后才进行交换操作，减少了交换的次数，提高了效率。</p>
<p>不过它的复杂度依然是O(n^2)，因为这种优化带来的效果是操作次数常数倍的减少，决定这个算法效率的关键是比较的次数，这一类依赖于比较的算法，可以严格证明它们的复杂度是有下限的，稍后将会看到这样的算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">selected sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selected_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  	<span class="keyword">int</span> i,j,k;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size()<span class="number">-1</span>;i++)</div><div class="line">  &#123;</div><div class="line">	 k= i;</div><div class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;vec.size();j++)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(vec[j]&gt;vec[k])</div><div class="line">		&#123;</div><div class="line">			k=j;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	vec[i]=vec[k]^vec[i];</div><div class="line">	vec[k]=vec[k]^vec[i];</div><div class="line">	vec[i]=vec[k]^vec[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-冒泡排序（bubble-sort）"><a href="#3-冒泡排序（bubble-sort）" class="headerlink" title="3. 冒泡排序（bubble sort）"></a>3. 冒泡排序（bubble sort）</h2><p>这个算法的思想是从左往右去遍历数组，每次比较相邻两个元素的大小，如果其大小和你需要的大小关系相反（假设需要从大到小排序，那么你需要的排序结果左边的元素一定大于等于右边的元素），就交换两个元素的位置，这样一次从左到右的遍历，就能把最小的元素放到最后面去，这个最小的元素也就走到了它该去的地方，完成了历史的使命。第二次遍历的时候也就不用考虑这个元素了，具体来讲就是遍历范围的右边界减去1.</p>
<p>这个过程类似于每次把一个比较轻的泡泡冒出水面，所以这个算法叫做冒泡法。对于一个长度为n的数组，这个算法第i趟的时候需要比较n-i次，所以算法的复杂度依然是O(n^2)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">bubble sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  	<span class="keyword">int</span> i,j;</div><div class="line">  <span class="keyword">for</span>(i=vec.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</div><div class="line">  &#123;</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i+<span class="number">1</span>;j++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(vec[j]&gt;vec[j<span class="number">-1</span>])</div><div class="line">		&#123;</div><div class="line">			vec[j]=vec[j<span class="number">-1</span>]^vec[j];</div><div class="line">			vec[j<span class="number">-1</span>]=vec[j<span class="number">-1</span>]^vec[j];</div><div class="line">			vec[j]=vec[j<span class="number">-1</span>]^vec[j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-鸡尾酒排序（cocktail-sort）"><a href="#3-鸡尾酒排序（cocktail-sort）" class="headerlink" title="3. 鸡尾酒排序（cocktail sort）"></a>3. 鸡尾酒排序（cocktail sort）</h2><p>这个算法是冒泡排序的一个变种，它的具体做法就是来回冒泡，每次把一个泡泡冒到右边，然后把一个石子沉到水底，代码实现方面，用两个变量存储遍历的左右边界，每次从左向右遍历到头就将右边界减一后向左遍历，如此，直到左右边界重合，排序就完成了。这个算法相比于冒泡排序，性能上没有优化，复杂度依然是n^2只是过程显得更加酷炫狂拽，估计也就因此得名鸡尾酒，如果是中国人发明的估计应该命名洗剪吹算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">cocktail sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cocktail_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=vec.size()<span class="number">-1</span>,k;</div><div class="line">	<span class="keyword">while</span>(j&gt;i)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(k=i;k&lt;=j<span class="number">-1</span>;k++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[k]&lt;vec[k+<span class="number">1</span>])</div><div class="line">			&#123;</div><div class="line">				vec[k]=vec[k+<span class="number">1</span>]^vec[k];</div><div class="line">				vec[k+<span class="number">1</span>]=vec[k+<span class="number">1</span>]^vec[k];</div><div class="line">				vec[k]=vec[k+<span class="number">1</span>]^vec[k];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		j--;</div><div class="line">		<span class="keyword">if</span>(j&gt;i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(k=j<span class="number">-1</span>;k&gt;=i;k--)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(vec[k]&lt;vec[k+<span class="number">1</span>])</div><div class="line">				&#123;</div><div class="line">					vec[k]=vec[k+<span class="number">1</span>]^vec[k];</div><div class="line">					vec[k+<span class="number">1</span>]=vec[k+<span class="number">1</span>]^vec[k];</div><div class="line">					vec[k]=vec[k+<span class="number">1</span>]^vec[k];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-插入排序（insertion-sort）"><a href="#4-插入排序（insertion-sort）" class="headerlink" title="4. 插入排序（insertion sort）"></a>4. 插入排序（insertion sort）</h2><p>这个算法的思想依次选取待排数组中间的元素，插入到已经有序的数组内合适的位置，最终得到的元素序列就是有序的。初始的时候，我们从待排数组左边选择一个元素当作是已经有序的数组。</p>
<p>分析它的复杂度我们主要看发生的比较的次数，插入的时候我们是有序数列的从一侧向另一侧遍历，如果运气好，比较一次就找到了它应该在的位置，如果数组本身是反序的，你每次都要从左到右把已经有序的部分比较完才能找到其应该的位置。所以这个算法的复杂度和以上几个有了不一样的地方，有最好的和最坏的情况，这种情形用复杂度的期望来衡量复杂度是比较自然而然的做法。</p>
<p>总共需要插入n次，第i次插入操作平均会比较（i-1）2次，所以他的期望的复杂度为O（n^2/2）==O(n^2).</p>
<p>插入排序实际上可以优化到O(nlog(n),插入的时候采用二分法插入即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">insertion sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  	<span class="keyword">int</span> i,j;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;vec.size();i++)</div><div class="line">  &#123;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(vec[j]&gt;vec[j<span class="number">-1</span>])</div><div class="line">		&#123;</div><div class="line">			vec[j]=vec[j<span class="number">-1</span>]^vec[j];</div><div class="line">			vec[j<span class="number">-1</span>]=vec[j<span class="number">-1</span>]^vec[j];</div><div class="line">			vec[j]=vec[j<span class="number">-1</span>]^vec[j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-堆排序（heap-sort）"><a href="#5-堆排序（heap-sort）" class="headerlink" title="5. 堆排序（heap sort）"></a>5. 堆排序（heap sort）</h2><p>堆排序是利用了堆的特性，根据大根堆的定义，堆的根就是整个堆当中最大的一个元素，那么我们不断的去取出这个根（由于取出后会重建堆，导致新的根被选出来），那么得到的数列就是有序的了。</p>
<p>所以说这个算法关键在建一个堆，此处采用线性存储结构，直接用数组存储堆，为了原地排序，我们取出堆的根之后，重建堆，这样尾端就会空出一个位置，把取出的元素放到这个位置，等堆的元素个数为1的时候，数组就有序了。</p>
<p>若我们不看堆的操作，这个算法就需要n-1次操作就能完成任务啦，现实是我们必须考虑每次取出堆头后堆的重建。由于堆是完全二叉树，所以这个树的深度最多log(n)+1,根据堆调整过程，最多log(n)次的比较交换就能完成调整。所以算法复杂度为O（n*log(n)），这个数字就是比较类算法的复杂度的下限，可见它是一种很快的算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> heap sort</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebuild_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> n,<span class="keyword">int</span> size)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> largest=n;</div><div class="line">	<span class="keyword">if</span>(<span class="number">2</span>*n&gt;size)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</div><div class="line">	 <span class="keyword">if</span>(<span class="number">2</span>*n&lt;=size)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[n]&lt;vec[<span class="number">2</span>*n])</div><div class="line">			&#123;</div><div class="line">				largest=<span class="number">2</span>*n;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> largest=n;</div><div class="line">		&#125;</div><div class="line">	 <span class="keyword">if</span>(<span class="number">2</span>*n+<span class="number">1</span>&lt;=size)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(vec[<span class="number">2</span>*n+<span class="number">1</span>]&gt;vec[largest])</div><div class="line">				&#123;</div><div class="line">					largest=<span class="number">2</span>*n+<span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	<span class="keyword">if</span>(largest!=n)</div><div class="line">	&#123;</div><div class="line">		vec[n]=vec[n]^vec[largest];</div><div class="line">		vec[largest]=vec[n]^vec[largest];</div><div class="line">		vec[n]=vec[n]^vec[largest];</div><div class="line">		rebuild_heap(vec,largest,size);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=vec.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</div><div class="line">	&#123;</div><div class="line">		rebuild_heap(vec,i,vec.size()<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  	<span class="keyword">int</span> i,size;</div><div class="line">	size=vec.size()<span class="number">-1</span>;</div><div class="line">	<span class="comment">/*build  heap*/</span></div><div class="line">	build_heap(vec);</div><div class="line">	  <span class="keyword">for</span>(i=size;i&gt;<span class="number">1</span>;i--)</div><div class="line">	  &#123;</div><div class="line">		vec[<span class="number">1</span>]=vec[size]^vec[<span class="number">1</span>];</div><div class="line">		vec[size]=vec[size]^vec[<span class="number">1</span>];</div><div class="line">		vec[<span class="number">1</span>]=vec[size]^vec[<span class="number">1</span>];</div><div class="line">		<span class="comment">/*1和size位置的值交换*/</span></div><div class="line">		size--;</div><div class="line">		rebuild_heap(vec, <span class="number">1</span>, size);</div><div class="line">	  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="桶排序（-bucket-sort）"><a href="#桶排序（-bucket-sort）" class="headerlink" title="桶排序（ bucket sort）"></a>桶排序（ bucket sort）</h2><p>这个算法的思想是，给出一列有顺序的桶，每个桶编上号，从待排数列中取出一个元素，放到对应标号的桶里，这个操作在程序实现的时候极其方便，用数组的下标作为桶号，只需要一个赋值语句即可，对应桶的位置上的数字，用来标记桶号在待排数组内出现的次数。</p>
<p>输出的时候，按顺序扫描桶，若桶是空的，就跳过，若不空就根据桶中的数字输出相应个数的元素。</p>
<p>根据原理，很显然，只需要一次遍历就能把元素放进桶内，再一次便利桶即可输出有序的元素，为保证每个元素都能找到属于自己的桶，桶的个数需要包含待排数组的最小和最大值中间的所以情况。倘若待排数组长度n，桶个数m，那么算法的空间复杂度就是O(m)，时间复杂度就是O(n+m).</p>
<p>这似乎打破了前述的nlog(n)的复杂度下限，其实不然，之前说的复杂度下限，是直的基于比较的排序算法，而桶排序是不需要比较的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> bucket sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bucket_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket;</div><div class="line">	bucket.resize(vec.size(),<span class="number">0</span>);</div><div class="line">	<span class="comment">/*造桶*/</span></div><div class="line">  	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		bucket[vec[i]]++;</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bucket.size();i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(bucket[i]!=<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			vec.push_back(i);</div><div class="line">			bucket[i]--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="proxmap-sort"><a href="#proxmap-sort" class="headerlink" title="proxmap sort"></a>proxmap sort</h2><p>这东西没找着中文翻译，据我猜测 proximal是近似的意思，map是映射，它的中文应该是近似映射排序吧。</p>
<p>这是桶排序的升级版，桶排序最大的缺点就是浪费空间，因为桶排序中，大部分的桶都是空着的，所以有人提出每个桶装某个范围内的元素，所以它直接指定定一个桶的范围，然后在入桶的时候采用插入排序，最后遍历桶输出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">proxmap sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">proxmap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</div><div class="line">	bucket.resize(vec.size()/<span class="number">10</span>+<span class="number">1</span>);</div><div class="line">	<span class="comment">/*造桶*/</span></div><div class="line">  	<span class="keyword">int</span> i,j,k,* n,* m;</div><div class="line">	<span class="comment">//入桶</span></div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=bucket.size();j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[i]&lt;<span class="number">10</span>*j)</div><div class="line">			&#123;</div><div class="line">				bucket[j<span class="number">-1</span>].push_back(vec[i]);</div><div class="line">				<span class="keyword">for</span>(k=bucket[j<span class="number">-1</span>].size()<span class="number">-1</span>;k&gt;<span class="number">0</span>;k--)</div><div class="line">				&#123;</div><div class="line">					m=&amp;bucket[j<span class="number">-1</span>][k];</div><div class="line">					n=&amp;bucket[j<span class="number">-1</span>][k<span class="number">-1</span>];</div><div class="line">					<span class="keyword">if</span>(*n&lt;*m)</div><div class="line">					&#123;</div><div class="line">						*n=*n^(*m);</div><div class="line">						*m=*n^(*m);</div><div class="line">						*n=*n^(*m);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//出桶</span></div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bucket.size();j++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(bucket[j].size())</div><div class="line">		&#123;</div><div class="line">			vec.push_back(bucket[j].back());</div><div class="line">			bucket[j].pop_back();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h2><p>这个基数也就是数学中各种进制数字表示法的基数，由于我们用的是十进制，在此处，基数就是10。</p>
<p>这个算法分配十个桶，标号0到9，先按照个位数入桶，然后从左到右遍历桶，将元素取出，按照十位数字入桶，以此类推。</p>
<p>分析一下这个操作，就知道，按照个位数入桶的时候，个位数小的第二轮会先入桶，也就是说，第二轮完毕之后，每个桶内十位数相同，但是个位数小的被压在下面。继续分析，到百位数入桶的时候，每个桶十位数小的被压在下面，那这些被压在下边的十位数相同的一组，他们的个位数是否有序呢？显然是有的，其大小方向，取决于我们上一层的桶的取出方式为保持小的压在下面的性质，出桶应该采用先进先出的方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">radix sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,temp=vec.size();</div><div class="line">	<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</div><div class="line">	bucket.resize(<span class="number">10</span>);</div><div class="line">	<span class="comment">/*造桶*/</span></div><div class="line">  	</div><div class="line">	<span class="keyword">for</span>(i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">	&#123;</div><div class="line">		bucket[vec[i]%<span class="number">10</span>].push_back(vec[i]);</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(bucket[i].size()&gt;<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			vec.push_back(bucket[i].back());</div><div class="line">			bucket[i].pop_back();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">	&#123;</div><div class="line">		bucket[(vec[i]/<span class="number">10</span>)%<span class="number">10</span>].push_back(vec[i]);</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(bucket[i].size()&gt;<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			vec.push_back(bucket[i].back());</div><div class="line">			bucket[i].pop_back();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="耐心排序（patience-sort）"><a href="#耐心排序（patience-sort）" class="headerlink" title="耐心排序（patience sort）"></a>耐心排序（patience sort）</h2><p>这个排序的思想是依次取出待排数组元素，从左往右查找桶，只有小于桶底元素才能入桶，如果没有桶或者元素不小于任何一个桶的桶底元素，就新建一个桶，把这个元素放到桶底部。</p>
<p>这一边操作结束的结果就是，把待排数组分成了很多段，在每个桶分别插入排序就能得到有序数组。</p>
<p>插入排序的最坏情况是在反序的时候出现的，这个算法相比插入排序，将那些反序得太离谱的元素进行了调整，减小了问题规模。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">patience sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">patience_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</div><div class="line">	<span class="keyword">int</span> i,j,k,cur_bucket,len=vec.size();</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</div><div class="line">	&#123;</div><div class="line">		cur_bucket=<span class="number">-1</span>;</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bucket.size();j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(bucket[j][<span class="number">0</span>]&gt;=vec[i])</div><div class="line">			&#123;</div><div class="line">				cur_bucket=j;<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(cur_bucket==<span class="number">-1</span>)</div><div class="line">		&#123;</div><div class="line">			bucket.push_back(*(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;));</div><div class="line">			bucket.back().push_back(vec[i]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			bucket[cur_bucket].push_back(vec[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;bucket.size();k++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(bucket[k].size()!=<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			vec.push_back(bucket[k].back());</div><div class="line">			bucket[k].pop_back();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//插入排序</span></div><div class="line">	<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;len;k++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(j=k;j&gt;<span class="number">0</span>;j--)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[j]&lt;vec[j<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				vec[j]=vec[j]^vec[j<span class="number">-1</span>];</div><div class="line">				vec[j<span class="number">-1</span>]=vec[j]^vec[j<span class="number">-1</span>];</div><div class="line">				vec[j]=vec[j]^vec[j<span class="number">-1</span>];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="闪电排序（flash-sort）"><a href="#闪电排序（flash-sort）" class="headerlink" title="闪电排序（flash sort）"></a>闪电排序（flash sort）</h2><p>这也是proximap排序的一种升级算法，对于长度为n的桶，它把数组最大值和最小值之间分成n个区间，落在同个区间的放进同一个桶，入桶的时候进行插入排序，最后按顺序遍历桶，得到的数组就是有序的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> flash sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">flash_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</div><div class="line">	bucket.resize(vec.size());</div><div class="line">	<span class="comment">/*造桶*/</span></div><div class="line">  	<span class="keyword">int</span> i,j,max=<span class="number">0</span>,min=<span class="number">0</span>,*m,*n,k;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(vec[i]&gt;max)max=vec[i];</div><div class="line">		<span class="keyword">if</span>(vec[i]&lt;min)min=vec[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		j=(vec.size()<span class="number">-1</span>)*(vec[i]-min)/(max-min);</div><div class="line">		bucket[j].push_back(vec[i]);</div><div class="line">		<span class="keyword">for</span>(k=bucket[j].size()<span class="number">-1</span>;k&gt;<span class="number">0</span>;k--)</div><div class="line">		&#123;</div><div class="line">			m=&amp;bucket[j][k];</div><div class="line">			n=&amp;bucket[j][k<span class="number">-1</span>];</div><div class="line">			<span class="keyword">if</span>(*n&lt;*m)</div><div class="line">			&#123;</div><div class="line">				*n=*n^(*m);</div><div class="line">				*m=*n^(*m);</div><div class="line">				*n=*n^(*m);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bucket.size();j++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(bucket[j].size())</div><div class="line">		&#123;</div><div class="line">			vec.push_back(bucket[j].back());</div><div class="line">			bucket[j].pop_back();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="计数排序（-counting-sort）"><a href="#计数排序（-counting-sort）" class="headerlink" title="计数排序（ counting sort）"></a>计数排序（ counting sort）</h2><p>这个算法的核心思想是，如果待排数组中比一个元素小的有k个，那么这个元素就该放在第k+1个位置上。</p>
<p>当然对待重复的元素，需要特殊处理，假设有m个元素都发现数组中有k个元素比自己小，他们肯定不能全部挤在k+1号坑，显然，它们应该占据k+1到k+m这m个坑。</p>
<p>由于对每个元素，我们都需要遍历整个数组来统计比它小的元素个数，所以这个算法复杂度应该为O(n^2).<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> counting sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">counting_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,count;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket;</div><div class="line">	bucket.resize(vec.size(),<span class="number">-1000</span>);</div><div class="line">	<span class="comment">/*造桶*/</span></div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		count=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;vec.size();j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[j]&lt;vec[i]&amp;&amp;(j!=i))</div><div class="line">			&#123;</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(bucket[count]!=(<span class="number">-1000</span>))</div><div class="line">		&#123;</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">		bucket[count]=vec[i];</div><div class="line">	&#125;</div><div class="line">	vec=bucket;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="圈排序（-cycle-sort）"><a href="#圈排序（-cycle-sort）" class="headerlink" title="圈排序（ cycle sort）"></a>圈排序（ cycle sort）</h2><p>如果你看懂了计数排序，你也许会想到，它并不是原地算法，因为通过对某个元素计数之后，你知道了这个元素应该去的位置，但是在原地那个位置上还占着一个不知该放在哪里的元素。所以我们的做法是建立一个新的数组来安放排好序的元素，最后赋值给原数组。当然为了节约能源，你也可以建一个数组用于保存每个位置应该放的元素的标号（因为实际排序不可能只排关键字，必然有数据域），最后再根据标号去让各个元素归位，不过这样操作依然不是最理想的。</p>
<p>圈排序解决了这个问题，把计数排序升级成了原地排序。</p>
<p>它的思想是这样的：当你找到一个a元素应该放在1号位，而1号位被另一个元素b占着，你就把b元素取出，然后把a放到1号位，给a本来的位置放一个空标记。接着寻找b应该放在哪里。最终你一定会找到一个元素应该放在a原来的位置，由于这个位置是空的，直接把元素放在此处就结束了，这样的一系列操作构成一个圈，每个元素移动一次，就能让一个圈上所有元素归位。</p>
<p>这里有个confused的地方，就是，你为什么知道能够找到这样的圈？</p>
<p>这背后是有数学原理的，这种排序前和排序之后的映射关系在抽象代数中称作置换，而上述的圈称作轮换，就是一个集合到自身的映射，可以严格证明，每个置换都能写成几个不相交的轮换乘积形式，此处只摆出结论，不做证明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">cycle sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cycle_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i, j, temp,count;</div><div class="line">	<span class="comment">/*造桶*/</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;vec.size(); i++)</div><div class="line">	&#123;</div><div class="line">		temp = vec[i];</div><div class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			count = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;vec.size(); j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (vec[j]&lt;temp &amp;&amp; (j != i))</div><div class="line">				&#123;</div><div class="line">					count++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">while</span> (vec[count] == temp)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (count == i)<span class="keyword">break</span>;</div><div class="line">				count++;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">			temp = temp^vec[count];</div><div class="line">			vec[count] = temp^vec[count];</div><div class="line">			temp = temp^vec[count];</div><div class="line">			<span class="keyword">if</span> (i == count)<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="地精-排序（gnome-sort）"><a href="#地精-排序（gnome-sort）" class="headerlink" title="地精 排序（gnome sort）"></a>地精 排序（gnome sort）</h2><p>这个算法我认为跟他的名字很搭调，地精就是生活在花园里的一种精灵，他们喜欢在土里钻来钻去。</p>
<p>这个算法具体操作概括为，先从左往右进行相邻元素比较，当发现一个元素不满足需要的大小关系的时候，就交换他们然后调转方向向左边冒泡，直到相邻元素满足大小关系的时候，停止冒泡。</p>
<p>按照这个过程，左边的一部分元素总是有序的，每次地精抓住一个元素把它插入到有序的序列内，所以这其实是插入排序的低配版，因为插入排序实际上在插入操作的时候可以优化到O(log(n),也就是二分法插入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> gnome sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gnome_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></div><div class="line">&#123;</div><div class="line">	</div><div class="line">  	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)(vec.size())<span class="number">-1</span>;)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(i==<span class="number">-1</span>)i++;</div><div class="line">		<span class="keyword">if</span>(vec[i]&lt;vec[i+<span class="number">1</span>])</div><div class="line">		&#123;</div><div class="line">			vec[i]=vec[i+<span class="number">1</span>]^vec[i];</div><div class="line">			vec[i+<span class="number">1</span>]=vec[i+<span class="number">1</span>]^vec[i];</div><div class="line">			vec[i]=vec[i+<span class="number">1</span>]^vec[i];</div><div class="line">			i--;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="珠排序（bead-sort）"><a href="#珠排序（bead-sort）" class="headerlink" title="珠排序（bead sort）"></a>珠排序（bead sort）</h2><p>这个算法有种让人眼前一亮的感觉，<a href="https://zh.wikipedia.org/wiki/%E7%8F%A0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科页面</a><br>讲的会更加清楚，这个算法按照理论，只需要把珠子穿在一系列棍子上，在‘duang’的一敲，排序就完成了。不过现实很骨感，它只能排整数列，并且在编程的时候，复杂度也是n^2级别，但是这种想法的确让人惊叹，发明这个算法的人真的是天才。</p>
<p>这个算法实际上基本是不可用的，不过我还是写了一个实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">bead sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bead_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> i,j;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</div><div class="line">	temp.resize(vec.size(),<span class="number">0</span>);</div><div class="line">	<span class="comment">/*下落*/</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;vec.size();j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (vec[j] &gt;= i + <span class="number">1</span>)temp[i]++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	vec.resize(temp.size(),<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;vec.size();j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (temp[j] &gt;= i + <span class="number">1</span>)vec[i]++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##　快速排序（quick sort）<br>这个算法采用的是分治法的思想，选取一个元素，然后遍历整个数组，小于等于这个元素的都放在这个元素左边，其余的放在它右边。这样数组就被分为三部分，这个元素本身已经处于正确的位置上，不需要再移动，而左右两部分都是无序的，但是左边部分的元素的正确位置只可能在左边，所以只要将左右两边分别排序，整个数组都有序了。</p>
<p>实现的时候，数组头尾各放一个指针（抽象意义的），左边指针向右移动直到有大于指定元素的时候停下来，右边指针也类似，等两边指针都停下来了，就进行一次交换，最终两个指针相遇的时候,再中间放上之前指定的那个元素，就完成了数组的分片操作。</p>
<p>递归的调用这个过程，最终得到的数组就是有序的。</p>
<p>由于这个算法递归深度为log（n）到n之间，它的复杂度也在n^2到nlogn之间，实际上他的平均复杂度是O（nlogn），既然他的名字叫做快速排序它总不能打自己脸来个n^2复杂度吧。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">quick sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=left+<span class="number">1</span>,j=right,k,temp;</div><div class="line">	<span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	temp=vec[left];</div><div class="line">	<span class="keyword">while</span>(i&lt;j)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(vec[left]&gt;=vec[i])</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(i==j)<span class="keyword">break</span>;</div><div class="line">			vec[i<span class="number">-1</span>]=vec[i];</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(vec[left]&lt;vec[j])</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(i==j)<span class="keyword">break</span>;</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i&lt;j)</div><div class="line">		&#123;</div><div class="line">			vec[i]=vec[i]^vec[j];</div><div class="line">			vec[j]=vec[i]^vec[j];</div><div class="line">			vec[i]=vec[i]^vec[j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	vec[k]=temp;</div><div class="line">	quick_sort(vec,left,i<span class="number">-2</span>);</div><div class="line">	quick_sort(vec,i,right);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h2><p>归并排序的思想也是挺直观的，对于已经有序的两个（或者n个）数列，我们只需要比较队列头部两个元素就能找出最终合并后数列的最大or最小元素。</p>
<p>假设我们需要从大到小排列，每次比较后把两个队头中大的那个放到新的队列，然后从待排队列中剔除它，直到其中一个列没有元素之后，就把另一列全部接到已经排序好的数列后边。</p>
<p>算法实现上，通过设置两个队头指针（抽象意义），用移动指针来表示元素的剔除，实现原地操作（当然就增加了时间复杂度）。</p>
<p>同时也用了分治法，先归并排序左半个数列，再归并排序右半边数列，最后归并排序整个数列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">merge sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(l&gt;=h)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> i,j,k,m,n;</div><div class="line">	i=(h-l+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">	j=h-l+<span class="number">1</span>-i;</div><div class="line">	m=l;</div><div class="line">	n=l+i;</div><div class="line">	merge_sort(vec,l,l+i<span class="number">-1</span>);</div><div class="line">	merge_sort(vec,l+i,h);</div><div class="line">	</div><div class="line">  	<span class="keyword">for</span>(;(m&lt;n)&amp;&amp;(n&lt;=h);)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(vec[m]&gt;=vec[n])</div><div class="line">		&#123;</div><div class="line">			m++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(k=n;k&gt;m;k--)</div><div class="line">			&#123;</div><div class="line">				vec[k]=vec[k]^vec[k<span class="number">-1</span>];</div><div class="line">				vec[k<span class="number">-1</span>]=vec[k]^vec[k<span class="number">-1</span>];</div><div class="line">				vec[k]=vec[k]^vec[k<span class="number">-1</span>];</div><div class="line">			&#125;</div><div class="line">			n++;</div><div class="line">			m++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="strand-sort"><a href="#strand-sort" class="headerlink" title="strand sort"></a>strand sort</h2><p>这个算法首先给出一个有序数组（实际上选取待排数组中的第一个，就是一个有序数组了），然后遍历数组中余下的部分找到一个有序子列，具体做法是选一个元素作为子列开头，往后遍历若找到一个元素小于子列的尾部元素（这里是指的从大到小排列的情形），就从待排数组剔除这个元素，然后将它接到子列尾部。</p>
<p>最后将有序数组和子列归并排序，直到待排数组为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">strand sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strand_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;<span class="comment">//'有序列'</span></div><div class="line">	temp.push_back(vec[<span class="number">0</span>]);</div><div class="line">	vec.erase(vec.begin());</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</div><div class="line">	<span class="keyword">int</span> j,k,m,n;</div><div class="line">	</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		n=temp.size();</div><div class="line">		<span class="keyword">if</span> (vec.size() == <span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">for</span>(i=vec.begin();i!=vec.end();)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(i==vec.begin())</div><div class="line">			&#123;</div><div class="line">				temp.push_back(*i);</div><div class="line">				i++;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(*i&lt;=temp.back())</div><div class="line">			&#123;</div><div class="line">				temp.push_back(*i);</div><div class="line">				i=vec.erase(i);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(n==temp.size())<span class="keyword">break</span>;</div><div class="line">		vec.erase(vec.begin());</div><div class="line">		m = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(;(m&lt;n)&amp;&amp;(n&lt;=temp.size()<span class="number">-1</span>);)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(temp[m]&gt;=temp[n])</div><div class="line">			&#123;</div><div class="line">				m++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">for</span>(k=n;k&gt;m;k--)</div><div class="line">				&#123;</div><div class="line">					temp[k]=temp[k]^temp[k<span class="number">-1</span>];</div><div class="line">					temp[k<span class="number">-1</span>]=temp[k]^temp[k<span class="number">-1</span>];</div><div class="line">					temp[k]=temp[k]^temp[k<span class="number">-1</span>];</div><div class="line">				&#125;</div><div class="line">				n++;</div><div class="line">				m++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;	</div><div class="line">    </div><div class="line">	vec = temp;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h2><p>希尔排序是选择一系列的间隔，对每个间隔把元素等距离的分为若干组，每组分别进行插入排序。</p>
<p>这个间隔序列的选取应该是递减的，并且最后一个间隔是1.这个算法相比于插入排序，优势在于当间隔不为1的时候进行的排序，实际上相当于在整个数列中，让元素跨过多元素进行移动，这样解决了逆序带来的复杂度的提升。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">shell sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> interval=<span class="number">10</span>,i,j,k,len=vec.size(),cur_len;</div><div class="line">	<span class="keyword">while</span>(interval&gt;<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;interval;i++)</div><div class="line">		&#123;</div><div class="line">			cur_len=(len/interval)+(i&lt;len%interval?<span class="number">1</span>:<span class="number">0</span>);</div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;cur_len<span class="number">-1</span>;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;cur_len<span class="number">-1</span>-i;k++)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">if</span>(vec[i+interval*k]&lt;vec[i+interval*(k+<span class="number">1</span>)])</div><div class="line">					&#123;</div><div class="line">						vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k+<span class="number">1</span>)];</div><div class="line">						vec[i+interval*(k+<span class="number">1</span>)]=vec[i+interval*k]^vec[i+interval*(k+<span class="number">1</span>)];</div><div class="line">						vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k+<span class="number">1</span>)];</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		interval=interval/<span class="number">1.3</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="梳子排序（comb-sort）"><a href="#梳子排序（comb-sort）" class="headerlink" title="梳子排序（comb sort）"></a>梳子排序（comb sort）</h2><p>这个算法就是希尔排序的冒泡版本，因为他按照等距离的方法把元素分为很多组，分别冒泡排序，就像梳子的齿一样，所以得名comb sort。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">comb sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> interval=<span class="number">10</span>,i,j,k,len=vec.size(),cur_len;</div><div class="line">	<span class="keyword">while</span>(interval&gt;<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;interval;i++)</div><div class="line">		&#123;</div><div class="line">			cur_len=(len/interval)+(i&lt;len%interval?<span class="number">1</span>:<span class="number">0</span>);</div><div class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;cur_len;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">for</span>(k=j;k&gt;<span class="number">0</span>;k--)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">if</span>(vec[i+interval*k]&lt;vec[i+interval*(k<span class="number">-1</span>)])</div><div class="line">					&#123;</div><div class="line">						vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k<span class="number">-1</span>)];</div><div class="line">						vec[i+interval*(k<span class="number">-1</span>)]=vec[i+interval*k]^vec[i+interval*(k<span class="number">-1</span>)];</div><div class="line">						vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k<span class="number">-1</span>)];</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		interval=interval/<span class="number">1.3</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="奇偶排序（odd-even-sort）"><a href="#奇偶排序（odd-even-sort）" class="headerlink" title="奇偶排序（odd_even sort）"></a>奇偶排序（odd_even sort）</h2><p>这个算法将元素按照下标的奇偶分为两组，首先在第一组进行相邻两个元素的比较，然后在第二组进行相邻两个元素比较（相邻的定义要一致，可以都用后一个相邻，也可以都用前一个乡邻，绝对不能一个前一个后），如此循环。直到某一次进行完检查后，第一组和第二组都没有改动，这时候就说明元素已经有序了。</p>
<p>这个算法一看就知道只是花拳绣腿，改变一下冒泡排序的顺序而已，性能没有任何变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">odd_even sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">odd_even_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> odd_len,even_len,len,j,flag=<span class="number">1</span>;</div><div class="line">	len=vec.size();</div><div class="line">	odd_len=len/<span class="number">2</span>+(len%<span class="number">2</span>==<span class="number">0</span>?(<span class="number">-1</span>):<span class="number">0</span>);</div><div class="line">	even_len=len/<span class="number">2</span>+(len%<span class="number">2</span>==<span class="number">0</span>?<span class="number">0</span>:<span class="number">0</span>);</div><div class="line">	<span class="keyword">while</span>(flag==<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		flag=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;even_len;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[<span class="number">2</span>*j]&lt;vec[<span class="number">2</span>*j+<span class="number">1</span>])</div><div class="line">			&#123;</div><div class="line">				vec[<span class="number">2</span>*j]=vec[<span class="number">2</span>*j]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</div><div class="line">				vec[<span class="number">2</span>*j+<span class="number">1</span>]=vec[<span class="number">2</span>*j]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</div><div class="line">				vec[<span class="number">2</span>*j]=vec[<span class="number">2</span>*j]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</div><div class="line">				flag=<span class="number">1</span>;</div><div class="line">			&#125;			</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;odd_len;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(vec[<span class="number">2</span>*j+<span class="number">1</span>]&lt;vec[<span class="number">2</span>*j+<span class="number">2</span>])</div><div class="line">			&#123;</div><div class="line">				vec[<span class="number">2</span>*j+<span class="number">2</span>]=vec[<span class="number">2</span>*j+<span class="number">2</span>]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</div><div class="line">				vec[<span class="number">2</span>*j+<span class="number">1</span>]=vec[<span class="number">2</span>*j+<span class="number">2</span>]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</div><div class="line">				vec[<span class="number">2</span>*j+<span class="number">2</span>]=vec[<span class="number">2</span>*j+<span class="number">2</span>]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</div><div class="line">				flag=<span class="number">1</span>;</div><div class="line">			&#125;			</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="图书馆排序（library-sort）"><a href="#图书馆排序（library-sort）" class="headerlink" title="图书馆排序（library sort）"></a>图书馆排序（library sort）</h2><p>这个算法是二十一世纪才提出的，由此便看出计算机科学的活力，在数学上，那些让你觉得深不可测的东西，你一看年代，往往在几百年前就被大师上课的时候在草稿纸上解决了，等你学到21世纪的数学，你就是大师了。</p>
<p>这个算法灵感源于在图书馆放书的时候在书之间留下空隙，当你需要插入一本书的时候就不必移动整个架子的书。</p>
<p>所以我们在数组元素间留一些空隙，插入的时候就能够减少对其他元素的移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">library sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">library_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> empty_flag = <span class="number">-1000</span>;</div><div class="line"></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</div><div class="line">	temp.resize(vec.size()*<span class="number">2</span>,empty_flag);</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> i, j, k,l, indicator;</div><div class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;vec.size();i++)</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (j=<span class="number">2</span>*i;j&gt;=<span class="number">-1</span>;j--)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> ( j == <span class="number">-1</span>||(temp[j] &gt;= vec[i]&amp;&amp;temp[j]!= empty_flag))</div><div class="line">			&#123;</div><div class="line">				indicator = <span class="number">0</span>;</div><div class="line">				<span class="keyword">for</span>(l=<span class="number">2</span>*i;l&gt;j;l--)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">if</span> (temp[l] != empty_flag)</div><div class="line">					&#123;</div><div class="line">						indicator = <span class="number">1</span>; <span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (indicator == <span class="number">1</span>)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">if</span> (temp[j + <span class="number">1</span>] != empty_flag)</div><div class="line">					&#123;</div><div class="line"></div><div class="line">						k = j + <span class="number">1</span>;</div><div class="line">						<span class="keyword">while</span> (temp[k] != empty_flag)</div><div class="line">						&#123;</div><div class="line">							k++;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">for</span> (; k &gt; j + <span class="number">1</span>; k--)</div><div class="line">						&#123;</div><div class="line">							temp[k] = temp[k - <span class="number">1</span>];</div><div class="line">						&#125;</div><div class="line">						temp[k] = vec[i];</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span></div><div class="line">					&#123;</div><div class="line">						temp[j + <span class="number">1</span>] = vec[i];</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span></div><div class="line">				&#123;</div><div class="line">					temp[i * <span class="number">2</span>] = vec[i];</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	vec.resize(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; temp.size(); i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (temp[i] != empty_flag)</div><div class="line">		&#123;</div><div class="line">			vec.push_back(temp[i]);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="bogo-sort"><a href="#bogo-sort" class="headerlink" title="bogo sort"></a>bogo sort</h2><p>这个算法也没有中文翻译，不过我把它作为压轴算法，它必然有过人之处，它的过人之处就是，超级慢。</p>
<p>这个算法思想类似于把一副牌扔向空中，掉到地上后去看看它是不是有序的，如果不是，再扔一次。</p>
<p>它的复杂度是O（n!）,这个东西和n^n是同阶的。可见其相当恐怖。</p>
<p>数学说起来太抽象，假设排十个数需要时间t，那么排20个就需要2^20*10^10*t，也就是大约2*10^16*t，我实测了一下，半分钟才能排11个数字。</p>
<p>这个算法存在的意义估计是挑战运算的极限吧，等有朝一日，这个算法能用于生产生活，人类文明估计就会进入新纪元了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">bogo sort</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bogo_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> randa=<span class="number">1</span>, randb=<span class="number">2</span>,count=<span class="number">0</span>,i,flag=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">		&#123;</div><div class="line">			randa = (time(<span class="literal">NULL</span>)+rand())%vec.size();</div><div class="line">			randb = (time(<span class="literal">NULL</span>)+rand())% vec.size();</div><div class="line">			<span class="keyword">if</span> (randb != randa)<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		vec[randa] = vec[randa] ^ vec[randb];</div><div class="line">		vec[randb] = vec[randa] ^ vec[randb];</div><div class="line">		vec[randa] = vec[randa] ^ vec[randb];</div><div class="line">		count++;</div><div class="line">		<span class="keyword">if</span> (count &gt;= <span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			count = <span class="number">0</span>;</div><div class="line">			flag = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; vec.size()<span class="number">-1</span>; i++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (vec[i] &lt; vec[i + <span class="number">1</span>])</div><div class="line">				&#123;</div><div class="line">					flag = <span class="number">1</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[徒手(加上Wikipedia)实现一颗红黑树]]></title>
      <url>/2017/05/25/2017-05-25-RBT/</url>
      <content type="html"><![CDATA[<p>近来回顾往日之学习，深感光阴虚度，愧对祖宗，所学多为纸上谈兵，死记硬背，极少深入理解知识中的精髓，往往知其HOW而不知其WHY。</p>
<p>不过知其WHY是一件极为困难的事情，于是便决心要多多实践，纸上得来终觉浅，觉知此事要躬行。</p>
<p>红黑树是一种什么树，三言两语是说不清楚的，在此推荐<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">Wikipedia页面</a>,为了实现一棵树，我盯着这个页面好些天才算看明白了一点点，我在此主要记录一下代码实现细节过程。</p>
<p>首先定义节点的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*RBT*/</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include&lt;iomanip&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#define RED 0</div><div class="line">#define BLACK 1</div><div class="line">#define LEFT -1</div><div class="line">#define RIGHT 1</div><div class="line">using namespace std;</div><div class="line">struct RBT_Node &#123;</div><div class="line">	int key;</div><div class="line">	int color;//颜色</div><div class="line">	RBT_Node * left;</div><div class="line">	RBT_Node * right;</div><div class="line">	RBT_Node * parent;</div><div class="line">&#125;;</div><div class="line">struct RBTree &#123;</div><div class="line">	RBT_Node * root;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>树最重要的是增删查改操作，其中增删是主要的，所以我只实现增加和删除两个操作。</p>
<p>下面来实现节点的插入，根据原理，我们根据给出的key构造一个红节点，插入到树中，插入完毕必须要调整以满足红黑树性质，用RBT_adjust（）来实现，这个函数在后面再写出具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">int RBT_insert(RBT_Node*  p, RBTree&amp;  T, int n) &#123;</div><div class="line">	int RBT_adjust(RBT_Node *p, RBTree&amp; t);</div><div class="line">	RBT_Node*  node;</div><div class="line">	if (T.root == NULL)</div><div class="line">	&#123;</div><div class="line">		T.root = new RBT_Node;</div><div class="line">		node = T.root;</div><div class="line">		node-&gt;color = RED;//0是红色</div><div class="line">		node-&gt;key = n;</div><div class="line">		node-&gt;left = NULL;</div><div class="line">		node-&gt;right = NULL;</div><div class="line">		node-&gt;parent = NULL;</div><div class="line">		RBT_adjust(node, T);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (n&lt;p-&gt;key) &#123;</div><div class="line">		if (p-&gt;left == NULL)</div><div class="line">		&#123;</div><div class="line">			p-&gt;left = new RBT_Node;</div><div class="line">			node = p-&gt;left;</div><div class="line">			node-&gt;color = RED;//0是红色</div><div class="line">			node-&gt;key = n;</div><div class="line">			node-&gt;left = NULL;</div><div class="line">			node-&gt;right = NULL;</div><div class="line">			node-&gt;parent = p;</div><div class="line">			RBT_adjust(node, T);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		else RBT_insert((p-&gt;left), T, n);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else if (n&gt;p-&gt;key) &#123;</div><div class="line">		if (p-&gt;right == NULL)</div><div class="line">		&#123;</div><div class="line">			p-&gt;right = new RBT_Node;</div><div class="line">			node = p-&gt;right;</div><div class="line">			node-&gt;color = RED;//0是红色</div><div class="line">			node-&gt;key = n;</div><div class="line">			node-&gt;left = NULL;</div><div class="line">			node-&gt;right = NULL;</div><div class="line">			node-&gt;parent = p;</div><div class="line">			RBT_adjust(node, T);</div><div class="line">		&#125;</div><div class="line">		else RBT_insert((p-&gt;right), T, n);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来定义几个工具函数，分别实现几种旋转，找到叔叔节点，判断孩子和父亲的左右关系等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int RBT_adjust_LL(RBT_Node* p, RBTree&amp; t) &#123;</div><div class="line">	RBT_Node** temp = NULL;</div><div class="line">	if (p-&gt;parent == NULL) &#123;</div><div class="line">		t.root = p-&gt;right;</div><div class="line">		p-&gt;right-&gt;parent = NULL;</div><div class="line">		p-&gt;right = p-&gt;right-&gt;left;</div><div class="line">		if (p-&gt;right != NULL) p-&gt;right-&gt;parent = p;</div><div class="line">		t.root-&gt;left = p;</div><div class="line">		p-&gt;parent = t.root;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		if (p-&gt;parent-&gt;right == p)temp = &amp;(p-&gt;parent-&gt;right);</div><div class="line">		else temp = &amp;(p-&gt;parent-&gt;left);</div><div class="line">		*temp = p-&gt;right;</div><div class="line">		p-&gt;right-&gt;parent = p-&gt;parent;</div><div class="line">		p-&gt;right = p-&gt;right-&gt;left;</div><div class="line">		if (p-&gt;right != NULL) p-&gt;right-&gt;parent = p;</div><div class="line">		(*temp)-&gt;left = p;</div><div class="line">		p-&gt;parent = (*temp);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">int RBT_adjust_RR(RBT_Node* p, RBTree&amp; t) &#123;</div><div class="line">	RBT_Node** temp = NULL;</div><div class="line">	if (p-&gt;parent == NULL) &#123;</div><div class="line">		t.root = p-&gt;left;</div><div class="line">		p-&gt;left-&gt;parent = NULL;</div><div class="line">		p-&gt;left = p-&gt;left-&gt;right;</div><div class="line">		if (p-&gt;left != NULL) p-&gt;left-&gt;parent = p;</div><div class="line">		t.root-&gt;right = p;</div><div class="line">		p-&gt;parent = t.root;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		if (p-&gt;parent-&gt;right == p)temp = &amp;(p-&gt;parent-&gt;right);</div><div class="line">		else temp = &amp;(p-&gt;parent-&gt;left);</div><div class="line">		*temp = p-&gt;left;</div><div class="line">		p-&gt;left-&gt;parent = p-&gt;parent;</div><div class="line">		p-&gt;left = p-&gt;left-&gt;right;</div><div class="line">		if (p-&gt;left != NULL) p-&gt;left-&gt;parent = p;</div><div class="line">		(*temp)-&gt;right = p;</div><div class="line">		p-&gt;parent = *temp;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int RBT_adjust_RL(RBT_Node* p, RBTree&amp; t) &#123;</div><div class="line">	RBT_Node* temp1 = p;</div><div class="line">	RBT_Node* temp2 = p-&gt;right;</div><div class="line">	RBT_adjust_RR(temp2, t);</div><div class="line">	RBT_adjust_LL(temp1, t);</div><div class="line">	return 0;</div><div class="line"></div><div class="line">&#125;</div><div class="line">int RBT_adjust_LR(RBT_Node* p, RBTree&amp; t) &#123;</div><div class="line">	RBT_Node* temp1 = p;</div><div class="line">	RBT_Node* temp2 = p-&gt;left;</div><div class="line">	RBT_adjust_LL(temp2, t);</div><div class="line">	RBT_adjust_RR(temp1, t);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">bool isRchild(RBT_Node* node) &#123;</div><div class="line">	if (node-&gt;parent == NULL || node == NULL)return -1;</div><div class="line">	if (node-&gt;parent-&gt;right == node)return true;</div><div class="line">	else return false;</div><div class="line">&#125;</div><div class="line">bool isLchild(RBT_Node* node) &#123;</div><div class="line">	if (node-&gt;parent == NULL||node==NULL)return -1;</div><div class="line">	if (node-&gt;parent-&gt;left == node)return true;</div><div class="line">	else return false;</div><div class="line">&#125;</div><div class="line">struct RBT_Node* getUncle(RBT_Node* node) &#123;</div><div class="line">	//前提是爷爷存在</div><div class="line">	if (isLchild(node-&gt;parent)) &#123;</div><div class="line">		return node-&gt;parent-&gt;parent-&gt;right;</div><div class="line">	&#125;</div><div class="line">	else if (isRchild(node-&gt;parent)) &#123;</div><div class="line">		return node-&gt;parent-&gt;parent-&gt;left;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这便是最核心的部分，也就是插入完成后的调整了，代码中，关键部位，我加了一些注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">int RBT_adjust_case3(RBT_Node *p, RBTree&amp; t) &#123;</div><div class="line">	//爸爸红，叔叔黑或者是null</div><div class="line">	if (isLchild(p) &amp;&amp; isRchild(p-&gt;parent)) &#123;</div><div class="line">		RBT_adjust_LR(p-&gt;parent-&gt;parent,t);</div><div class="line">		p-&gt;color = BLACK;</div><div class="line">		if(p-&gt;left)p-&gt;left-&gt;color = RED;</div><div class="line">		if(p-&gt;right)p-&gt;right-&gt;color = RED;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else if (isRchild(p) &amp;&amp; isLchild(p-&gt;parent)) &#123;</div><div class="line">		RBT_adjust_RL(p-&gt;parent-&gt;parent,t);</div><div class="line">		p-&gt;color = BLACK;</div><div class="line">		 if(p-&gt;left)p-&gt;left-&gt;color = RED;</div><div class="line">		if(p-&gt;right)p-&gt;right-&gt;color = RED;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else if (isLchild(p) &amp;&amp; isLchild(p-&gt;parent)) &#123;</div><div class="line">		RBT_adjust_RR(p-&gt;parent-&gt;parent,t);</div><div class="line">		p-&gt;parent-&gt;color = BLACK;</div><div class="line">		if(p-&gt;parent-&gt;right)p-&gt;parent-&gt;right-&gt;color = RED;</div><div class="line">		if(p-&gt;parent-&gt;left)p-&gt;parent-&gt;left-&gt;color = RED;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		RBT_adjust_LL(p-&gt;parent-&gt;parent,t);</div><div class="line">		p-&gt;parent-&gt;color = BLACK;</div><div class="line">		if(p-&gt;parent-&gt;right)p-&gt;parent-&gt;right-&gt;color = RED;</div><div class="line">		if(p-&gt;parent-&gt;left)p-&gt;parent-&gt;left-&gt;color = RED;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">int RBT_adjust_case2(RBT_Node *p, RBTree&amp; t) &#123;</div><div class="line">	//父亲RED,所以爷爷是黑色,此处父亲红色，所以肯定不是根，爷爷 必定存在</div><div class="line">	if ((NULL!= getUncle(p))&amp;&amp;(getUncle(p)-&gt;color==RED))</div><div class="line">	&#123;</div><div class="line">		//若叔叔是红色，可以把爸爸 和叔叔公用的爷爷这个黑色节点，下放到父辈，也就是把爷爷染红，爸爸和叔叔染黑</div><div class="line">		//如此一来，就相当于在爷爷处插入了一个新的红节点，需要递归调用调整操作</div><div class="line">		p-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">		getUncle(p)-&gt;color = BLACK;</div><div class="line">		p-&gt;parent-&gt;color = BLACK;</div><div class="line">		int RBT_adjust(RBT_Node *p, RBTree&amp; t);</div><div class="line">		RBT_adjust(p-&gt;parent-&gt;parent, t);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else </div><div class="line">	&#123;</div><div class="line">		RBT_adjust_case3(p,  t);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int RBT_adjust(RBT_Node *p, RBTree&amp; t) &#123;</div><div class="line">	if (p-&gt;parent == NULL) &#123; p-&gt;color = BLACK; return 0; &#125;//插入之后是树根</div><div class="line">	if ((p-&gt;parent-&gt;color) ==BLACK) return 0;</div><div class="line">	else RBT_adjust_case2(p,t);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是这段代码中最臭最长的一部分，实现了删除操作，我要说的内容，都在注释内。。。。。。。。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div></pre></td><td class="code"><pre><div class="line">//delete</div><div class="line">RBT_Node*  getBrother(RBT_Node*p) &#123;</div><div class="line">	if (NULL == p || NULL == p-&gt;parent)return NULL;</div><div class="line">	if (p-&gt;parent-&gt;left == p)return p-&gt;parent-&gt;right;</div><div class="line">	else return p-&gt;parent-&gt;left;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">int delete_case6(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)</div><div class="line">&#123;/*所以综合为：父亲红黑均可，兄弟黑，兄弟两个孩子不全黑,且new节点是父亲左孩子时兄弟左孩子是黑的，</div><div class="line">	new节点是父亲右孩子时兄弟右孩子是黑的</div><div class="line">	如此只剩下：</div><div class="line">	当new节点是父亲左孩子时，父亲红，兄弟右孩子红，或父亲黑，兄弟右孩子黑</div><div class="line">	当new节点是父亲右孩子时，对称。</div><div class="line">	*/</div><div class="line">	RBT_Node*l, *r;</div><div class="line">	if (father_of_new_node-&gt;left == new_node)</div><div class="line">	&#123;</div><div class="line">		l = father_of_new_node-&gt;right-&gt;left;</div><div class="line">		r = father_of_new_node-&gt;right-&gt;right;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		l = father_of_new_node-&gt;left-&gt;left;</div><div class="line">		r = father_of_new_node-&gt;left-&gt;right;</div><div class="line">	&#125;</div><div class="line">	if (new_node-&gt;parent-&gt;left == new_node)</div><div class="line">	&#123;</div><div class="line">		RBT_adjust_RR(father_of_new_node,t);</div><div class="line">		r-&gt;color = BLACK;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		RBT_adjust_LL(father_of_new_node, t);</div><div class="line">		l-&gt;color = BLACK;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">int delete_case5(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)</div><div class="line">&#123;//此时前提是，兄弟为黑色,（父亲，兄弟的两个孩子不全为黑色)且有（父亲为红时，兄弟两个孩子不同时为黑）</div><div class="line">	//所以综合为：父亲红黑均可，兄弟黑，兄弟两个孩子不全黑</div><div class="line">	RBT_Node*l, *r;</div><div class="line">	if (father_of_new_node-&gt;left == new_node)</div><div class="line">	&#123;</div><div class="line">		l = father_of_new_node-&gt;right-&gt;left;</div><div class="line">		r = father_of_new_node-&gt;right-&gt;right;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		l = father_of_new_node-&gt;left-&gt;left;</div><div class="line">		r = father_of_new_node-&gt;left-&gt;right;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (new_node-&gt;parent-&gt;left==new_node) </div><div class="line">	&#123;</div><div class="line">		if (l&amp;&amp;l-&gt;color == RED)</div><div class="line">		&#123;</div><div class="line">			RBT_adjust_RR(l-&gt;parent, t);</div><div class="line">			l-&gt;color = BLACK;</div><div class="line">			l-&gt;right-&gt;color = RED;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if (r&amp;&amp;r-&gt;color == RED)</div><div class="line">		&#123;</div><div class="line">			RBT_adjust_LL(l-&gt;parent, t);</div><div class="line">			l-&gt;color = BLACK;</div><div class="line">			l-&gt;left-&gt;color = RED;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	delete_case6(t, new_node, father_of_new_node);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">int delete_case4(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)</div><div class="line">&#123;//此时前提是，兄弟为黑色,（父亲，兄弟的两个孩子不全为黑色)</div><div class="line">	RBT_Node*l, *r;</div><div class="line">	if (father_of_new_node-&gt;left == new_node)</div><div class="line">	&#123;</div><div class="line">		l = father_of_new_node-&gt;right-&gt;left;</div><div class="line">		r = father_of_new_node-&gt;right-&gt;right;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		l = father_of_new_node-&gt;left-&gt;left;</div><div class="line">		r = father_of_new_node-&gt;left-&gt;right;</div><div class="line">	&#125;</div><div class="line">	if ((NULL == l || l-&gt;color == BLACK) &amp;&amp; (NULL == r || r-&gt;color == BLACK) &amp;&amp; father_of_new_node-&gt;color == RED)</div><div class="line">	&#123;</div><div class="line">		father_of_new_node-&gt;color = BLACK;</div><div class="line">		getBrother(new_node)-&gt;color = RED;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	else  delete_case5(t, new_node, father_of_new_node);</div><div class="line"></div><div class="line">&#125;</div><div class="line">int delete_case3(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)</div><div class="line">&#123;//此时前提是，兄弟为黑色</div><div class="line">	RBT_Node*l, *r;</div><div class="line"></div><div class="line">		if (father_of_new_node-&gt;left == new_node)</div><div class="line">		&#123;</div><div class="line">			l = father_of_new_node-&gt;right-&gt;left;</div><div class="line">			r = father_of_new_node-&gt;right-&gt;right;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			l = father_of_new_node-&gt;left-&gt;left;</div><div class="line">			r = father_of_new_node-&gt;left-&gt;right;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">		if ((NULL==l||l-&gt;color==BLACK)&amp;&amp;(NULL==r||r-&gt;color==BLACK)&amp;&amp;father_of_new_node-&gt;color == BLACK)</div><div class="line">		&#123;//父亲和兄弟以及兄弟的孩子都是黑的，将兄弟染红，递归调用</div><div class="line">			</div><div class="line">			if (father_of_new_node-&gt;left == new_node)</div><div class="line">			&#123;</div><div class="line">				father_of_new_node-&gt;right-&gt;color = RED;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				father_of_new_node-&gt;left-&gt;color = RED;</div><div class="line">			&#125;</div><div class="line">			int delete_adjust(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node, int deletedColor);</div><div class="line">			delete_adjust(t, father_of_new_node, father_of_new_node-&gt;parent, BLACK);//递归</div><div class="line">		&#125;</div><div class="line">		else delete_case4(t, new_node, father_of_new_node);</div><div class="line"></div><div class="line">		return 0;</div><div class="line">&#125;</div><div class="line">int delete_case2(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)</div><div class="line">&#123;</div><div class="line">	//case2</div><div class="line">		</div><div class="line">			if (getBrother(new_node))//实际上brother不可能为空</div><div class="line">			&#123;</div><div class="line">				if (getBrother(new_node)-&gt;color == RED)</div><div class="line">				&#123;//新节点兄弟是红的，也就决定了父亲是黑的，且兄弟的二个儿子是黑的</div><div class="line">					if (father_of_new_node-&gt;left = new_node) </div><div class="line">					&#123;</div><div class="line">						RBT_adjust_LL(father_of_new_node, t);</div><div class="line">					&#125;</div><div class="line">					else</div><div class="line">					&#123;</div><div class="line">						RBT_adjust_RR(father_of_new_node, t);</div><div class="line">					&#125;</div><div class="line">					father_of_new_node-&gt;parent-&gt;color = BLACK;</div><div class="line">					father_of_new_node-&gt;color = RED;</div><div class="line">				&#125;</div><div class="line">				 </div><div class="line">			&#125;</div><div class="line">			delete_case3(t, new_node, father_of_new_node);</div><div class="line">			return 0;</div><div class="line">		</div><div class="line">	</div><div class="line">&#125;</div><div class="line">int delete_adjust(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node, int deletedColor) &#123;</div><div class="line">	//parent_of_deleted至多含有一个非空节点</div><div class="line">	//传来的参数给出了被删除节点的颜色,被删除节点的父亲</div><div class="line">	if (deletedColor == RED)return 0;</div><div class="line">	if (new_node&amp;&amp;new_node-&gt;color == RED) &#123;</div><div class="line">		//被删掉的是黑色，新顶替上来的是红色</div><div class="line">		new_node-&gt;color = BLACK; return 0;</div><div class="line">	&#125;</div><div class="line">	else </div><div class="line">	&#123;//被删掉的是黑色，新顶替上来的是黑色or空，这样这条路径就少了一个黑色</div><div class="line">			//case1</div><div class="line">		if (NULL == father_of_new_node)return 0;</div><div class="line">		else  delete_case2(t,new_node,father_of_new_node);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">int RBT_delete(RBTree&amp; t, RBT_Node*p, int n) &#123;</div><div class="line">	if (p == NULL) &#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	RBT_Node* temp = NULL;</div><div class="line">	if (n == p-&gt;key) &#123;</div><div class="line">		if ((!(p-&gt;left)) &amp;&amp; (!(p-&gt;right))) &#123;//leaf node</div><div class="line">			temp = p;</div><div class="line">			if (!p-&gt;parent) &#123;//是树内唯一根节点</div><div class="line">				t.root = NULL;</div><div class="line">				delete p;</div><div class="line">				return 0;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			if (p-&gt;parent-&gt;right == p) &#123; </div><div class="line">				p-&gt;parent-&gt;right = NULL; </div><div class="line">				delete_adjust(t,temp-&gt;parent-&gt;right ,temp-&gt;parent,0);</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				p-&gt;parent-&gt;left = NULL;</div><div class="line">				delete_adjust(t, temp-&gt;parent-&gt;left,temp-&gt;parent, 0);</div><div class="line">			&#125;</div><div class="line">			delete p;</div><div class="line">			return 0;</div><div class="line">		&#125;</div><div class="line">		else if (p-&gt;left) &#123;//若左子树存在则找出左最大的</div><div class="line">			temp = p-&gt;left;</div><div class="line">			while (temp-&gt;right != NULL) &#123;</div><div class="line">				temp = temp-&gt;right;</div><div class="line">			&#125;</div><div class="line">			p-&gt;key = temp-&gt;key;//复制key</div><div class="line">			 </div><div class="line">				//if (temp-&gt;parent-&gt;right == p) p-&gt;parent-&gt;right = NULL;</div><div class="line">				//else temp-&gt;parent-&gt;left = NULL;</div><div class="line">				if (temp-&gt;parent-&gt;left == temp)</div><div class="line">				&#123;</div><div class="line">					temp-&gt;parent-&gt;left = temp-&gt;left;</div><div class="line">					if (temp-&gt;left != NULL)temp-&gt;left-&gt;parent = temp-&gt;parent;</div><div class="line">					delete_adjust(t, temp-&gt;parent-&gt;left,temp-&gt;parent,temp-&gt;color);</div><div class="line">				&#125;</div><div class="line">				else</div><div class="line">				&#123;</div><div class="line">					temp-&gt;parent-&gt;right = temp-&gt;left;</div><div class="line">					if (temp-&gt;left != NULL)temp-&gt;left-&gt;parent = temp-&gt;parent;</div><div class="line">					delete_adjust(t, temp-&gt;parent-&gt;right, temp-&gt;parent, temp-&gt;color);</div><div class="line">				&#125;</div><div class="line">				delete temp;</div><div class="line">				return 0;//调整</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		else if (p-&gt;right) &#123;//找右边最小的</div><div class="line">			temp = p-&gt;right;</div><div class="line">			while (temp-&gt;left != NULL) &#123;</div><div class="line">				temp = temp-&gt;left;</div><div class="line">			&#125;</div><div class="line">			p-&gt;key = temp-&gt;key;//复制key</div><div class="line">			if (temp-&gt;parent-&gt;left == temp)</div><div class="line">			&#123;</div><div class="line">				temp-&gt;parent-&gt;left = temp-&gt;right;</div><div class="line">				if (temp-&gt;right != NULL)temp-&gt;right-&gt;parent = temp-&gt;parent;</div><div class="line">				delete_adjust(t, temp-&gt;parent-&gt;left, temp-&gt;parent, temp-&gt;color);</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				temp-&gt;parent-&gt;right = temp-&gt;right;</div><div class="line">				if (temp-&gt;right != NULL)temp-&gt;right-&gt;parent = temp-&gt;parent;</div><div class="line">				delete_adjust(t, temp-&gt;parent-&gt;right, temp-&gt;parent, temp-&gt;color);</div><div class="line">			&#125;</div><div class="line">			delete temp;</div><div class="line">			return 0;//调整</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;//p-&gt;key==n</div><div class="line">	else &#123;</div><div class="line">		if (n &gt; p-&gt;key) &#123;</div><div class="line">			RBT_delete(t, p-&gt;right, n);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		else &#123;</div><div class="line">			RBT_delete(t, p-&gt;left, n);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义两种遍历，用于输出树的形态，方便调试。<br>前序遍历不必多讲，这个层序遍历我做了换行，一层输出一行，并且红色节点用[]，黑色节点用（），空的位置用+占位，使得二叉树能够可视化表示出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//遍历输出</div><div class="line">int pre_Treverse(RBT_Node* t) &#123;</div><div class="line">	if (t == NULL)</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	pre_Treverse(t-&gt;left);</div><div class="line">	cout &lt;&lt; t-&gt;key &lt;&lt; &quot; &quot;;</div><div class="line"></div><div class="line">	pre_Treverse(t-&gt;right);</div><div class="line">&#125;</div><div class="line">//层序遍历</div><div class="line">int levelOrder_traverse(RBTree t) &#123;</div><div class="line">	/*</div><div class="line">	此函数用于层序使出二叉树，红色节点用[]，黑色节点用（），空的位置用+占位</div><div class="line">	*/</div><div class="line">	if (t.root == NULL)return -1;</div><div class="line">	vector&lt;RBT_Node*&gt; vec;</div><div class="line">	vec.push_back(t.root);</div><div class="line">	int cur = 0;</div><div class="line">	int num_of_nextlevel = 1;</div><div class="line">	int num_of_nextlevel_notnull = 0;</div><div class="line">	int step_of_thislecel = 100;</div><div class="line">	while (cur&lt;vec.size())</div><div class="line">	&#123;</div><div class="line">		for (int i = 0; i &lt; num_of_nextlevel; i++) &#123;</div><div class="line"></div><div class="line">			if (vec.at(cur) == NULL) &#123;</div><div class="line">				vec.push_back(NULL); vec.push_back(NULL);</div><div class="line">				cout &lt;&lt; &quot;+&quot;;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				if (vec.at(cur)-&gt;color == BLACK)</div><div class="line">				&#123;</div><div class="line">					cout &lt;&lt;&quot;[&quot;&lt;&lt; vec.at(cur)-&gt;key&lt;&lt;&quot;]&quot;;</div><div class="line">				&#125;</div><div class="line">				else</div><div class="line">				&#123;</div><div class="line">					cout &lt;&lt; &quot;(&quot; &lt;&lt; vec.at(cur)-&gt;key &lt;&lt; &quot;)&quot;;</div><div class="line">				&#125;</div><div class="line">				if (vec.at(cur)-&gt;left != NULL) &#123; vec.push_back(vec.at(cur)-&gt;left); num_of_nextlevel_notnull++; &#125;</div><div class="line">				else &#123; vec.push_back(NULL); &#125;</div><div class="line">				if (vec.at(cur)-&gt;right != NULL) &#123; vec.push_back(vec.at(cur)-&gt;right); num_of_nextlevel_notnull++; &#125;</div><div class="line">				else &#123; vec.push_back(NULL); &#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			cur++;</div><div class="line">		&#125;</div><div class="line">		cout &lt;&lt; endl;</div><div class="line">		step_of_thislecel /= 2;</div><div class="line">		num_of_nextlevel *= 2;</div><div class="line">		if (num_of_nextlevel_notnull == 0) break;</div><div class="line">		num_of_nextlevel_notnull = 0;</div><div class="line"></div><div class="line">	&#125;//while end</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main函数现身，程序终于完了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">	RBTree T = &#123; NULL &#125;;</div><div class="line">	for (int i = 0; i &lt; 20; i++) &#123;</div><div class="line">		RBT_insert(T.root, T, i);</div><div class="line">	&#125;</div><div class="line">    pre_Treverse(T.root);</div><div class="line">	cout &lt;&lt; endl;</div><div class="line">	levelOrder_traverse(T);</div><div class="line">	cout &lt;&lt; endl;</div><div class="line">	RBT_delete(T, T.root, 7);</div><div class="line">	levelOrder_traverse(T);</div><div class="line">	cout &lt;&lt; &quot;hello&quot;;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">	return 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：</p>
<blockquote>
<p><img src="http://oqqy3xbdd.bkt.clouddn.com/Casdfsdfsdfsdpture.PNG" alt="运行结果"><br>我先顺序插入了20个节点，前序输出，然后层序输出。<br>然后删除了根节点7，再层序输出，可以看出，树的建立和节点删除没有问题，不过我对软件测试不太了解，也不保证没有bug，但是经过这个过程，对红黑树原理有了更深了解，要debug也不会素手无策了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自己实现一个ping程序]]></title>
      <url>/2017/05/20/2017-05-20-python-ping/</url>
      <content type="html"><![CDATA[<p>小时候不太会玩电脑，一般自己玩的时候流程是：开始–附加功能–游戏与娱乐。</p>
<p>倘若旁边有妹子在围观，我便会win+R—–cmd—-ping baidu.com.然后看着屏幕上跳出一行行数字，假装自己看得懂的样子，过一会儿再慢悠悠地打开太空弹球玩起来</p>
<p>现在想起来真的是图样图森破，甚至还非常naive啊。</p>
<p>这个ping程序算是我对计算机最早的认识了，作为一个生活在图形界面时代的人类，这也是我第一次知道了命令行形式的人机交互。</p>
<p>之前学习了计算机网络的知识，知道了它的原理其实是利用ICMP协议的回显请求来实现的，通过构造ICMP报文向目的主机发出，然后接收返回报文，计算经过的时间，就能计算出主机到目的主机之间的RTT（Round Trip Time），也就是我们平时讲的延迟。</p>
<p>由于ICMP工作在网络层,不能保证交付，也不保证顺序，所以发送多个请求的时候，可能会出现乱序的情况，于是ping程序中在数据段保存包本身的发送时间，接收到之后用系统时间减去报文中读取的时间即可得到RTT。为了简化过程，我在此只发送一个报文。<br>要构造ICMP包，首先要知道其格式，</p>
<blockquote>
<p>Type （8bit）     |     Code（8bit）   |          Checksum       （16bit）  |           Identifier        （16bit）  |       Sequence Number   （16bit）  |     Data …<br>我们要用到的是回显请求，对应type是8，code是0，checksum要通过特定的算法获得，其他部分自己处理即可。</p>
</blockquote>
<pre><code>import socket
import  array,struct,time,select
def checksum(data):
if(len(data)%2!=0):
    data+=b&apos;\x00&apos;
a=array.array(&apos;H&apos;,data)
s=0
for d in a:
    s=s+d
s=(~s)&amp;0xffff
return s
</code></pre><p>这段代码将已经除checksum以外其它打包好的数据进行一系列计算，得到一个16bit的数，用于差错检测，如果计算错误，服务器方不会响应，你也就接受不到响应的报文了。在编写网络程序的时候，调试时要利用抓包工具查看自己发出的报文的具体内容，否则难以得知自己错在何处。</p>
<pre><code>def send_packet(my_socket,destination_addr):
header=struct.pack(&apos;bbHh&apos;,8,0,1,1)
data=0
data=struct.pack(&apos;d&apos;,data)
checks=checksum(header+data)
packet=struct.pack(&apos;bbHHh&apos;,8,0,checks,1,1)+data
my_socket.sendto(packet,(destination_addr,1))
t=recive_ping(my_socket, 5)
print(t)

def recive_ping(my_socket,timeout):
timeleft=timeout
while True:
    starttime=time.time()
    select_=select.select([my_socket],[],[],timeleft)
    if select_[0]==[]:
        print(&quot;timeout&quot;)
        return -1
    t=time.time()-starttime
    return  t
</code></pre><p>这两个函数一起完成了报文的构造和发送，这其中用到了raw类型socket，select用于接收数据，由于数据要翻译成二进制发送，直接连接字符串肯定是不行的，所以要用struct将数据打包。</p>
<pre><code>def do(addr):
icmp=socket.getprotobyname(&apos;icmp&apos;)
s=socket.socket(socket.AF_INET,socket.SOCK_RAW,icmp)
send_packet(s, addr)

do(&quot;220.181.57.217&quot;)
</code></pre><p>这就是程序的入口了，运行效果就不贴了，反正就是打印出一个浮点数。</p>
<p>与ping相似的另一个traceroute，实现原理也类似，它利用的是ip头部的TTL,通过构造指向目的主机的ttl从1递增的数据包，就能获得源主机到目的主机之间所有经过的路由，这可以在网上找到不少资料，此处不再赘述。</p>
<p>参考:[1]:<a href="https://bbs.ichunqiu.com/thread-8970-1-1.html" target="_blank" rel="external">https://bbs.ichunqiu.com/thread-8970-1-1.html</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[huffman树及编码的实现]]></title>
      <url>/2017/05/03/2017-05-03-hufmantree/</url>
      <content type="html"><![CDATA[<p>最近学到Huffman编码，于是想要实现出来看看，查阅了一些资料，就开始动手了。<br>首先整理一下思路，Huffman编码关键是构造huffman树，输入字母表以及对应权重，构建Huffman树；由Huffman树即可生成Huffman码和字母表的映射。</p>
<p>由于hufgman树的特殊性，节点的度只有0和2，只有叶子结点代表字母，其他节点均为辅助接点，当有n个叶子的时候必然有n-1个辅助节点。考虑用连续存储来存放，具体来说就是个结构体数组。每个结构体中记录节点的字母，权重，父亲节点，孩子节点，没有的置为-1；在长度为2n-1的结构体数组中，前n个存放叶子结点，后n-1个存放辅助节点，初始的时候叶子结点都没有父亲节点，构建Huffman树的时候，只需要依次进行n-1轮插入辅助节点操作即可（没插入一个辅助节点就会导致森林中的树减少一个）。</p>
<p>首先定义一个hufTree类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include&quot;Windows.h&quot;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class hufTree &#123;</div><div class="line">private:</div><div class="line">	typedef struct hufNode &#123;</div><div class="line">		char alpha;</div><div class="line">		int weight;</div><div class="line">		int lChild, rChild, parent;</div><div class="line">	&#125;  *pNode;</div><div class="line"></div><div class="line">	int  _n;</div><div class="line">	int _m;//叶子数和总节点数</div><div class="line"></div><div class="line">	pNode huf_arr;</div><div class="line">	void getMintwo(int  flag,int *min1,int* min2);</div><div class="line">public:</div><div class="line">	 hufTree(char * alpha,int * weight,int N);//构造huf树，alpha为字母数组</div><div class="line">	 ~hufTree() &#123;&#125;;</div><div class="line">	string*  hufCodingtable();</div><div class="line">	string encode(string str,string * huftable, char * alpha);</div><div class="line">	string decode(string str, string * huftable, char * alpha);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由于要多次选取森林中权最小的两个树，所以，写成函数getMintwo（）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void hufTree::getMintwo(int  flag, int *min1, int* min2) &#123;</div><div class="line">	pNode hf = huf_arr;</div><div class="line">	*min1 = 0; *min2 = 1;</div><div class="line">	int weight1=9999, weight2=9999;</div><div class="line">	for (int i = 0; i &lt; flag;i++)</div><div class="line">	&#123;</div><div class="line">		if ((hf[i].parent == -1) &amp;&amp; (hf[i].weight &lt; weight1)) &#123; *min1 = i; weight1 = huf_arr[i].weight; &#125;</div><div class="line">		else if ((hf[i].parent == -1) &amp;&amp; (hf[i].weight &lt; weight2)) &#123; *min2 = i; weight2 = huf_arr[i].weight; &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重载构造函数，实现Huffman树的构建,这里最开始的时候，申请长度为2n-1的结构体数组空间，然后将前n个初始化为叶子结点，并且没有父亲节点（独立成为一棵树）和孩子节点，之后在插入辅助接点形成新树删除旧树之时只需改变元素之间的父子关系即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//构造huf树</div><div class="line">hufTree::hufTree(char * alpha, int * weight, int N) &#123;</div><div class="line">	char* tmp=new char[20];</div><div class="line">	_n = N;</div><div class="line">	_m = N * 2 - 1;</div><div class="line">	huf_arr = new hufNode[_m];</div><div class="line">	for (int i = 0; i &lt; _n; i++)</div><div class="line">	&#123;</div><div class="line">		huf_arr[i].alpha = alpha[i];</div><div class="line">		huf_arr[i].parent = -1;</div><div class="line">		huf_arr[i].lChild = -1;</div><div class="line">		huf_arr[i].rChild = -1;</div><div class="line">		huf_arr[i].weight = weight[i];</div><div class="line">		//*tmp = huf_arr[i].alpha;</div><div class="line">		//OutputDebugStringA(tmp);</div><div class="line">	&#125;</div><div class="line">	int min1, min2;</div><div class="line">	for (int i = _n; i &lt; _m; i++)</div><div class="line">	&#123;</div><div class="line">		getMintwo(i,&amp;min1,&amp;min2);</div><div class="line">		huf_arr[i].parent = -1;</div><div class="line">		huf_arr[i].lChild = min1;</div><div class="line">		huf_arr[i].rChild = min2;</div><div class="line">		huf_arr[min1].parent = i;</div><div class="line">		huf_arr[min2].parent = i;</div><div class="line">		huf_arr[i].weight = huf_arr[min1].weight + huf_arr[min2].weight;</div><div class="line">	   </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后根据已有的Huffman树生成对应的编码映射表，此处应该有键值表，但是我嫌麻烦，所以直接用两个平行的数组分别存放键和值(函数值返回hufman码表，和已知的字母表一一顺序对应)。方法是，从对应的叶子开始向上搜索到根节点，每次判断当前节点是父亲节点的左节点还是右节点，对应加入0或1，由于得到的码是反序的，最后将字符串反转后插入编码表即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">string* hufTree::hufCodingtable() &#123;</div><div class="line">	string* table = new string[_n];</div><div class="line">	for (int i = 0; i &lt; _n; i++)</div><div class="line">	&#123;</div><div class="line">		int cur = i,parent=huf_arr[i].parent;</div><div class="line">		string tmp = &quot;&quot;;</div><div class="line">		while (parent!=-1) &#123;</div><div class="line">			if (huf_arr[parent].lChild==cur)</div><div class="line">			&#123;</div><div class="line">				tmp += &quot;0&quot;;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				tmp += &quot;1&quot;;</div><div class="line">			&#125;</div><div class="line">			cur = parent;</div><div class="line">			parent = huf_arr[cur].parent;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		reverse(tmp.begin(),tmp.end());</div><div class="line"></div><div class="line">		table[i] = tmp;</div><div class="line">	&#125;</div><div class="line">	return table;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编码和解码函数，编码函数很简单，每次取出一个字符，将其对应Huffman码值查出后加到输出字符串即可；解码函数由于每个码长短未知，所以设置一个buffer变量，每次读入一个二进制位到buffer，比对Huffman码表是否有相应的字母，如有，取出加入输出字符串后，buffer归零；若无，则在buffer中再加入一个二进制位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">string hufTree::encode(string str, string * huftable, char * alpha)</div><div class="line">&#123;</div><div class="line">	string tmp = &quot;&quot;;</div><div class="line"></div><div class="line">	int len = str.length();</div><div class="line">	for (int i = 0; i &lt; len; i++)</div><div class="line">		for (int  j = 0; j &lt; _n; j++)</div><div class="line">		&#123;</div><div class="line">		if (huf_arr[j].alpha==str.at(i))</div><div class="line">			&#123;</div><div class="line">			tmp += huftable[j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	return tmp;</div><div class="line">&#125;</div><div class="line">string hufTree::decode(string str, string * huftable, char * alpha)</div><div class="line">&#123;</div><div class="line">	string tmp = &quot;&quot;;</div><div class="line">	string buffer = &quot;&quot;;</div><div class="line">	int len = str.length();</div><div class="line">	for (int i = 0; i &lt; len; i++)</div><div class="line">	&#123;</div><div class="line">		buffer += str.at(i);</div><div class="line"></div><div class="line">		for (int j = 0; j &lt; _n; j++)</div><div class="line">		&#123;</div><div class="line">			if (huftable[j] == buffer)</div><div class="line">			&#123;</div><div class="line">				tmp += alpha[j];</div><div class="line">				buffer = &quot;&quot;;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后就是主函数了,..以前上课老爱用getchar停住cmd黑框，今天忽然掉进个坑，我把黑框关闭后再去修改了代码后就出现lnk1168错误，原因是之前那个程序根本没停，我去任务管理器试图关闭发现关闭不了，估计是没给它个char他不甘心停止吧。所以改成了system（“pause”），暂时还没出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	char  alpha[] = &#123; &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos; &#125;;</div><div class="line">	int   weight[] = &#123; 1,2,3,4,5,6,7 &#125;;</div><div class="line">	hufTree hf(alpha,weight,7);</div><div class="line">    string str = &quot;abcdefg&quot;;</div><div class="line">	string encode=hf.encode(str,hf.hufCodingtable(),alpha);</div><div class="line">	cout &lt;&lt; encode;</div><div class="line">	string decode = hf.decode(encode,hf.hufCodingtable(),alpha);</div><div class="line">	cout &lt;&lt; decode;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>011001110101101110010<br>abcdefg<br>Press any key to continue . . .</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[秘技---------气象操控术！！]]></title>
      <url>/2017/04/10/2017-04-10-jzm&amp;weather/</url>
      <content type="html"><![CDATA[<p>气象学是一门极其困难的科学，究其原因，主要是气象学模型复杂，扰动条件相当多，导致时常有不符合模型的情况出现，这在专业上称作‘奇点’。<br>今天我们讲讲中国气象学上几个著名的奇点。</p>
<p>1985年5月，戈尔巴乔夫访华，国家主席杨尚昆和未来的总书记江先生一同接见了这位苏共总书记。<br>江主席亲切的说：“由于您的到来，上海的天气好转了。”戈尔巴乔夫回应：“特别令人高兴的是，中苏关系好转了”。</p>
<p><img src="http://upload.ouliu.net/i/20170410233443ihv0i.jpeg" alt="戈尔巴乔夫访华"></p>
<p>2009年，江主席视察旧部国机二院。会议中，中国著名气象专家徐嘉诰笑着说：“天气预报本来说今天有雨，结果江主席一来，天气晴朗”。</p>
<p><img src="http://upload.ouliu.net/i/20170410233720bdiro.jpeg" alt="二院天气变化"></p>
<p>科学研究需要敏锐的嗅觉，通过对以上两个案例的分析，很多人发现两个事件中共同点就是有他在场，于是做出结论，他拥有气象操控术这样一种失传已久的秘技，上一次这个秘技展示在众人眼前，还是东汉末年。</p>
<p>斗转星移，到了2017年，我看到这样一篇新闻报道：</p>
<p><img src="http://upload.ouliu.net/i/2017041023375122g4j.jpeg" alt="芬兰天气转变"></p>
<p>之前网友盛传他拥有秘技的谣言不攻自破，倘若真是秘技重现江湖，就目前的情形来看，他并不是唯一掌握这种秘技的人，至少他那位胖嘟嘟的继任者也拥有同样的能力。<br>历史的脉搏是这么的有力，在波澜壮阔的长河里一次又一次不紧不慢的展示出自己的迷人之处。无论真相如何，我们作为芸芸众生中微不足道的一员，只能感叹：历史总是惊人的相似！</p>
]]></content>
      
        <categories>
            
            <category> 幽默 </category>
            
        </categories>
        
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>

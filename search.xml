<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Group testing]群组测试：毒药谜题]]></title>
    <url>%2F2019%2F04%2F28%2FGroup-testing%2F</url>
    <content type="text"><![CDATA[问题背景这个问题在统计学和组合数学领域被称为群组测试问题(Group testing),问题源于二战时期，美国需要通过血样检测美军是否携带梅毒，但是当时血液检测耗时耗钱，将每个士兵的血液都检查一遍效率很低。考虑到携带梅毒的总归是少数，Rosenblatt和Dorfman提出将全部待检测士兵的血样分组混合后再检测，如果混合后的血样没有病毒，可以推定整个组都没有病毒，如此便能够减少不必要的检测。 将以上问题标准化描述如下： 给定集合N，其中有n个个体，每个个体要么是正例(Positive)要么是负例(Negative)，记其中正例个数为d。 目标：通过尽量少的测试次数，找出所有的负例。 群组测试(Group testing)：在N 的一个子集上测试（与在每个个体上测试相对）。 这样做有一个前提：d&lt;&lt; n；可以设想，如果一个集合N当中大多数都是正例，那你随便找个子集，大概率都是含有正例的， 那么就不能达到排除一个子集的效果，这个方法就失去意义了。 Katona在1976年介绍了一种矩阵表示法，只需要$ \log_2{n} $次测试即可检测出n个样本中的一个正例，并且证明的其最优性。这个方法就是被各个互联网公司面试题疯狂引用的1000瓶药中有一瓶有毒，要求用最少的小白鼠检测出这一瓶毒药的题目。我也刷过，但是不得不吐槽，起码对我来讲，倘若没见过这个题目的解法，要想自己独立思考出来，可以说是难如登天，即使有些人能够写下解法，但是这个“最优”一词，可能很少有人能说上来其中的原因。反正大加面试题抄来抄去，也没有认真想过为什么要出这么个面试题，可能面试官觉得自己已经背过了，不出给别人觉得浪费。 吐槽完了还是简单说说这个题目的解法，就免得部分同学再点到其他网页游览一圈了。将1000只老鼠用二进制的$ (1) _{10} $到$ (1000) _{10} $编上序号，需要10位二进制码，然后把序号第1位为1的药混合在一起喂给老鼠1，….然后把序号第10位为1的药混合在一起喂给老鼠10。假设老鼠i死掉了，那么可以推定毒药的编号的第i位是1，把每只老鼠的实验结果综合起来，就能得到毒药编号的每一位，毒药就找出来了。另外，前述的此法所需测试次数 $ \log_2{n} $ 实际上就是所需二进制编码的位数。 一般，对上述从n个样本中寻找一个正例的问题，很容易能想到的就是采用二分法去寻找，把样本分成两份，分别进行群组测试，那么只有一个能包含正例，所以，排除一半，对另一半进行检测····使用此法也能在$ \log_2{n} $次检测结束后找到解。不过此法与Katona的方法区别在于，此法是多阶段的决策(adaptive Algorithm)，比如第二次对哪一拨进行测试，要根据第一次的测试结果来确定。但是Katona方法则不同，其在测试开始前即可确定全部的测试群组的划分(non-adaptive Algorithm)。 以上的只是一些老生常谈的问题，可能大家都看过无数遍了，我为甚么又要提起这个问题，还要谁个博文呢？主要是我昨天参加了IGG的线上笔试题，这个公司不走寻常路，出了一个这个问题的加强版，也就是在n个样本中寻找d个正例。这种题一下子就触及到我这样的刷题党的知识盲区了，因为之前没见过，要现场想出个解法太难了。 但是当时我还是大致写了个方法，不过不严密，当时也想的比较混乱。大致思想如下，既然已知其中有d个正例，我直接把样本随机分为d份，然后分别进行群组测试，按照鸽笼原理和统计学常识，这些正例恰好每组一个的概率是不太大的，所以能够淘汰掉一些群组。一直重复这个过程就能够排除掉很多负例。但是达到一定程度(在剩余样本里正例占比很大的时候)，就不能再采用分组测试了，应该采用单独测试。后来我去查阅文献，发现这个思想和文章[1]类似。 -信息论下界从信息论讲，这个问题(仅有一个正例)一定有一个下界。因为每次测试只有两个输出信息—正例or负例，因此进行k次测试最多表示$2^k$种信息状态，因此，至少要$ \log_2{n} $次测试才能获得足够的信息，因此，下界为$ \log_2{n} $。同理，对于d个正例的情况，下界为$ \log_2{n \choose d} $。当然，下界一般而言是难以达到的。 解法1：可以简单地想到一种解法，利用二分法去解决，首先把n个样本分成两份进行检测，有毒（正例）的群组继续检测，没毒的部分排除，一直重复这个过程直到剩下的样本总数等于d，就找到所有的正例了。这个方法实际上就是算法中常用的剪枝的思想，剪枝越早，效率越高，假设你运气好，没走几步就只剩下d个可疑样本了，那就直接求出结果了。再来看看它的复杂度，由于其中只有d个样本是正例，那么在二叉搜索树的某一个层上最多只有d个节点能被检测出正例，而二叉树的深度是$ \log_2{n} $，所以复杂度为$O(d \log_2{n} )$。而哪个IGG笔试的题目实际上就是要求这个复杂度，只能说考试总是这样，交卷了思维才会清晰起来，呵呵。 但是这个方法也不是没有问题，因为它是adaptive的，需要的时间复杂度是$ \log_2{n} $，也就是要进行至多$ \log_2{n} $次的试验。如果题目要求一次就测出来，那么就还需要一个提前决定测试分组的编码方案，并且在测试结果出来之后能够解码得出到底哪些是正例。由于我对类问题兴趣不大，所以暂时不想深究,有兴趣的可以去文献[3]尝试寻找答案。 最近比较忙，倘若日后有空再去看这个问题，如果你有了自己的见解欢迎分享给我，万分感谢。 //TODO [1]: Li, Chou Hsiung (June 1962). “A sequential method for screening experimental variables”. Journal of the American Statistical Association. 57 (298): 455–477. doi:10.1080/01621459.1962.10480672[2]:https://en.wikipedia.org/wiki/Group_testing[3]:Ding-Zhu, Du; Hwang, Frank K. (1993). Combinatorial group testing and its applications. Singapore: World Scientific. ISBN 978-9810212933.]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Person-Curve:使用数学公式绘制你的爱豆]]></title>
    <url>%2F2018%2F08%2F14%2F2018-02-09%E8%A5%BF%E6%96%B9%E7%9A%84%E5%9B%BD%E5%AE%B6%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（大合集）各种排序算法的介绍与实现]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-5-sort_agrithon%2F</url>
    <content type="text"><![CDATA[写在前边：这篇文章又臭又长，纯属个人无聊总结之作。 [TOC] 排序算法在计算机界是很基础，很重要的，对人类也是至关重要的，没有排序算法，就难以把人类分成三六九等，区别对待了，那样的世界是多么恐怖啊。 为了演示方便，此文排序的对象都是一个int类型的vector，其中交换两个元素，采用了位运算，至于为什么，第一是我恰好会，第二是，我认为这三行写在一起有一种独特的美感。123vec[i]=vec[j]^vec[i];vec[j]=vec[j]^vec[i];vec[i]=vec[j]^vec[i]; (看起来似乎有点画蛇添足了，还不如。sort()……)。 1.菜鸟排序这个排序算法，是所有学生最开始接触编程的时候碰到的一个算法，其地位就像是&gt;hello world！&lt;在IT界的地位一般，所以必须放在开头。 其思想相当接近大多数常人的思维，从前向后，对每个位置，都从当前位置开始，向后面扫描，如果发现一个元素比当前位置的值大，就把它，交换过来。 这个算法，大约进行（n到1求和）次比较操作，所以复杂度是O(n^2)。123456789101112131415161718192021/*noob sort*/int noob_sort(vector&lt;int&gt;&amp; vec )&#123; int i,j; for(i=0;i&lt;vec.size()-1;i++) &#123; for(j=i+1;j&lt;vec.size();j++) &#123; if(vec[j]&gt;vec[i]) &#123; vec[i]=vec[j]^vec[i]; vec[j]=vec[j]^vec[i]; vec[i]=vec[j]^vec[i]; &#125; &#125; &#125; return 0;&#125; 2. 选择排序（selected sort）一般同学们学到了上面那个算法，老师们就会指出，其中的很多交换是不必要的，如果我们先找出当前元素后面最大或者最小的元素，就能只用一次交换将一个元素放到正确的位置。于是就有了如下算法，用一个变量存储，后边的元素中最大或最小的元素下标，在遍历完之后才进行交换操作，减少了交换的次数，提高了效率。 不过它的复杂度依然是O(n^2)，因为这种优化带来的效果是操作次数常数倍的减少，决定这个算法效率的关键是比较的次数，这一类依赖于比较的算法，可以严格证明它们的复杂度是有下限的，稍后将会看到这样的算法。1234567891011121314151617181920212223242526/*selected sort*/int selected_sort(vector&lt;int&gt;&amp; vec )&#123; int i,j,k; for(i=0;i&lt;vec.size()-1;i++) &#123; k= i; for(j=i+1;j&lt;vec.size();j++) &#123; if(vec[j]&gt;vec[k]) &#123; k=j; &#125; &#125; vec[i]=vec[k]^vec[i]; vec[k]=vec[k]^vec[i]; vec[i]=vec[k]^vec[i]; &#125; return 0;&#125; 3. 冒泡排序（bubble sort）这个算法的思想是从左往右去遍历数组，每次比较相邻两个元素的大小，如果其大小和你需要的大小关系相反（假设需要从大到小排序，那么你需要的排序结果左边的元素一定大于等于右边的元素），就交换两个元素的位置，这样一次从左到右的遍历，就能把最小的元素放到最后面去，这个最小的元素也就走到了它该去的地方，完成了历史的使命。第二次遍历的时候也就不用考虑这个元素了，具体来讲就是遍历范围的右边界减去1. 这个过程类似于每次把一个比较轻的泡泡冒出水面，所以这个算法叫做冒泡法。对于一个长度为n的数组，这个算法第i趟的时候需要比较n-i次，所以算法的复杂度依然是O(n^2)。123456789101112131415161718192021/*bubble sort*/int bubble_sort(vector&lt;int&gt;&amp; vec )&#123; int i,j; for(i=vec.size()-1;i&gt;0;i--) &#123; for(j=1;j&lt;i+1;j++) &#123; if(vec[j]&gt;vec[j-1]) &#123; vec[j]=vec[j-1]^vec[j]; vec[j-1]=vec[j-1]^vec[j]; vec[j]=vec[j-1]^vec[j]; &#125; &#125; &#125; return 0;&#125; 3. 鸡尾酒排序（cocktail sort）这个算法是冒泡排序的一个变种，它的具体做法就是来回冒泡，每次把一个泡泡冒到右边，然后把一个石子沉到水底，代码实现方面，用两个变量存储遍历的左右边界，每次从左向右遍历到头就将右边界减一后向左遍历，如此，直到左右边界重合，排序就完成了。这个算法相比于冒泡排序，性能上没有优化，复杂度依然是n^2只是过程显得更加酷炫狂拽，估计也就因此得名鸡尾酒，如果是中国人发明的估计应该命名洗剪吹算法。 12345678910111213141516171819202122232425262728293031323334/*cocktail sort*/int cocktail_sort(vector&lt;int&gt;&amp; vec )&#123; int i=0,j=vec.size()-1,k; while(j&gt;i) &#123; for(k=i;k&lt;=j-1;k++) &#123; if(vec[k]&lt;vec[k+1]) &#123; vec[k]=vec[k+1]^vec[k]; vec[k+1]=vec[k+1]^vec[k]; vec[k]=vec[k+1]^vec[k]; &#125; &#125; j--; if(j&gt;i) &#123; for(k=j-1;k&gt;=i;k--) &#123; if(vec[k]&lt;vec[k+1]) &#123; vec[k]=vec[k+1]^vec[k]; vec[k+1]=vec[k+1]^vec[k]; vec[k]=vec[k+1]^vec[k]; &#125; &#125; i++; &#125; &#125; return 0;&#125; 4. 插入排序（insertion sort）这个算法的思想依次选取待排数组中间的元素，插入到已经有序的数组内合适的位置，最终得到的元素序列就是有序的。初始的时候，我们从待排数组左边选择一个元素当作是已经有序的数组。 分析它的复杂度我们主要看发生的比较的次数，插入的时候我们是有序数列的从一侧向另一侧遍历，如果运气好，比较一次就找到了它应该在的位置，如果数组本身是反序的，你每次都要从左到右把已经有序的部分比较完才能找到其应该的位置。所以这个算法的复杂度和以上几个有了不一样的地方，有最好的和最坏的情况，这种情形用复杂度的期望来衡量复杂度是比较自然而然的做法。 总共需要插入n次，第i次插入操作平均会比较（i-1）2次，所以他的期望的复杂度为O（n^2/2）==O(n^2). 插入排序实际上可以优化到O(nlog(n),插入的时候采用二分法插入即可。1234567891011121314151617181920212223/*insertion sort*/int insertion_sort(vector&lt;int&gt;&amp; vec )&#123; int i,j; for(i=1;i&lt;vec.size();i++) &#123; for(j=i;j&gt;0;j--) &#123; if(vec[j]&gt;vec[j-1]) &#123; vec[j]=vec[j-1]^vec[j]; vec[j-1]=vec[j-1]^vec[j]; vec[j]=vec[j-1]^vec[j]; &#125; else&#123;break;&#125; &#125; &#125; return 0;&#125; 5. 堆排序（heap sort）堆排序是利用了堆的特性，根据大根堆的定义，堆的根就是整个堆当中最大的一个元素，那么我们不断的去取出这个根（由于取出后会重建堆，导致新的根被选出来），那么得到的数列就是有序的了。 所以说这个算法关键在建一个堆，此处采用线性存储结构，直接用数组存储堆，为了原地排序，我们取出堆的根之后，重建堆，这样尾端就会空出一个位置，把取出的元素放到这个位置，等堆的元素个数为1的时候，数组就有序了。 若我们不看堆的操作，这个算法就需要n-1次操作就能完成任务啦，现实是我们必须考虑每次取出堆头后堆的重建。由于堆是完全二叉树，所以这个树的深度最多log(n)+1,根据堆调整过程，最多log(n)次的比较交换就能完成调整。所以算法复杂度为O（n*log(n)），这个数字就是比较类算法的复杂度的下限，可见它是一种很快的算法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* heap sort*/int rebuild_heap(vector&lt;int&gt;&amp; vec,int n,int size)&#123; int largest=n; if(2*n&gt;size)&#123;return 0;&#125; if(2*n&lt;=size) &#123; if(vec[n]&lt;vec[2*n]) &#123; largest=2*n; &#125; else largest=n; &#125; if(2*n+1&lt;=size) &#123; if(vec[2*n+1]&gt;vec[largest]) &#123; largest=2*n+1; &#125; &#125; if(largest!=n) &#123; vec[n]=vec[n]^vec[largest]; vec[largest]=vec[n]^vec[largest]; vec[n]=vec[n]^vec[largest]; rebuild_heap(vec,largest,size); &#125; return 0;&#125;int build_heap(vector&lt;int&gt;&amp; vec )&#123; for(int i=vec.size()-1;i&gt;0;i--) &#123; rebuild_heap(vec,i,vec.size()-1); &#125; return 0;&#125;int heap_sort(vector&lt;int&gt;&amp; vec )&#123; int i,size; size=vec.size()-1; /*build heap*/ build_heap(vec); for(i=size;i&gt;1;i--) &#123; vec[1]=vec[size]^vec[1]; vec[size]=vec[size]^vec[1]; vec[1]=vec[size]^vec[1]; /*1和size位置的值交换*/ size--; rebuild_heap(vec, 1, size); &#125; return 0;&#125; 桶排序（ bucket sort）这个算法的思想是，给出一列有顺序的桶，每个桶编上号，从待排数列中取出一个元素，放到对应标号的桶里，这个操作在程序实现的时候极其方便，用数组的下标作为桶号，只需要一个赋值语句即可，对应桶的位置上的数字，用来标记桶号在待排数组内出现的次数。 输出的时候，按顺序扫描桶，若桶是空的，就跳过，若不空就根据桶中的数字输出相应个数的元素。 根据原理，很显然，只需要一次遍历就能把元素放进桶内，再一次便利桶即可输出有序的元素，为保证每个元素都能找到属于自己的桶，桶的个数需要包含待排数组的最小和最大值中间的所以情况。倘若待排数组长度n，桶个数m，那么算法的空间复杂度就是O(m)，时间复杂度就是O(n+m). 这似乎打破了前述的nlog(n)的复杂度下限，其实不然，之前说的复杂度下限，是直的基于比较的排序算法，而桶排序是不需要比较的。123456789101112131415161718192021222324/* bucket sort*/int bucket_sort(vector&lt;int&gt;&amp; vec )&#123; vector&lt;int&gt; bucket; bucket.resize(vec.size(),0); /*造桶*/ int i; for(i=0;i&lt;vec.size();i++) &#123; bucket[vec[i]]++; &#125; vec.resize(0); for(i=0;i&lt;bucket.size();i++) &#123; while(bucket[i]!=0) &#123; vec.push_back(i); bucket[i]--; &#125; &#125; return 0;&#125; proxmap sort这东西没找着中文翻译，据我猜测 proximal是近似的意思，map是映射，它的中文应该是近似映射排序吧。 这是桶排序的升级版，桶排序最大的缺点就是浪费空间，因为桶排序中，大部分的桶都是空着的，所以有人提出每个桶装某个范围内的元素，所以它直接指定定一个桶的范围，然后在入桶的时候采用插入排序，最后遍历桶输出。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*proxmap sort*/int proxmap_sort(vector&lt;int&gt;&amp; vec )&#123; vector&lt;vector&lt;int&gt; &gt; bucket; bucket.resize(vec.size()/10+1); /*造桶*/ int i,j,k,* n,* m; //入桶 for(i=0;i&lt;vec.size();i++) &#123; for(j=1;j&lt;=bucket.size();j++) &#123; if(vec[i]&lt;10*j) &#123; bucket[j-1].push_back(vec[i]); for(k=bucket[j-1].size()-1;k&gt;0;k--) &#123; m=&amp;bucket[j-1][k]; n=&amp;bucket[j-1][k-1]; if(*n&lt;*m) &#123; *n=*n^(*m); *m=*n^(*m); *n=*n^(*m); &#125; &#125; break; &#125; &#125; &#125; //出桶 vec.resize(0); for(j=0;j&lt;bucket.size();j++) &#123; while(bucket[j].size()) &#123; vec.push_back(bucket[j].back()); bucket[j].pop_back(); &#125; &#125; return 0;&#125; 基数排序（radix sort）这个基数也就是数学中各种进制数字表示法的基数，由于我们用的是十进制，在此处，基数就是10。 这个算法分配十个桶，标号0到9，先按照个位数入桶，然后从左到右遍历桶，将元素取出，按照十位数字入桶，以此类推。 分析一下这个操作，就知道，按照个位数入桶的时候，个位数小的第二轮会先入桶，也就是说，第二轮完毕之后，每个桶内十位数相同，但是个位数小的被压在下面。继续分析，到百位数入桶的时候，每个桶十位数小的被压在下面，那这些被压在下边的十位数相同的一组，他们的个位数是否有序呢？显然是有的，其大小方向，取决于我们上一层的桶的取出方式为保持小的压在下面的性质，出桶应该采用先进先出的方式。1234567891011121314151617181920212223242526272829303132333435363738/*radix sort*/int radix_sort(vector&lt;int&gt;&amp; vec )&#123; int i,temp=vec.size(); vector&lt; vector&lt;int&gt; &gt; bucket; bucket.resize(10); /*造桶*/ for(i=vec.size()-1;i&gt;=0;i--) &#123; bucket[vec[i]%10].push_back(vec[i]); &#125; vec.resize(0); for(i=0;i&lt;10;i++) &#123; while(bucket[i].size()&gt;0) &#123; vec.push_back(bucket[i].back()); bucket[i].pop_back(); &#125; &#125; for(i=vec.size()-1;i&gt;=0;i--) &#123; bucket[(vec[i]/10)%10].push_back(vec[i]); &#125; vec.resize(0); for(i=0;i&lt;10;i++) &#123; while(bucket[i].size()&gt;0) &#123; vec.push_back(bucket[i].back()); bucket[i].pop_back(); &#125; &#125; return 0;&#125; 耐心排序（patience sort）这个排序的思想是依次取出待排数组元素，从左往右查找桶，只有小于桶底元素才能入桶，如果没有桶或者元素不小于任何一个桶的桶底元素，就新建一个桶，把这个元素放到桶底部。 这一边操作结束的结果就是，把待排数组分成了很多段，在每个桶分别插入排序就能得到有序数组。 插入排序的最坏情况是在反序的时候出现的，这个算法相比插入排序，将那些反序得太离谱的元素进行了调整，减小了问题规模。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*patience sort*/int patience_sort(vector&lt;int&gt;&amp; vec)&#123; vector&lt; vector&lt;int&gt; &gt; bucket; int i,j,k,cur_bucket,len=vec.size(); for(i=0;i&lt;len;i++) &#123; cur_bucket=-1; for(j=0;j&lt;bucket.size();j++) &#123; if(bucket[j][0]&gt;=vec[i]) &#123; cur_bucket=j;break; &#125; &#125; if(cur_bucket==-1) &#123; bucket.push_back(*(new vector&lt;int&gt;)); bucket.back().push_back(vec[i]); &#125; else &#123; bucket[cur_bucket].push_back(vec[i]); &#125; &#125; vec.resize(0); for(k=0;k&lt;bucket.size();k++) &#123; while(bucket[k].size()!=0) &#123; vec.push_back(bucket[k].back()); bucket[k].pop_back(); &#125; &#125; //插入排序 for(k=1;k&lt;len;k++) &#123; for(j=k;j&gt;0;j--) &#123; if(vec[j]&lt;vec[j-1]) &#123; vec[j]=vec[j]^vec[j-1]; vec[j-1]=vec[j]^vec[j-1]; vec[j]=vec[j]^vec[j-1]; &#125; &#125; &#125; return 0;&#125; 闪电排序（flash sort）这也是proximap排序的一种升级算法，对于长度为n的桶，它把数组最大值和最小值之间分成n个区间，落在同个区间的放进同一个桶，入桶的时候进行插入排序，最后按顺序遍历桶，得到的数组就是有序的。1234567891011121314151617181920212223242526272829303132333435363738394041/* flash sort*/int flash_sort(vector&lt;int&gt;&amp; vec )&#123; vector&lt;vector&lt;int&gt; &gt; bucket; bucket.resize(vec.size()); /*造桶*/ int i,j,max=0,min=0,*m,*n,k; for(i=0;i&lt;vec.size();i++) &#123; if(vec[i]&gt;max)max=vec[i]; if(vec[i]&lt;min)min=vec[i]; &#125; for(i=0;i&lt;vec.size();i++) &#123; j=(vec.size()-1)*(vec[i]-min)/(max-min); bucket[j].push_back(vec[i]); for(k=bucket[j].size()-1;k&gt;0;k--) &#123; m=&amp;bucket[j][k]; n=&amp;bucket[j][k-1]; if(*n&lt;*m) &#123; *n=*n^(*m); *m=*n^(*m); *n=*n^(*m); &#125; &#125; &#125; vec.resize(0); for(j=0;j&lt;bucket.size();j++) &#123; while(bucket[j].size()) &#123; vec.push_back(bucket[j].back()); bucket[j].pop_back(); &#125; &#125; return 0;&#125; 计数排序（ counting sort）这个算法的核心思想是，如果待排数组中比一个元素小的有k个，那么这个元素就该放在第k+1个位置上。 当然对待重复的元素，需要特殊处理，假设有m个元素都发现数组中有k个元素比自己小，他们肯定不能全部挤在k+1号坑，显然，它们应该占据k+1到k+m这m个坑。 由于对每个元素，我们都需要遍历整个数组来统计比它小的元素个数，所以这个算法复杂度应该为O(n^2).12345678910111213141516171819202122232425262728/* counting sort*/int counting_sort(vector&lt;int&gt;&amp; vec )&#123; int i,j,count; vector&lt;int&gt; bucket; bucket.resize(vec.size(),-1000); /*造桶*/ for(i=0;i&lt;vec.size();i++) &#123; count=0; for(j=0;j&lt;vec.size();j++) &#123; if(vec[j]&lt;vec[i]&amp;&amp;(j!=i)) &#123; count++; &#125; &#125; while(bucket[count]!=(-1000)) &#123; count++; &#125; bucket[count]=vec[i]; &#125; vec=bucket; return 0;&#125; 圈排序（ cycle sort）如果你看懂了计数排序，你也许会想到，它并不是原地算法，因为通过对某个元素计数之后，你知道了这个元素应该去的位置，但是在原地那个位置上还占着一个不知该放在哪里的元素。所以我们的做法是建立一个新的数组来安放排好序的元素，最后赋值给原数组。当然为了节约能源，你也可以建一个数组用于保存每个位置应该放的元素的标号（因为实际排序不可能只排关键字，必然有数据域），最后再根据标号去让各个元素归位，不过这样操作依然不是最理想的。 圈排序解决了这个问题，把计数排序升级成了原地排序。 它的思想是这样的：当你找到一个a元素应该放在1号位，而1号位被另一个元素b占着，你就把b元素取出，然后把a放到1号位，给a本来的位置放一个空标记。接着寻找b应该放在哪里。最终你一定会找到一个元素应该放在a原来的位置，由于这个位置是空的，直接把元素放在此处就结束了，这样的一系列操作构成一个圈，每个元素移动一次，就能让一个圈上所有元素归位。 这里有个confused的地方，就是，你为什么知道能够找到这样的圈？ 这背后是有数学原理的，这种排序前和排序之后的映射关系在抽象代数中称作置换，而上述的圈称作轮换，就是一个集合到自身的映射，可以严格证明，每个置换都能写成几个不相交的轮换乘积形式，此处只摆出结论，不做证明。 12345678910111213141516171819202122232425262728293031323334/*cycle sort*/int cycle_sort(vector&lt;int&gt;&amp; vec)&#123; int i, j, temp,count; /*造桶*/ for (i = 0; i&lt;vec.size(); i++) &#123; temp = vec[i]; while (1) &#123; count = 0; for (j = 0; j&lt;vec.size(); j++) &#123; if (vec[j]&lt;temp &amp;&amp; (j != i)) &#123; count++; &#125; &#125; while (vec[count] == temp) &#123; if (count == i)break; count++; &#125; temp = temp^vec[count]; vec[count] = temp^vec[count]; temp = temp^vec[count]; if (i == count)break; &#125; &#125; return 0;&#125; 地精 排序（gnome sort）这个算法我认为跟他的名字很搭调，地精就是生活在花园里的一种精灵，他们喜欢在土里钻来钻去。 这个算法具体操作概括为，先从左往右进行相邻元素比较，当发现一个元素不满足需要的大小关系的时候，就交换他们然后调转方向向左边冒泡，直到相邻元素满足大小关系的时候，停止冒泡。 按照这个过程，左边的一部分元素总是有序的，每次地精抓住一个元素把它插入到有序的序列内，所以这其实是插入排序的低配版，因为插入排序实际上在插入操作的时候可以优化到O(log(n),也就是二分法插入。 12345678910111213141516171819202122232425/* gnome sort*/int gnome_sort(vector&lt;int&gt;&amp; vec )&#123; int i; for(i=0;i&lt;(int)(vec.size())-1;) &#123; if(i==-1)i++; if(vec[i]&lt;vec[i+1]) &#123; vec[i]=vec[i+1]^vec[i]; vec[i+1]=vec[i+1]^vec[i]; vec[i]=vec[i+1]^vec[i]; i--; &#125; else &#123; i++; &#125; &#125; return 0;&#125; 珠排序（bead sort）这个算法有种让人眼前一亮的感觉，维基百科页面讲的会更加清楚，这个算法按照理论，只需要把珠子穿在一系列棍子上，在‘duang’的一敲，排序就完成了。不过现实很骨感，它只能排整数列，并且在编程的时候，复杂度也是n^2级别，但是这种想法的确让人惊叹，发明这个算法的人真的是天才。 这个算法实际上基本是不可用的，不过我还是写了一个实现。12345678910111213141516171819202122232425262728/*bead sort*/int bead_sort(vector&lt;int&gt;&amp; vec)&#123; int i,j; vector&lt;int&gt; temp; temp.resize(vec.size(),0); /*下落*/ for (i = 0; i&lt;vec.size();i++) &#123; for (j=0;j&lt;vec.size();j++) &#123; if (vec[j] &gt;= i + 1)temp[i]++; &#125; &#125; vec.resize(0); vec.resize(temp.size(),0); for (i = 0; i&lt;vec.size();i++) &#123; for (j=0;j&lt;vec.size();j++) &#123; if (temp[j] &gt;= i + 1)vec[i]++; &#125; &#125; return 0;&#125; ## 快速排序（quick sort）这个算法采用的是分治法的思想，选取一个元素，然后遍历整个数组，小于等于这个元素的都放在这个元素左边，其余的放在它右边。这样数组就被分为三部分，这个元素本身已经处于正确的位置上，不需要再移动，而左右两部分都是无序的，但是左边部分的元素的正确位置只可能在左边，所以只要将左右两边分别排序，整个数组都有序了。 实现的时候，数组头尾各放一个指针（抽象意义的），左边指针向右移动直到有大于指定元素的时候停下来，右边指针也类似，等两边指针都停下来了，就进行一次交换，最终两个指针相遇的时候,再中间放上之前指定的那个元素，就完成了数组的分片操作。 递归的调用这个过程，最终得到的数组就是有序的。 由于这个算法递归深度为log（n）到n之间，它的复杂度也在n^2到nlogn之间，实际上他的平均复杂度是O（nlogn），既然他的名字叫做快速排序它总不能打自己脸来个n^2复杂度吧。12345678910111213141516171819202122232425262728293031323334/*quick sort*/int quick_sort(vector&lt;int&gt;&amp; vec,int left,int right)&#123; int i=left+1,j=right,k,temp; if(left&gt;=right)return 0; temp=vec[left]; while(i&lt;j) &#123; while(vec[left]&gt;=vec[i]) &#123; if(i==j)break; vec[i-1]=vec[i]; i++; &#125; while(vec[left]&lt;vec[j]) &#123; if(i==j)break; j--; &#125; if(i&lt;j) &#123; vec[i]=vec[i]^vec[j]; vec[j]=vec[i]^vec[j]; vec[i]=vec[i]^vec[j]; &#125; &#125; vec[k]=temp; quick_sort(vec,left,i-2); quick_sort(vec,i,right); return 0;&#125; 归并排序（merge sort）归并排序的思想也是挺直观的，对于已经有序的两个（或者n个）数列，我们只需要比较队列头部两个元素就能找出最终合并后数列的最大or最小元素。 假设我们需要从大到小排列，每次比较后把两个队头中大的那个放到新的队列，然后从待排队列中剔除它，直到其中一个列没有元素之后，就把另一列全部接到已经排序好的数列后边。 算法实现上，通过设置两个队头指针（抽象意义），用移动指针来表示元素的剔除，实现原地操作（当然就增加了时间复杂度）。 同时也用了分治法，先归并排序左半个数列，再归并排序右半边数列，最后归并排序整个数列。1234567891011121314151617181920212223242526272829303132333435/*merge sort*/int merge_sort(vector&lt;int&gt;&amp; vec,int l,int h)&#123; if(l&gt;=h)return 0; int i,j,k,m,n; i=(h-l+1)/2; j=h-l+1-i; m=l; n=l+i; merge_sort(vec,l,l+i-1); merge_sort(vec,l+i,h); for(;(m&lt;n)&amp;&amp;(n&lt;=h);) &#123; if(vec[m]&gt;=vec[n]) &#123; m++; &#125; else &#123; for(k=n;k&gt;m;k--) &#123; vec[k]=vec[k]^vec[k-1]; vec[k-1]=vec[k]^vec[k-1]; vec[k]=vec[k]^vec[k-1]; &#125; n++; m++; &#125; &#125; return 0;&#125; strand sort这个算法首先给出一个有序数组（实际上选取待排数组中的第一个，就是一个有序数组了），然后遍历数组中余下的部分找到一个有序子列，具体做法是选一个元素作为子列开头，往后遍历若找到一个元素小于子列的尾部元素（这里是指的从大到小排列的情形），就从待排数组剔除这个元素，然后将它接到子列尾部。 最后将有序数组和子列归并排序，直到待排数组为空。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*strand sort*/int strand_sort(vector&lt;int&gt;&amp; vec)&#123; vector&lt;int&gt; temp;//'有序列' temp.push_back(vec[0]); vec.erase(vec.begin()); vector&lt;int&gt;::iterator i; int j,k,m,n; while(1) &#123; n=temp.size(); if (vec.size() == 0)break; for(i=vec.begin();i!=vec.end();) &#123; if(i==vec.begin()) &#123; temp.push_back(*i); i++; continue; &#125; if(*i&lt;=temp.back()) &#123; temp.push_back(*i); i=vec.erase(i); &#125; else &#123; i++; &#125; &#125; if(n==temp.size())break; vec.erase(vec.begin()); m = 0; for(;(m&lt;n)&amp;&amp;(n&lt;=temp.size()-1);) &#123; if(temp[m]&gt;=temp[n]) &#123; m++; &#125; else &#123; for(k=n;k&gt;m;k--) &#123; temp[k]=temp[k]^temp[k-1]; temp[k-1]=temp[k]^temp[k-1]; temp[k]=temp[k]^temp[k-1]; &#125; n++; m++; &#125; &#125; &#125; vec = temp; return 0;&#125; 希尔排序（shell sort）希尔排序是选择一系列的间隔，对每个间隔把元素等距离的分为若干组，每组分别进行插入排序。 这个间隔序列的选取应该是递减的，并且最后一个间隔是1.这个算法相比于插入排序，优势在于当间隔不为1的时候进行的排序，实际上相当于在整个数列中，让元素跨过多元素进行移动，这样解决了逆序带来的复杂度的提升。123456789101112131415161718192021222324252627282930/*shell sort*/int shell_sort(vector&lt;int&gt;&amp; vec)&#123; int interval=10,i,j,k,len=vec.size(),cur_len; while(interval&gt;0) &#123; for(i=0;i&lt;interval;i++) &#123; cur_len=(len/interval)+(i&lt;len%interval?1:0); for(j=0;j&lt;cur_len-1;j++) &#123; for(k=0;k&lt;cur_len-1-i;k++) &#123; if(vec[i+interval*k]&lt;vec[i+interval*(k+1)]) &#123; vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k+1)]; vec[i+interval*(k+1)]=vec[i+interval*k]^vec[i+interval*(k+1)]; vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k+1)]; &#125; &#125; &#125; &#125; interval=interval/1.3; &#125; return 0;&#125; 梳子排序（comb sort）这个算法就是希尔排序的冒泡版本，因为他按照等距离的方法把元素分为很多组，分别冒泡排序，就像梳子的齿一样，所以得名comb sort。123456789101112131415161718192021222324252627282930/*comb sort*/int comb_sort(vector&lt;int&gt;&amp; vec)&#123; int interval=10,i,j,k,len=vec.size(),cur_len; while(interval&gt;0) &#123; for(i=0;i&lt;interval;i++) &#123; cur_len=(len/interval)+(i&lt;len%interval?1:0); for(j=1;j&lt;cur_len;j++) &#123; for(k=j;k&gt;0;k--) &#123; if(vec[i+interval*k]&lt;vec[i+interval*(k-1)]) &#123; vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k-1)]; vec[i+interval*(k-1)]=vec[i+interval*k]^vec[i+interval*(k-1)]; vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k-1)]; &#125; &#125; &#125; &#125; interval=interval/1.3; &#125; return 0;&#125; 奇偶排序（odd_even sort）这个算法将元素按照下标的奇偶分为两组，首先在第一组进行相邻两个元素的比较，然后在第二组进行相邻两个元素比较（相邻的定义要一致，可以都用后一个相邻，也可以都用前一个乡邻，绝对不能一个前一个后），如此循环。直到某一次进行完检查后，第一组和第二组都没有改动，这时候就说明元素已经有序了。 这个算法一看就知道只是花拳绣腿，改变一下冒泡排序的顺序而已，性能没有任何变化。 123456789101112131415161718192021222324252627282930313233343536/*odd_even sort*/int odd_even_sort(vector&lt;int&gt;&amp; vec)&#123; int odd_len,even_len,len,j,flag=1; len=vec.size(); odd_len=len/2+(len%2==0?(-1):0); even_len=len/2+(len%2==0?0:0); while(flag==1) &#123; flag=0; for(j=0;j&lt;even_len;j++) &#123; if(vec[2*j]&lt;vec[2*j+1]) &#123; vec[2*j]=vec[2*j]^vec[2*j+1]; vec[2*j+1]=vec[2*j]^vec[2*j+1]; vec[2*j]=vec[2*j]^vec[2*j+1]; flag=1; &#125; &#125; for(j=0;j&lt;odd_len;j++) &#123; if(vec[2*j+1]&lt;vec[2*j+2]) &#123; vec[2*j+2]=vec[2*j+2]^vec[2*j+1]; vec[2*j+1]=vec[2*j+2]^vec[2*j+1]; vec[2*j+2]=vec[2*j+2]^vec[2*j+1]; flag=1; &#125; &#125; &#125; return 0;&#125; 图书馆排序（library sort）这个算法是二十一世纪才提出的，由此便看出计算机科学的活力，在数学上，那些让你觉得深不可测的东西，你一看年代，往往在几百年前就被大师上课的时候在草稿纸上解决了，等你学到21世纪的数学，你就是大师了。 这个算法灵感源于在图书馆放书的时候在书之间留下空隙，当你需要插入一本书的时候就不必移动整个架子的书。 所以我们在数组元素间留一些空隙，插入的时候就能够减少对其他元素的移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*library sort*/int library_sort(vector&lt;int&gt;&amp; vec)&#123; const int empty_flag = -1000; vector&lt;int&gt; temp; temp.resize(vec.size()*2,empty_flag); int i, j, k,l, indicator; for (i=0;i&lt;vec.size();i++) &#123; for (j=2*i;j&gt;=-1;j--) &#123; if ( j == -1||(temp[j] &gt;= vec[i]&amp;&amp;temp[j]!= empty_flag)) &#123; indicator = 0; for(l=2*i;l&gt;j;l--) &#123; if (temp[l] != empty_flag) &#123; indicator = 1; break; &#125; &#125; if (indicator == 1) &#123; if (temp[j + 1] != empty_flag) &#123; k = j + 1; while (temp[k] != empty_flag) &#123; k++; &#125; for (; k &gt; j + 1; k--) &#123; temp[k] = temp[k - 1]; &#125; temp[k] = vec[i]; &#125; else &#123; temp[j + 1] = vec[i]; &#125; &#125; else &#123; temp[i * 2] = vec[i]; &#125; break; &#125; &#125; &#125; vec.resize(0); for (i = 0; i &lt; temp.size(); i++) &#123; if (temp[i] != empty_flag) &#123; vec.push_back(temp[i]); &#125; &#125; return 0;&#125; bogo sort这个算法也没有中文翻译，不过我把它作为压轴算法，它必然有过人之处，它的过人之处就是，超级慢。 这个算法思想类似于把一副牌扔向空中，掉到地上后去看看它是不是有序的，如果不是，再扔一次。 它的复杂度是O（n!）,这个东西和n^n是同阶的。可见其相当恐怖。 数学说起来太抽象，假设排十个数需要时间t，那么排20个就需要2^20*10^10*t，也就是大约2*10^16*t，我实测了一下，半分钟才能排11个数字。 这个算法存在的意义估计是挑战运算的极限吧，等有朝一日，这个算法能用于生产生活，人类文明估计就会进入新纪元了。123456789101112131415161718192021222324252627282930313233343536/*bogo sort*/int bogo_sort(vector&lt;int&gt;&amp; vec)&#123; int randa=1, randb=2,count=0,i,flag=1; while (true) &#123; while (true) &#123; randa = (time(NULL)+rand())%vec.size(); randb = (time(NULL)+rand())% vec.size(); if (randb != randa)break; &#125; vec[randa] = vec[randa] ^ vec[randb]; vec[randb] = vec[randa] ^ vec[randb]; vec[randa] = vec[randa] ^ vec[randb]; count++; if (count &gt;= 1) &#123; count = 0; flag = 0; for ( i = 0; i &lt; vec.size()-1; i++) &#123; if (vec[i] &lt; vec[i + 1]) &#123; flag = 1; break; &#125; &#125; &#125; if (flag == 0)break; &#125; return 0;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[徒手(加上Wikipedia)实现一颗红黑树]]></title>
    <url>%2F2017%2F05%2F25%2F2017-05-25-RBT%2F</url>
    <content type="text"><![CDATA[红黑树是一种什么树，三言两语是说不清楚的，在此推荐Wikipedia页面,为了实现一棵树，我盯着这个页面好些天才算看明白了一点点，我在此主要记录一下代码实现细节过程。 首先定义节点的形式： 1234567891011121314151617181920/*RBT*/#include &lt;iostream&gt;#include&lt;iomanip&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;#define RED 0#define BLACK 1#define LEFT -1#define RIGHT 1using namespace std;struct RBT_Node &#123; int key; int color;//颜色 RBT_Node * left; RBT_Node * right; RBT_Node * parent;&#125;;struct RBTree &#123; RBT_Node * root;&#125;; 树最重要的是增删查改操作，其中增删是主要的，所以我只实现增加和删除两个操作。 下面来实现节点的插入，根据原理，我们根据给出的key构造一个红节点，插入到树中，插入完毕必须要调整以满足红黑树性质，用RBT_adjust（）来实现，这个函数在后面再写出具体实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int RBT_insert(RBT_Node* p, RBTree&amp; T, int n) &#123; int RBT_adjust(RBT_Node *p, RBTree&amp; t); RBT_Node* node; if (T.root == NULL) &#123; T.root = new RBT_Node; node = T.root; node-&gt;color = RED;//0是红色 node-&gt;key = n; node-&gt;left = NULL; node-&gt;right = NULL; node-&gt;parent = NULL; RBT_adjust(node, T); return 0; &#125; if (n&lt;p-&gt;key) &#123; if (p-&gt;left == NULL) &#123; p-&gt;left = new RBT_Node; node = p-&gt;left; node-&gt;color = RED;//0是红色 node-&gt;key = n; node-&gt;left = NULL; node-&gt;right = NULL; node-&gt;parent = p; RBT_adjust(node, T); &#125; else RBT_insert((p-&gt;left), T, n); return 0; &#125; else if (n&gt;p-&gt;key) &#123; if (p-&gt;right == NULL) &#123; p-&gt;right = new RBT_Node; node = p-&gt;right; node-&gt;color = RED;//0是红色 node-&gt;key = n; node-&gt;left = NULL; node-&gt;right = NULL; node-&gt;parent = p; RBT_adjust(node, T); &#125; else RBT_insert((p-&gt;right), T, n); return 0; &#125; else return -1;&#125; 接下来定义几个工具函数，分别实现几种旋转，找到叔叔节点，判断孩子和父亲的左右关系等等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283int RBT_adjust_LL(RBT_Node* p, RBTree&amp; t) &#123; RBT_Node** temp = NULL; if (p-&gt;parent == NULL) &#123; t.root = p-&gt;right; p-&gt;right-&gt;parent = NULL; p-&gt;right = p-&gt;right-&gt;left; if (p-&gt;right != NULL) p-&gt;right-&gt;parent = p; t.root-&gt;left = p; p-&gt;parent = t.root; return 0; &#125; else &#123; if (p-&gt;parent-&gt;right == p)temp = &amp;(p-&gt;parent-&gt;right); else temp = &amp;(p-&gt;parent-&gt;left); *temp = p-&gt;right; p-&gt;right-&gt;parent = p-&gt;parent; p-&gt;right = p-&gt;right-&gt;left; if (p-&gt;right != NULL) p-&gt;right-&gt;parent = p; (*temp)-&gt;left = p; p-&gt;parent = (*temp); return 0; &#125;&#125;int RBT_adjust_RR(RBT_Node* p, RBTree&amp; t) &#123; RBT_Node** temp = NULL; if (p-&gt;parent == NULL) &#123; t.root = p-&gt;left; p-&gt;left-&gt;parent = NULL; p-&gt;left = p-&gt;left-&gt;right; if (p-&gt;left != NULL) p-&gt;left-&gt;parent = p; t.root-&gt;right = p; p-&gt;parent = t.root; return 0; &#125; else &#123; if (p-&gt;parent-&gt;right == p)temp = &amp;(p-&gt;parent-&gt;right); else temp = &amp;(p-&gt;parent-&gt;left); *temp = p-&gt;left; p-&gt;left-&gt;parent = p-&gt;parent; p-&gt;left = p-&gt;left-&gt;right; if (p-&gt;left != NULL) p-&gt;left-&gt;parent = p; (*temp)-&gt;right = p; p-&gt;parent = *temp; return 0; &#125;&#125;int RBT_adjust_RL(RBT_Node* p, RBTree&amp; t) &#123; RBT_Node* temp1 = p; RBT_Node* temp2 = p-&gt;right; RBT_adjust_RR(temp2, t); RBT_adjust_LL(temp1, t); return 0;&#125;int RBT_adjust_LR(RBT_Node* p, RBTree&amp; t) &#123; RBT_Node* temp1 = p; RBT_Node* temp2 = p-&gt;left; RBT_adjust_LL(temp2, t); RBT_adjust_RR(temp1, t); return 0;&#125;bool isRchild(RBT_Node* node) &#123; if (node-&gt;parent == NULL || node == NULL)return -1; if (node-&gt;parent-&gt;right == node)return true; else return false;&#125;bool isLchild(RBT_Node* node) &#123; if (node-&gt;parent == NULL||node==NULL)return -1; if (node-&gt;parent-&gt;left == node)return true; else return false;&#125;struct RBT_Node* getUncle(RBT_Node* node) &#123; //前提是爷爷存在 if (isLchild(node-&gt;parent)) &#123; return node-&gt;parent-&gt;parent-&gt;right; &#125; else if (isRchild(node-&gt;parent)) &#123; return node-&gt;parent-&gt;parent-&gt;left; &#125;&#125; 这便是最核心的部分，也就是插入完成后的调整了，代码中，关键部位，我加了一些注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int RBT_adjust_case3(RBT_Node *p, RBTree&amp; t) &#123; //爸爸红，叔叔黑或者是null if (isLchild(p) &amp;&amp; isRchild(p-&gt;parent)) &#123; RBT_adjust_LR(p-&gt;parent-&gt;parent,t); p-&gt;color = BLACK; if(p-&gt;left)p-&gt;left-&gt;color = RED; if(p-&gt;right)p-&gt;right-&gt;color = RED; return 0; &#125; else if (isRchild(p) &amp;&amp; isLchild(p-&gt;parent)) &#123; RBT_adjust_RL(p-&gt;parent-&gt;parent,t); p-&gt;color = BLACK; if(p-&gt;left)p-&gt;left-&gt;color = RED; if(p-&gt;right)p-&gt;right-&gt;color = RED; return 0; &#125; else if (isLchild(p) &amp;&amp; isLchild(p-&gt;parent)) &#123; RBT_adjust_RR(p-&gt;parent-&gt;parent,t); p-&gt;parent-&gt;color = BLACK; if(p-&gt;parent-&gt;right)p-&gt;parent-&gt;right-&gt;color = RED; if(p-&gt;parent-&gt;left)p-&gt;parent-&gt;left-&gt;color = RED; return 0; &#125; else &#123; RBT_adjust_LL(p-&gt;parent-&gt;parent,t); p-&gt;parent-&gt;color = BLACK; if(p-&gt;parent-&gt;right)p-&gt;parent-&gt;right-&gt;color = RED; if(p-&gt;parent-&gt;left)p-&gt;parent-&gt;left-&gt;color = RED; return 0; &#125;&#125;int RBT_adjust_case2(RBT_Node *p, RBTree&amp; t) &#123; //父亲RED,所以爷爷是黑色,此处父亲红色，所以肯定不是根，爷爷 必定存在 if ((NULL!= getUncle(p))&amp;&amp;(getUncle(p)-&gt;color==RED)) &#123; //若叔叔是红色，可以把爸爸 和叔叔公用的爷爷这个黑色节点，下放到父辈，也就是把爷爷染红，爸爸和叔叔染黑 //如此一来，就相当于在爷爷处插入了一个新的红节点，需要递归调用调整操作 p-&gt;parent-&gt;parent-&gt;color = RED; getUncle(p)-&gt;color = BLACK; p-&gt;parent-&gt;color = BLACK; int RBT_adjust(RBT_Node *p, RBTree&amp; t); RBT_adjust(p-&gt;parent-&gt;parent, t); return 0; &#125; else &#123; RBT_adjust_case3(p, t); return 0; &#125;&#125;int RBT_adjust(RBT_Node *p, RBTree&amp; t) &#123; if (p-&gt;parent == NULL) &#123; p-&gt;color = BLACK; return 0; &#125;//插入之后是树根 if ((p-&gt;parent-&gt;color) ==BLACK) return 0; else RBT_adjust_case2(p,t); return 0;&#125; 这是这段代码中最臭最长的一部分，实现了删除操作，我要说的内容，都在注释内。。。。。。。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260//deleteRBT_Node* getBrother(RBT_Node*p) &#123; if (NULL == p || NULL == p-&gt;parent)return NULL; if (p-&gt;parent-&gt;left == p)return p-&gt;parent-&gt;right; else return p-&gt;parent-&gt;left; &#125;int delete_case6(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)&#123;/*所以综合为：父亲红黑均可，兄弟黑，兄弟两个孩子不全黑,且new节点是父亲左孩子时兄弟左孩子是黑的， new节点是父亲右孩子时兄弟右孩子是黑的 如此只剩下： 当new节点是父亲左孩子时，父亲红，兄弟右孩子红，或父亲黑，兄弟右孩子黑 当new节点是父亲右孩子时，对称。 */ RBT_Node*l, *r; if (father_of_new_node-&gt;left == new_node) &#123; l = father_of_new_node-&gt;right-&gt;left; r = father_of_new_node-&gt;right-&gt;right; &#125; else &#123; l = father_of_new_node-&gt;left-&gt;left; r = father_of_new_node-&gt;left-&gt;right; &#125; if (new_node-&gt;parent-&gt;left == new_node) &#123; RBT_adjust_RR(father_of_new_node,t); r-&gt;color = BLACK; &#125; else &#123; RBT_adjust_LL(father_of_new_node, t); l-&gt;color = BLACK; &#125; return 0;&#125;int delete_case5(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)&#123;//此时前提是，兄弟为黑色,（父亲，兄弟的两个孩子不全为黑色)且有（父亲为红时，兄弟两个孩子不同时为黑） //所以综合为：父亲红黑均可，兄弟黑，兄弟两个孩子不全黑 RBT_Node*l, *r; if (father_of_new_node-&gt;left == new_node) &#123; l = father_of_new_node-&gt;right-&gt;left; r = father_of_new_node-&gt;right-&gt;right; &#125; else &#123; l = father_of_new_node-&gt;left-&gt;left; r = father_of_new_node-&gt;left-&gt;right; &#125; if (new_node-&gt;parent-&gt;left==new_node) &#123; if (l&amp;&amp;l-&gt;color == RED) &#123; RBT_adjust_RR(l-&gt;parent, t); l-&gt;color = BLACK; l-&gt;right-&gt;color = RED; &#125; &#125; else &#123; if (r&amp;&amp;r-&gt;color == RED) &#123; RBT_adjust_LL(l-&gt;parent, t); l-&gt;color = BLACK; l-&gt;left-&gt;color = RED; &#125; &#125; delete_case6(t, new_node, father_of_new_node); return 0;&#125;int delete_case4(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)&#123;//此时前提是，兄弟为黑色,（父亲，兄弟的两个孩子不全为黑色) RBT_Node*l, *r; if (father_of_new_node-&gt;left == new_node) &#123; l = father_of_new_node-&gt;right-&gt;left; r = father_of_new_node-&gt;right-&gt;right; &#125; else &#123; l = father_of_new_node-&gt;left-&gt;left; r = father_of_new_node-&gt;left-&gt;right; &#125; if ((NULL == l || l-&gt;color == BLACK) &amp;&amp; (NULL == r || r-&gt;color == BLACK) &amp;&amp; father_of_new_node-&gt;color == RED) &#123; father_of_new_node-&gt;color = BLACK; getBrother(new_node)-&gt;color = RED; return 0; &#125; else delete_case5(t, new_node, father_of_new_node);&#125;int delete_case3(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)&#123;//此时前提是，兄弟为黑色 RBT_Node*l, *r; if (father_of_new_node-&gt;left == new_node) &#123; l = father_of_new_node-&gt;right-&gt;left; r = father_of_new_node-&gt;right-&gt;right; &#125; else &#123; l = father_of_new_node-&gt;left-&gt;left; r = father_of_new_node-&gt;left-&gt;right; &#125; if ((NULL==l||l-&gt;color==BLACK)&amp;&amp;(NULL==r||r-&gt;color==BLACK)&amp;&amp;father_of_new_node-&gt;color == BLACK) &#123;//父亲和兄弟以及兄弟的孩子都是黑的，将兄弟染红，递归调用 if (father_of_new_node-&gt;left == new_node) &#123; father_of_new_node-&gt;right-&gt;color = RED; &#125; else &#123; father_of_new_node-&gt;left-&gt;color = RED; &#125; int delete_adjust(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node, int deletedColor); delete_adjust(t, father_of_new_node, father_of_new_node-&gt;parent, BLACK);//递归 &#125; else delete_case4(t, new_node, father_of_new_node); return 0;&#125;int delete_case2(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node)&#123; //case2 if (getBrother(new_node))//实际上brother不可能为空 &#123; if (getBrother(new_node)-&gt;color == RED) &#123;//新节点兄弟是红的，也就决定了父亲是黑的，且兄弟的二个儿子是黑的 if (father_of_new_node-&gt;left = new_node) &#123; RBT_adjust_LL(father_of_new_node, t); &#125; else &#123; RBT_adjust_RR(father_of_new_node, t); &#125; father_of_new_node-&gt;parent-&gt;color = BLACK; father_of_new_node-&gt;color = RED; &#125; &#125; delete_case3(t, new_node, father_of_new_node); return 0; &#125;int delete_adjust(RBTree&amp; t, RBT_Node*new_node, RBT_Node*father_of_new_node, int deletedColor) &#123; //parent_of_deleted至多含有一个非空节点 //传来的参数给出了被删除节点的颜色,被删除节点的父亲 if (deletedColor == RED)return 0; if (new_node&amp;&amp;new_node-&gt;color == RED) &#123; //被删掉的是黑色，新顶替上来的是红色 new_node-&gt;color = BLACK; return 0; &#125; else &#123;//被删掉的是黑色，新顶替上来的是黑色or空，这样这条路径就少了一个黑色 //case1 if (NULL == father_of_new_node)return 0; else delete_case2(t,new_node,father_of_new_node); &#125;&#125;int RBT_delete(RBTree&amp; t, RBT_Node*p, int n) &#123; if (p == NULL) &#123; return 0; &#125; RBT_Node* temp = NULL; if (n == p-&gt;key) &#123; if ((!(p-&gt;left)) &amp;&amp; (!(p-&gt;right))) &#123;//leaf node temp = p; if (!p-&gt;parent) &#123;//是树内唯一根节点 t.root = NULL; delete p; return 0; &#125; if (p-&gt;parent-&gt;right == p) &#123; p-&gt;parent-&gt;right = NULL; delete_adjust(t,temp-&gt;parent-&gt;right ,temp-&gt;parent,0); &#125; else &#123; p-&gt;parent-&gt;left = NULL; delete_adjust(t, temp-&gt;parent-&gt;left,temp-&gt;parent, 0); &#125; delete p; return 0; &#125; else if (p-&gt;left) &#123;//若左子树存在则找出左最大的 temp = p-&gt;left; while (temp-&gt;right != NULL) &#123; temp = temp-&gt;right; &#125; p-&gt;key = temp-&gt;key;//复制key //if (temp-&gt;parent-&gt;right == p) p-&gt;parent-&gt;right = NULL; //else temp-&gt;parent-&gt;left = NULL; if (temp-&gt;parent-&gt;left == temp) &#123; temp-&gt;parent-&gt;left = temp-&gt;left; if (temp-&gt;left != NULL)temp-&gt;left-&gt;parent = temp-&gt;parent; delete_adjust(t, temp-&gt;parent-&gt;left,temp-&gt;parent,temp-&gt;color); &#125; else &#123; temp-&gt;parent-&gt;right = temp-&gt;left; if (temp-&gt;left != NULL)temp-&gt;left-&gt;parent = temp-&gt;parent; delete_adjust(t, temp-&gt;parent-&gt;right, temp-&gt;parent, temp-&gt;color); &#125; delete temp; return 0;//调整 &#125; else if (p-&gt;right) &#123;//找右边最小的 temp = p-&gt;right; while (temp-&gt;left != NULL) &#123; temp = temp-&gt;left; &#125; p-&gt;key = temp-&gt;key;//复制key if (temp-&gt;parent-&gt;left == temp) &#123; temp-&gt;parent-&gt;left = temp-&gt;right; if (temp-&gt;right != NULL)temp-&gt;right-&gt;parent = temp-&gt;parent; delete_adjust(t, temp-&gt;parent-&gt;left, temp-&gt;parent, temp-&gt;color); &#125; else &#123; temp-&gt;parent-&gt;right = temp-&gt;right; if (temp-&gt;right != NULL)temp-&gt;right-&gt;parent = temp-&gt;parent; delete_adjust(t, temp-&gt;parent-&gt;right, temp-&gt;parent, temp-&gt;color); &#125; delete temp; return 0;//调整 &#125; &#125;//p-&gt;key==n else &#123; if (n &gt; p-&gt;key) &#123; RBT_delete(t, p-&gt;right, n); &#125; else &#123; RBT_delete(t, p-&gt;left, n); &#125; &#125; return 0;&#125; 定义两种遍历，用于输出树的形态，方便调试。前序遍历不必多讲，这个层序遍历我做了换行，一层输出一行，并且红色节点用[]，黑色节点用（），空的位置用+占位，使得二叉树能够可视化表示出来。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//遍历输出int pre_Treverse(RBT_Node* t) &#123; if (t == NULL) &#123; return 0; &#125; pre_Treverse(t-&gt;left); cout &lt;&lt; t-&gt;key &lt;&lt; &quot; &quot;; pre_Treverse(t-&gt;right);&#125;//层序遍历int levelOrder_traverse(RBTree t) &#123; /* 此函数用于层序使出二叉树，红色节点用[]，黑色节点用（），空的位置用+占位 */ if (t.root == NULL)return -1; vector&lt;RBT_Node*&gt; vec; vec.push_back(t.root); int cur = 0; int num_of_nextlevel = 1; int num_of_nextlevel_notnull = 0; int step_of_thislecel = 100; while (cur&lt;vec.size()) &#123; for (int i = 0; i &lt; num_of_nextlevel; i++) &#123; if (vec.at(cur) == NULL) &#123; vec.push_back(NULL); vec.push_back(NULL); cout &lt;&lt; &quot;+&quot;; &#125; else &#123; if (vec.at(cur)-&gt;color == BLACK) &#123; cout &lt;&lt;&quot;[&quot;&lt;&lt; vec.at(cur)-&gt;key&lt;&lt;&quot;]&quot;; &#125; else &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; vec.at(cur)-&gt;key &lt;&lt; &quot;)&quot;; &#125; if (vec.at(cur)-&gt;left != NULL) &#123; vec.push_back(vec.at(cur)-&gt;left); num_of_nextlevel_notnull++; &#125; else &#123; vec.push_back(NULL); &#125; if (vec.at(cur)-&gt;right != NULL) &#123; vec.push_back(vec.at(cur)-&gt;right); num_of_nextlevel_notnull++; &#125; else &#123; vec.push_back(NULL); &#125; &#125; cur++; &#125; cout &lt;&lt; endl; step_of_thislecel /= 2; num_of_nextlevel *= 2; if (num_of_nextlevel_notnull == 0) break; num_of_nextlevel_notnull = 0; &#125;//while end&#125; main函数现身，程序终于完了。12345678910111213141516int main() &#123; RBTree T = &#123; NULL &#125;; for (int i = 0; i &lt; 20; i++) &#123; RBT_insert(T.root, T, i); &#125; pre_Treverse(T.root); cout &lt;&lt; endl; levelOrder_traverse(T); cout &lt;&lt; endl; RBT_delete(T, T.root, 7); levelOrder_traverse(T); cout &lt;&lt; &quot;hello&quot;; system(&quot;pause&quot;); return 0;&#125; 运行结果如下： 我先顺序插入了20个节点，前序输出，然后层序输出。然后删除了根节点7，再层序输出，可以看出，树的建立和节点删除没有问题，不过我对软件测试不太了解，也不保证没有bug，但是经过这个过程，对红黑树原理有了更深了解，要debug也不会素手无策了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自己实现一个ping程序]]></title>
    <url>%2F2017%2F05%2F20%2F2017-05-20-python-ping%2F</url>
    <content type="text"><![CDATA[小时候不太会玩电脑，一般自己玩的时候流程是：开始–附加功能–游戏与娱乐。 倘若旁边有妹子在围观，我便会win+R—–cmd—-ping baidu.com.然后看着屏幕上跳出一行行数字，假装自己看得懂的样子，过一会儿再慢悠悠地打开太空弹球玩起来 现在想起来真的是图样图森破，甚至还非常naive啊。 这个ping程序算是我对计算机最早的认识了，作为一个生活在图形界面时代的人类，这也是我第一次知道了命令行形式的人机交互。 之前学习了计算机网络的知识，知道了它的原理其实是利用ICMP协议的回显请求来实现的，通过构造ICMP报文向目的主机发出，然后接收返回报文，计算经过的时间，就能计算出主机到目的主机之间的RTT（Round Trip Time），也就是我们平时讲的延迟。 由于ICMP工作在网络层,不能保证交付，也不保证顺序，所以发送多个请求的时候，可能会出现乱序的情况，于是ping程序中在数据段保存包本身的发送时间，接收到之后用系统时间减去报文中读取的时间即可得到RTT。为了简化过程，我在此只发送一个报文。要构造ICMP包，首先要知道其格式， Type （8bit） | Code（8bit） | Checksum （16bit） | Identifier （16bit） | Sequence Number （16bit） | Data …我们要用到的是回显请求，对应type是8，code是0，checksum要通过特定的算法获得，其他部分自己处理即可。 import socket import array,struct,time,select def checksum(data): if(len(data)%2!=0): data+=b&apos;\x00&apos; a=array.array(&apos;H&apos;,data) s=0 for d in a: s=s+d s=(~s)&amp;0xffff return s 这段代码将已经除checksum以外其它打包好的数据进行一系列计算，得到一个16bit的数，用于差错检测，如果计算错误，服务器方不会响应，你也就接受不到响应的报文了。在编写网络程序的时候，调试时要利用抓包工具查看自己发出的报文的具体内容，否则难以得知自己错在何处。 def send_packet(my_socket,destination_addr): header=struct.pack(&apos;bbHh&apos;,8,0,1,1) data=0 data=struct.pack(&apos;d&apos;,data) checks=checksum(header+data) packet=struct.pack(&apos;bbHHh&apos;,8,0,checks,1,1)+data my_socket.sendto(packet,(destination_addr,1)) t=recive_ping(my_socket, 5) print(t) def recive_ping(my_socket,timeout): timeleft=timeout while True: starttime=time.time() select_=select.select([my_socket],[],[],timeleft) if select_[0]==[]: print(&quot;timeout&quot;) return -1 t=time.time()-starttime return t 这两个函数一起完成了报文的构造和发送，这其中用到了raw类型socket，select用于接收数据，由于数据要翻译成二进制发送，直接连接字符串肯定是不行的，所以要用struct将数据打包。 def do(addr): icmp=socket.getprotobyname(&apos;icmp&apos;) s=socket.socket(socket.AF_INET,socket.SOCK_RAW,icmp) send_packet(s, addr) do(&quot;220.181.57.217&quot;) 这就是程序的入口了，运行效果就不贴了，反正就是打印出一个浮点数。 与ping相似的另一个traceroute，实现原理也类似，它利用的是ip头部的TTL,通过构造指向目的主机的ttl从1递增的数据包，就能获得源主机到目的主机之间所有经过的路由，这可以在网上找到不少资料，此处不再赘述。 参考:[1]:https://bbs.ichunqiu.com/thread-8970-1-1.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[huffman树及编码的实现]]></title>
    <url>%2F2017%2F05%2F03%2F2017-05-03-hufmantree%2F</url>
    <content type="text"><![CDATA[最近学到Huffman编码，于是想要实现出来看看，查阅了一些资料，就开始动手了。首先整理一下思路，Huffman编码关键是构造huffman树，输入字母表以及对应权重，构建Huffman树；由Huffman树即可生成Huffman码和字母表的映射。 由于hufgman树的特殊性，节点的度只有0和2，只有叶子结点代表字母，其他节点均为辅助接点，当有n个叶子的时候必然有n-1个辅助节点。考虑用连续存储来存放，具体来说就是个结构体数组。每个结构体中记录节点的字母，权重，父亲节点，孩子节点，没有的置为-1；在长度为2n-1的结构体数组中，前n个存放叶子结点，后n-1个存放辅助节点，初始的时候叶子结点都没有父亲节点，构建Huffman树的时候，只需要依次进行n-1轮插入辅助节点操作即可（没插入一个辅助节点就会导致森林中的树减少一个）。 首先定义一个hufTree类： 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &quot;stdafx.h&quot;#include&quot;Windows.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class hufTree &#123;private: typedef struct hufNode &#123; char alpha; int weight; int lChild, rChild, parent; &#125; *pNode; int _n; int _m;//叶子数和总节点数 pNode huf_arr; void getMintwo(int flag,int *min1,int* min2);public: hufTree(char * alpha,int * weight,int N);//构造huf树，alpha为字母数组 ~hufTree() &#123;&#125;; string* hufCodingtable(); string encode(string str,string * huftable, char * alpha); string decode(string str, string * huftable, char * alpha);&#125;; 由于要多次选取森林中权最小的两个树，所以，写成函数getMintwo（）；12345678910void hufTree::getMintwo(int flag, int *min1, int* min2) &#123; pNode hf = huf_arr; *min1 = 0; *min2 = 1; int weight1=9999, weight2=9999; for (int i = 0; i &lt; flag;i++) &#123; if ((hf[i].parent == -1) &amp;&amp; (hf[i].weight &lt; weight1)) &#123; *min1 = i; weight1 = huf_arr[i].weight; &#125; else if ((hf[i].parent == -1) &amp;&amp; (hf[i].weight &lt; weight2)) &#123; *min2 = i; weight2 = huf_arr[i].weight; &#125; &#125;&#125; 重载构造函数，实现Huffman树的构建,这里最开始的时候，申请长度为2n-1的结构体数组空间，然后将前n个初始化为叶子结点，并且没有父亲节点（独立成为一棵树）和孩子节点，之后在插入辅助接点形成新树删除旧树之时只需改变元素之间的父子关系即可。123456789101112131415161718192021222324252627282930//构造huf树hufTree::hufTree(char * alpha, int * weight, int N) &#123; char* tmp=new char[20]; _n = N; _m = N * 2 - 1; huf_arr = new hufNode[_m]; for (int i = 0; i &lt; _n; i++) &#123; huf_arr[i].alpha = alpha[i]; huf_arr[i].parent = -1; huf_arr[i].lChild = -1; huf_arr[i].rChild = -1; huf_arr[i].weight = weight[i]; //*tmp = huf_arr[i].alpha; //OutputDebugStringA(tmp); &#125; int min1, min2; for (int i = _n; i &lt; _m; i++) &#123; getMintwo(i,&amp;min1,&amp;min2); huf_arr[i].parent = -1; huf_arr[i].lChild = min1; huf_arr[i].rChild = min2; huf_arr[min1].parent = i; huf_arr[min2].parent = i; huf_arr[i].weight = huf_arr[min1].weight + huf_arr[min2].weight; &#125;&#125; 然后根据已有的Huffman树生成对应的编码映射表，此处应该有键值表，但是我嫌麻烦，所以直接用两个平行的数组分别存放键和值(函数值返回hufman码表，和已知的字母表一一顺序对应)。方法是，从对应的叶子开始向上搜索到根节点，每次判断当前节点是父亲节点的左节点还是右节点，对应加入0或1，由于得到的码是反序的，最后将字符串反转后插入编码表即可。12345678910111213141516171819202122232425string* hufTree::hufCodingtable() &#123; string* table = new string[_n]; for (int i = 0; i &lt; _n; i++) &#123; int cur = i,parent=huf_arr[i].parent; string tmp = &quot;&quot;; while (parent!=-1) &#123; if (huf_arr[parent].lChild==cur) &#123; tmp += &quot;0&quot;; &#125; else &#123; tmp += &quot;1&quot;; &#125; cur = parent; parent = huf_arr[cur].parent; &#125; reverse(tmp.begin(),tmp.end()); table[i] = tmp; &#125; return table;&#125; 编码和解码函数，编码函数很简单，每次取出一个字符，将其对应Huffman码值查出后加到输出字符串即可；解码函数由于每个码长短未知，所以设置一个buffer变量，每次读入一个二进制位到buffer，比对Huffman码表是否有相应的字母，如有，取出加入输出字符串后，buffer归零；若无，则在buffer中再加入一个二进制位。1234567891011121314151617181920212223242526272829303132333435string hufTree::encode(string str, string * huftable, char * alpha)&#123; string tmp = &quot;&quot;; int len = str.length(); for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; _n; j++) &#123; if (huf_arr[j].alpha==str.at(i)) &#123; tmp += huftable[j]; &#125; &#125; return tmp;&#125;string hufTree::decode(string str, string * huftable, char * alpha)&#123; string tmp = &quot;&quot;; string buffer = &quot;&quot;; int len = str.length(); for (int i = 0; i &lt; len; i++) &#123; buffer += str.at(i); for (int j = 0; j &lt; _n; j++) &#123; if (huftable[j] == buffer) &#123; tmp += alpha[j]; buffer = &quot;&quot;; &#125; &#125; &#125; return tmp;&#125; 然后就是主函数了,..以前上课老爱用getchar停住cmd黑框，今天忽然掉进个坑，我把黑框关闭后再去修改了代码后就出现lnk1168错误，原因是之前那个程序根本没停，我去任务管理器试图关闭发现关闭不了，估计是没给它个char他不甘心停止吧。所以改成了system（“pause”），暂时还没出现问题。12345678910111213int main()&#123; char alpha[] = &#123; &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos; &#125;; int weight[] = &#123; 1,2,3,4,5,6,7 &#125;; hufTree hf(alpha,weight,7); string str = &quot;abcdefg&quot;; string encode=hf.encode(str,hf.hufCodingtable(),alpha); cout &lt;&lt; encode; string decode = hf.decode(encode,hf.hufCodingtable(),alpha); cout &lt;&lt; decode; system(&quot;pause&quot;); return 0;&#125; 输出： 011001110101101110010abcdefgPress any key to continue . . .]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[秘技---------气象操控术！！]]></title>
    <url>%2F2017%2F04%2F10%2F2017-04-10-jzm%26weather%2F</url>
    <content type="text"><![CDATA[气象学是一门极其困难的科学，究其原因，主要是气象学模型复杂，扰动条件相当多，导致时常有不符合模型的情况出现，这在专业上称作‘奇点’。今天我们讲讲中国气象学上几个著名的奇点。 1985年5月，戈尔巴乔夫访华，国家主席杨尚昆和未来的总书记江先生一同接见了这位苏共总书记。江主席亲切的说：“由于您的到来，上海的天气好转了。”戈尔巴乔夫回应：“特别令人高兴的是，中苏关系好转了”。 2009年，江主席视察旧部国机二院。会议中，中国著名气象专家徐嘉诰笑着说：“天气预报本来说今天有雨，结果江主席一来，天气晴朗”。 科学研究需要敏锐的嗅觉，通过对以上两个案例的分析，很多人发现两个事件中共同点就是有他在场，于是做出结论，他拥有气象操控术这样一种失传已久的秘技，上一次这个秘技展示在众人眼前，还是东汉末年。 斗转星移，到了2017年，我看到这样一篇新闻报道： 之前网友盛传他拥有秘技的谣言不攻自破，倘若真是秘技重现江湖，就目前的情形来看，他并不是唯一掌握这种秘技的人，至少他那位胖嘟嘟的继任者也拥有同样的能力。历史的脉搏是这么的有力，在波澜壮阔的长河里一次又一次不紧不慢的展示出自己的迷人之处。无论真相如何，我们作为芸芸众生中微不足道的一员，只能感叹：历史总是惊人的相似！]]></content>
      <categories>
        <category>幽默</category>
      </categories>
  </entry>
</search>

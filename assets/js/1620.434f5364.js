"use strict";(self.webpackChunkpersonal_blog=self.webpackChunkpersonal_blog||[]).push([[1620],{6495:(e,t,n)=>{n.d(t,{J:()=>Ee,_:()=>se});var o=n(85186),i=n(23068),r=n(81254),s=n(74722),a=n(17572),c=n(42531),h=n(89610),u=n(9703),l=n(69592),T=n(92049),d=n(73249),A=n(48585),f=n(89463),p=n(8058),E=n(66401),_=n(94092),m=n(17089),g=n(39241),I=n(47360),N=n(16145),O=n(34098),R=n(38207),C=n(27422),y=n(19288),x=n(98817);let L={};const M=new o.H;function P(e){const t=e.toString();if(L.hasOwnProperty(t))return L[t];{const e=M.pattern(t);return L[t]=e,e}}const k="Complement Sets are not supported for first char optimization",S='Unable to use "first char" lexer optimizations:\n';function D(e,t=!1){try{const t=P(e);return v(t.value,{},t.flags.ignoreCase)}catch(n){if(n.message===k)t&&(0,y.x)(`${S}\tUnable to optimize: < ${e.toString()} >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);else{let n="";t&&(n="\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."),(0,y.Z)(`${S}\n\tFailed parsing: < ${e.toString()} >\n\tUsing the @chevrotain/regexp-to-ast library\n\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues`+n)}}return[]}function v(e,t,n){switch(e.type){case"Disjunction":for(let i=0;i<e.value.length;i++)v(e.value[i],t,n);break;case"Alternative":const o=e.value;for(let e=0;e<o.length;e++){const i=o[e];switch(i.type){case"EndAnchor":case"GroupBackReference":case"Lookahead":case"NegativeLookahead":case"StartAnchor":case"WordBoundary":case"NonWordBoundary":continue}const r=i;switch(r.type){case"Character":U(r.value,t,n);break;case"Set":if(!0===r.complement)throw Error(k);(0,p.A)(r.value,(e=>{if("number"==typeof e)U(e,t,n);else{const o=e;if(!0===n)for(let e=o.from;e<=o.to;e++)U(e,t,n);else{for(let e=o.from;e<=o.to&&e<oe;e++)U(e,t,n);if(o.to>=oe){const e=o.from>=oe?o.from:oe,n=o.to,i=re(e),r=re(n);for(let o=i;o<=r;o++)t[o]=o}}}}));break;case"Group":v(r.value,t,n);break;default:throw Error("Non Exhaustive Match")}const s=void 0!==r.quantifier&&0===r.quantifier.atLeast;if("Group"===r.type&&!1===w(r)||"Group"!==r.type&&!1===s)break}break;default:throw Error("non exhaustive match!")}return(0,R.A)(t)}function U(e,t,n){const o=re(e);t[o]=o,!0===n&&function(e,t){const n=String.fromCharCode(e),o=n.toUpperCase();if(o!==n){const e=re(o.charCodeAt(0));t[e]=e}else{const e=n.toLowerCase();if(e!==n){const n=re(e.charCodeAt(0));t[n]=n}}}(e,t)}function b(e,t){return(0,N.A)(e.value,(e=>{if("number"==typeof e)return(0,c.A)(t,e);{const n=e;return void 0!==(0,N.A)(t,(e=>n.from<=e&&e<=n.to))}}))}function w(e){const t=e.quantifier;return!(!t||0!==t.atLeast)||!!e.value&&((0,T.A)(e.value)?(0,x.A)(e.value,w):w(e.value))}class F extends o.z{constructor(e){super(),this.targetCharCodes=e,this.found=!1}visitChildren(e){if(!0!==this.found){switch(e.type){case"Lookahead":return void this.visitLookahead(e);case"NegativeLookahead":return void this.visitNegativeLookahead(e)}super.visitChildren(e)}}visitCharacter(e){(0,c.A)(this.targetCharCodes,e.value)&&(this.found=!0)}visitSet(e){e.complement?void 0===b(e,this.targetCharCodes)&&(this.found=!0):void 0!==b(e,this.targetCharCodes)&&(this.found=!0)}}function G(e,t){if(t instanceof RegExp){const n=P(t),o=new F(e);return o.visit(n),o.found}return void 0!==(0,N.A)(t,(t=>(0,c.A)(e,t.charCodeAt(0))))}const z="PATTERN",$="defaultMode",H="modes";let B="boolean"==typeof new RegExp("(?:)").sticky;function W(e,t){const n=(t=(0,i.A)(t,{useSticky:B,debug:!1,safeMode:!1,positionTracking:"full",lineTerminatorCharacters:["\r","\n"],tracer:(e,t)=>t()})).tracer;let o;n("initCharCodeToOptimizedIndexMap",(()=>{!function(){if((0,E.A)(ie)){ie=new Array(65536);for(let e=0;e<65536;e++)ie[e]=e>255?255+~~(e/255):e}}()})),n("Reject Lexer.NA",(()=>{o=(0,r.A)(e,(e=>e[z]===Ee.NA))}));let _,m,g,I,N,O,R,C,x,L,M,P=!1;n("Transform Patterns",(()=>{P=!1,_=(0,s.A)(o,(e=>{const n=e[z];if((0,a.A)(n)){const e=n.source;return 1!==e.length||"^"===e||"$"===e||"."===e||n.ignoreCase?2!==e.length||"\\"!==e[0]||(0,c.A)(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],e[1])?t.useSticky?V(n):j(n):e[1]:e}if((0,h.A)(n))return P=!0,{exec:n};if("object"==typeof n)return P=!0,n;if("string"==typeof n){if(1===n.length)return n;{const e=n.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&"),o=new RegExp(e);return t.useSticky?V(o):j(o)}}throw Error("non exhaustive match")}))})),n("misc mapping",(()=>{m=(0,s.A)(o,(e=>e.tokenTypeIdx)),g=(0,s.A)(o,(e=>{const t=e.GROUP;if(t!==Ee.SKIPPED){if((0,u.A)(t))return t;if((0,l.A)(t))return!1;throw Error("non exhaustive match")}})),I=(0,s.A)(o,(e=>{const t=e.LONGER_ALT;if(t){return(0,T.A)(t)?(0,s.A)(t,(e=>(0,d.A)(o,e))):[(0,d.A)(o,t)]}})),N=(0,s.A)(o,(e=>e.PUSH_MODE)),O=(0,s.A)(o,(e=>(0,A.A)(e,"POP_MODE")))})),n("Line Terminator Handling",(()=>{const e=te(t.lineTerminatorCharacters);R=(0,s.A)(o,(e=>!1)),"onlyOffset"!==t.positionTracking&&(R=(0,s.A)(o,(t=>(0,A.A)(t,"LINE_BREAKS")?!!t.LINE_BREAKS:!1===ee(t,e)&&G(e,t.PATTERN))))})),n("Misc Mapping #2",(()=>{C=(0,s.A)(o,J),x=(0,s.A)(_,q),L=(0,f.A)(o,((e,t)=>{const n=t.GROUP;return(0,u.A)(n)&&n!==Ee.SKIPPED&&(e[n]=[]),e}),{}),M=(0,s.A)(_,((e,t)=>({pattern:_[t],longerAlt:I[t],canLineTerminator:R[t],isCustom:C[t],short:x[t],group:g[t],push:N[t],pop:O[t],tokenTypeIdx:m[t],tokenType:o[t]})))}));let k=!0,v=[];return t.safeMode||n("First Char Optimization",(()=>{v=(0,f.A)(o,((e,n,o)=>{if("string"==typeof n.PATTERN){const t=re(n.PATTERN.charCodeAt(0));ne(e,t,M[o])}else if((0,T.A)(n.START_CHARS_HINT)){let t;(0,p.A)(n.START_CHARS_HINT,(n=>{const i=re("string"==typeof n?n.charCodeAt(0):n);t!==i&&(t=i,ne(e,i,M[o]))}))}else if((0,a.A)(n.PATTERN))if(n.PATTERN.unicode)k=!1,t.ensureOptimizations&&(0,y.Z)(`${S}\tUnable to analyze < ${n.PATTERN.toString()} > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);else{const i=D(n.PATTERN,t.ensureOptimizations);(0,E.A)(i)&&(k=!1),(0,p.A)(i,(t=>{ne(e,t,M[o])}))}else t.ensureOptimizations&&(0,y.Z)(`${S}\tTokenType: <${n.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),k=!1;return e}),[])})),{emptyGroups:L,patternIdxToConfig:M,charCodeToPatternIdxToConfig:v,hasCustom:P,canBeOptimized:k}}function X(e,t){let n=[];const i=function(e){const t=(0,_.A)(e,(e=>!(0,A.A)(e,z))),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- missing static 'PATTERN' property",type:se.MISSING_PATTERN,tokenTypes:[e]}))),o=(0,m.A)(e,t);return{errors:n,valid:o}}(e);n=n.concat(i.errors);const r=function(e){const t=(0,_.A)(e,(e=>{const t=e[z];return!((0,a.A)(t)||(0,h.A)(t)||(0,A.A)(t,"exec")||(0,u.A)(t))})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:se.INVALID_PATTERN,tokenTypes:[e]}))),o=(0,m.A)(e,t);return{errors:n,valid:o}}(i.valid),l=r.valid;return n=n.concat(r.errors),n=n.concat(function(e){let t=[];const n=(0,_.A)(e,(e=>(0,a.A)(e[z])));return t=t.concat(function(e){class t extends o.z{constructor(){super(...arguments),this.found=!1}visitEndAnchor(e){this.found=!0}}const n=(0,_.A)(e,(e=>{const n=e.PATTERN;try{const e=P(n),o=new t;return o.visit(e),o.found}catch(o){return K.test(n.source)}})),i=(0,s.A)(n,(e=>({message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+e.name+"<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:se.EOI_ANCHOR_FOUND,tokenTypes:[e]})));return i}(n)),t=t.concat(function(e){class t extends o.z{constructor(){super(...arguments),this.found=!1}visitStartAnchor(e){this.found=!0}}const n=(0,_.A)(e,(e=>{const n=e.PATTERN;try{const e=P(n),o=new t;return o.visit(e),o.found}catch(o){return Y.test(n.source)}})),i=(0,s.A)(n,(e=>({message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+e.name+"<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:se.SOI_ANCHOR_FOUND,tokenTypes:[e]})));return i}(n)),t=t.concat(function(e){const t=(0,_.A)(e,(e=>{const t=e[z];return t instanceof RegExp&&(t.multiline||t.global)})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:se.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[e]})));return n}(n)),t=t.concat(function(e){const t=[];let n=(0,s.A)(e,(n=>(0,f.A)(e,((e,o)=>(n.PATTERN.source!==o.PATTERN.source||(0,c.A)(t,o)||o.PATTERN===Ee.NA||(t.push(o),e.push(o)),e)),[])));n=(0,g.A)(n);const o=(0,_.A)(n,(e=>e.length>1)),i=(0,s.A)(o,(e=>{const t=(0,s.A)(e,(e=>e.name));return{message:`The same RegExp pattern ->${(0,I.A)(e).PATTERN}<-has been used in all of the following Token Types: ${t.join(", ")} <-`,type:se.DUPLICATE_PATTERNS_FOUND,tokenTypes:e}}));return i}(n)),t=t.concat(function(e){const t=(0,_.A)(e,(e=>e.PATTERN.test(""))),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' must not match an empty string",type:se.EMPTY_MATCH_PATTERN,tokenTypes:[e]})));return n}(n)),t}(l)),n=n.concat(function(e){const t=(0,_.A)(e,(e=>{if(!(0,A.A)(e,"GROUP"))return!1;const t=e.GROUP;return t!==Ee.SKIPPED&&t!==Ee.NA&&!(0,u.A)(t)})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:se.INVALID_GROUP_TYPE_FOUND,tokenTypes:[e]})));return n}(l)),n=n.concat(function(e,t){const n=(0,_.A)(e,(e=>void 0!==e.PUSH_MODE&&!(0,c.A)(t,e.PUSH_MODE))),o=(0,s.A)(n,(e=>({message:`Token Type: ->${e.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${e.PUSH_MODE}<-which does not exist`,type:se.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[e]})));return o}(l,t)),n=n.concat(function(e){const t=[],n=(0,f.A)(e,((e,t,n)=>{const o=t.PATTERN;return o===Ee.NA||((0,u.A)(o)?e.push({str:o,idx:n,tokenType:t}):(0,a.A)(o)&&function(e){const t=[".","\\","[","]","|","^","$","(",")","?","*","+","{"];return void 0===(0,N.A)(t,(t=>-1!==e.source.indexOf(t)))}(o)&&e.push({str:o.source,idx:n,tokenType:t})),e}),[]);return(0,p.A)(e,((e,o)=>{(0,p.A)(n,(({str:n,idx:i,tokenType:r})=>{if(o<i&&function(e,t){if((0,a.A)(t)){const n=t.exec(e);return null!==n&&0===n.index}if((0,h.A)(t))return t(e,0,[],{});if((0,A.A)(t,"exec"))return t.exec(e,0,[],{});if("string"==typeof t)return t===e;throw Error("non exhaustive match")}(n,e.PATTERN)){const n=`Token: ->${r.name}<- can never be matched.\nBecause it appears AFTER the Token Type ->${e.name}<-in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;t.push({message:n,type:se.UNREACHABLE_PATTERN,tokenTypes:[e,r]})}}))})),t}(l)),n}const K=/[^\\][$]/;const Y=/[^\\[][\^]|^\^/;function j(e){const t=e.ignoreCase?"i":"";return new RegExp(`^(?:${e.source})`,t)}function V(e){const t=e.ignoreCase?"iy":"y";return new RegExp(`${e.source}`,t)}function Z(e,t,n){const o=[];let i=!1;const s=(0,g.A)((0,O.A)((0,R.A)(e.modes))),a=(0,r.A)(s,(e=>e[z]===Ee.NA)),c=te(n);return t&&(0,p.A)(a,(e=>{const t=ee(e,c);if(!1!==t){const n=function(e,t){if(t.issue===se.IDENTIFY_TERMINATOR)return`Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <${e.name}> Token Type\n\t Root cause: ${t.errMsg}.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;if(t.issue===se.CUSTOM_LINE_BREAK)return`Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <${e.name}> Token Type\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;throw Error("non exhaustive match")}(e,t),i={message:n,type:t.issue,tokenType:e};o.push(i)}else(0,A.A)(e,"LINE_BREAKS")?!0===e.LINE_BREAKS&&(i=!0):G(c,e.PATTERN)&&(i=!0)})),t&&!i&&o.push({message:"Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n\tfor details.",type:se.NO_LINE_BREAKS_FLAGS}),o}function J(e){const t=e.PATTERN;if((0,a.A)(t))return!1;if((0,h.A)(t))return!0;if((0,A.A)(t,"exec"))return!0;if((0,u.A)(t))return!1;throw Error("non exhaustive match")}function q(e){return!(!(0,u.A)(e)||1!==e.length)&&e.charCodeAt(0)}const Q={test:function(e){const t=e.length;for(let n=this.lastIndex;n<t;n++){const t=e.charCodeAt(n);if(10===t)return this.lastIndex=n+1,!0;if(13===t)return 10===e.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return!1},lastIndex:0};function ee(e,t){if((0,A.A)(e,"LINE_BREAKS"))return!1;if((0,a.A)(e.PATTERN)){try{G(t,e.PATTERN)}catch(n){return{issue:se.IDENTIFY_TERMINATOR,errMsg:n.message}}return!1}if((0,u.A)(e.PATTERN))return!1;if(J(e))return{issue:se.CUSTOM_LINE_BREAK};throw Error("non exhaustive match")}function te(e){return(0,s.A)(e,(e=>(0,u.A)(e)?e.charCodeAt(0):e))}function ne(e,t,n){void 0===e[t]?e[t]=[n]:e[t].push(n)}const oe=256;let ie=[];function re(e){return e<oe?e:ie[e]}var se,ae=n(38923),ce=n(50053),he=n(29008),ue=n(42302),le=n(26666),Te=n(10009),de=n(66786),Ae=n(73590),fe=n(92566);!function(e){e[e.MISSING_PATTERN=0]="MISSING_PATTERN",e[e.INVALID_PATTERN=1]="INVALID_PATTERN",e[e.EOI_ANCHOR_FOUND=2]="EOI_ANCHOR_FOUND",e[e.UNSUPPORTED_FLAGS_FOUND=3]="UNSUPPORTED_FLAGS_FOUND",e[e.DUPLICATE_PATTERNS_FOUND=4]="DUPLICATE_PATTERNS_FOUND",e[e.INVALID_GROUP_TYPE_FOUND=5]="INVALID_GROUP_TYPE_FOUND",e[e.PUSH_MODE_DOES_NOT_EXIST=6]="PUSH_MODE_DOES_NOT_EXIST",e[e.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",e[e.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",e[e.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",e[e.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",e[e.SOI_ANCHOR_FOUND=11]="SOI_ANCHOR_FOUND",e[e.EMPTY_MATCH_PATTERN=12]="EMPTY_MATCH_PATTERN",e[e.NO_LINE_BREAKS_FLAGS=13]="NO_LINE_BREAKS_FLAGS",e[e.UNREACHABLE_PATTERN=14]="UNREACHABLE_PATTERN",e[e.IDENTIFY_TERMINATOR=15]="IDENTIFY_TERMINATOR",e[e.CUSTOM_LINE_BREAK=16]="CUSTOM_LINE_BREAK",e[e.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE=17]="MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"}(se||(se={}));const pe={deferDefinitionErrorsHandling:!1,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:["\n","\r"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:fe.P,traceInitPerf:!1,skipValidations:!1,recoveryEnabled:!0};Object.freeze(pe);class Ee{constructor(e,t=pe){if(this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},this.TRACE_INIT=(e,t)=>{if(!0===this.traceInitPerf){this.traceInitIndent++;const n=new Array(this.traceInitIndent+1).join("\t");this.traceInitIndent<this.traceInitMaxIdent&&console.log(`${n}--\x3e <${e}>`);const{time:o,value:i}=(0,Te.O)(t),r=o>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&r(`${n}<-- <${e}> time: ${o}ms`),this.traceInitIndent--,i}return t()},"boolean"==typeof t)throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");this.config=(0,ae.A)({},pe,t);const n=this.config.traceInitPerf;!0===n?(this.traceInitMaxIdent=1/0,this.traceInitPerf=!0):"number"==typeof n&&(this.traceInitMaxIdent=n,this.traceInitPerf=!0),this.traceInitIndent=-1,this.TRACE_INIT("Lexer Constructor",(()=>{let n,o=!0;this.TRACE_INIT("Lexer Config handling",(()=>{if(this.config.lineTerminatorsPattern===pe.lineTerminatorsPattern)this.config.lineTerminatorsPattern=Q;else if(this.config.lineTerminatorCharacters===pe.lineTerminatorCharacters)throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");if(t.safeMode&&t.ensureOptimizations)throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking),(0,T.A)(e)?n={modes:{defaultMode:(0,ce.A)(e)},defaultMode:$}:(o=!1,n=(0,ce.A)(e))})),!1===this.config.skipValidations&&(this.TRACE_INIT("performRuntimeChecks",(()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(function(e){const t=[];return(0,A.A)(e,$)||t.push({message:"A MultiMode Lexer cannot be initialized without a <"+$+"> property in its definition\n",type:se.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),(0,A.A)(e,H)||t.push({message:"A MultiMode Lexer cannot be initialized without a <modes> property in its definition\n",type:se.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),(0,A.A)(e,H)&&(0,A.A)(e,$)&&!(0,A.A)(e.modes,e.defaultMode)&&t.push({message:`A MultiMode Lexer cannot be initialized with a ${$}: <${e.defaultMode}>which does not exist\n`,type:se.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),(0,A.A)(e,H)&&(0,p.A)(e.modes,((e,n)=>{(0,p.A)(e,((o,i)=>{if((0,l.A)(o))t.push({message:`A Lexer cannot be initialized using an undefined Token Type. Mode:<${n}> at index: <${i}>\n`,type:se.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});else if((0,A.A)(o,"LONGER_ALT")){const i=(0,T.A)(o.LONGER_ALT)?o.LONGER_ALT:[o.LONGER_ALT];(0,p.A)(i,(i=>{(0,l.A)(i)||(0,c.A)(e,i)||t.push({message:`A MultiMode Lexer cannot be initialized with a longer_alt <${i.name}> on token <${o.name}> outside of mode <${n}>\n`,type:se.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE})}))}}))})),t}(n,this.trackStartLines,this.config.lineTerminatorCharacters))})),this.TRACE_INIT("performWarningRuntimeChecks",(()=>{this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(Z(n,this.trackStartLines,this.config.lineTerminatorCharacters))}))),n.modes=n.modes?n.modes:{},(0,p.A)(n.modes,((e,t)=>{n.modes[t]=(0,r.A)(e,(e=>(0,l.A)(e)))}));const i=(0,C.A)(n.modes);if((0,p.A)(n.modes,((e,n)=>{this.TRACE_INIT(`Mode: <${n}> processing`,(()=>{if(this.modes.push(n),!1===this.config.skipValidations&&this.TRACE_INIT("validatePatterns",(()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(X(e,i))})),(0,E.A)(this.lexerDefinitionErrors)){let o;(0,Ae.SF)(e),this.TRACE_INIT("analyzeTokenTypes",(()=>{o=W(e,{lineTerminatorCharacters:this.config.lineTerminatorCharacters,positionTracking:t.positionTracking,ensureOptimizations:t.ensureOptimizations,safeMode:t.safeMode,tracer:this.TRACE_INIT})})),this.patternIdxToConfig[n]=o.patternIdxToConfig,this.charCodeToPatternIdxToConfig[n]=o.charCodeToPatternIdxToConfig,this.emptyGroups=(0,ae.A)({},this.emptyGroups,o.emptyGroups),this.hasCustom=o.hasCustom||this.hasCustom,this.canModeBeOptimized[n]=o.canBeOptimized}}))})),this.defaultMode=n.defaultMode,!(0,E.A)(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){const e=(0,s.A)(this.lexerDefinitionErrors,(e=>e.message)).join("-----------------------\n");throw new Error("Errors detected in definition of Lexer:\n"+e)}(0,p.A)(this.lexerDefinitionWarning,(e=>{(0,y.x)(e.message)})),this.TRACE_INIT("Choosing sub-methods implementations",(()=>{if(B?(this.chopInput=he.A,this.match=this.matchWithTest):(this.updateLastIndex=ue.A,this.match=this.matchWithExec),o&&(this.handleModes=ue.A),!1===this.trackStartLines&&(this.computeNewColumn=he.A),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=ue.A),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else{if(!/onlyOffset/i.test(this.config.positionTracking))throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);this.createTokenInstance=this.createOffsetOnlyToken}this.hasCustom?(this.addToken=this.addTokenUsingPush,this.handlePayload=this.handlePayloadWithCustom):(this.addToken=this.addTokenUsingMemberAccess,this.handlePayload=this.handlePayloadNoCustom)})),this.TRACE_INIT("Failed Optimization Warnings",(()=>{const e=(0,f.A)(this.canModeBeOptimized,((e,t,n)=>(!1===t&&e.push(n),e)),[]);if(t.ensureOptimizations&&!(0,E.A)(e))throw Error(`Lexer Modes: < ${e.join(", ")} > cannot be optimized.\n\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`)})),this.TRACE_INIT("clearRegExpParserCache",(()=>{L={}})),this.TRACE_INIT("toFastProperties",(()=>{(0,de.B)(this)}))}))}tokenize(e,t=this.defaultMode){if(!(0,E.A)(this.lexerDefinitionErrors)){const e=(0,s.A)(this.lexerDefinitionErrors,(e=>e.message)).join("-----------------------\n");throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n"+e)}return this.tokenizeInternal(e,t)}tokenizeInternal(e,t){let n,o,i,r,s,a,c,h,u,l,d,A,f,E,_;const m=e,g=m.length;let I=0,N=0;const O=this.hasCustom?0:Math.floor(e.length/10),R=new Array(O),y=[];let x=this.trackStartLines?1:void 0,L=this.trackStartLines?1:void 0;const M=function(e){const t={},n=(0,C.A)(e);return(0,p.A)(n,(n=>{const o=e[n];if(!(0,T.A)(o))throw Error("non exhaustive match");t[n]=[]})),t}(this.emptyGroups),P=this.trackStartLines,k=this.config.lineTerminatorsPattern;let S=0,D=[],v=[];const U=[],b=[];let w;function F(){return D}function G(e){const t=re(e),n=v[t];return void 0===n?b:n}Object.freeze(b);const z=e=>{if(1===U.length&&void 0===e.tokenType.PUSH_MODE){const t=this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(e);y.push({offset:e.startOffset,line:e.startLine,column:e.startColumn,length:e.image.length,message:t})}else{U.pop();const e=(0,le.A)(U);D=this.patternIdxToConfig[e],v=this.charCodeToPatternIdxToConfig[e],S=D.length;const t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;w=v&&t?G:F}};function $(e){U.push(e),v=this.charCodeToPatternIdxToConfig[e],D=this.patternIdxToConfig[e],S=D.length,S=D.length;const t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;w=v&&t?G:F}let H;$.call(this,t);const B=this.config.recoveryEnabled;for(;I<g;){a=null;const t=m.charCodeAt(I),T=w(t),p=T.length;for(n=0;n<p;n++){H=T[n];const o=H.pattern;c=null;const u=H.short;if(!1!==u?t===u&&(a=o):!0===H.isCustom?(_=o.exec(m,I,R,M),null!==_?(a=_[0],void 0!==_.payload&&(c=_.payload)):a=null):(this.updateLastIndex(o,I),a=this.match(o,e,I)),null!==a){if(s=H.longerAlt,void 0!==s){const t=s.length;for(i=0;i<t;i++){const t=D[s[i]],n=t.pattern;if(h=null,!0===t.isCustom?(_=n.exec(m,I,R,M),null!==_?(r=_[0],void 0!==_.payload&&(h=_.payload)):r=null):(this.updateLastIndex(n,I),r=this.match(n,e,I)),r&&r.length>a.length){a=r,c=h,H=t;break}}}break}}if(null!==a){if(u=a.length,l=H.group,void 0!==l&&(d=H.tokenTypeIdx,A=this.createTokenInstance(a,I,d,H.tokenType,x,L,u),this.handlePayload(A,c),!1===l?N=this.addToken(R,N,A):M[l].push(A)),e=this.chopInput(e,u),I+=u,L=this.computeNewColumn(L,u),!0===P&&!0===H.canLineTerminator){let e,t,n=0;k.lastIndex=0;do{e=k.test(a),!0===e&&(t=k.lastIndex-1,n++)}while(!0===e);0!==n&&(x+=n,L=u-t,this.updateTokenEndLineColumnLocation(A,l,t,n,x,L,u))}this.handleModes(H,z,$,A)}else{const t=I,n=x,i=L;let r=!1===B;for(;!1===r&&I<g;)for(e=this.chopInput(e,1),I++,o=0;o<S;o++){const t=D[o],n=t.pattern,i=t.short;if(!1!==i?m.charCodeAt(I)===i&&(r=!0):!0===t.isCustom?r=null!==n.exec(m,I,R,M):(this.updateLastIndex(n,I),r=null!==n.exec(e)),!0===r)break}if(f=I-t,L=this.computeNewColumn(L,f),E=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(m,t,f,n,i),y.push({offset:t,line:n,column:i,length:f,message:E}),!1===B)break}}return this.hasCustom||(R.length=N),{tokens:R,groups:M,errors:y}}handleModes(e,t,n,o){if(!0===e.pop){const i=e.push;t(o),void 0!==i&&n.call(this,i)}else void 0!==e.push&&n.call(this,e.push)}chopInput(e,t){return e.substring(t)}updateLastIndex(e,t){e.lastIndex=t}updateTokenEndLineColumnLocation(e,t,n,o,i,r,s){let a,c;void 0!==t&&(a=n===s-1,c=a?-1:0,1===o&&!0===a||(e.endLine=i+c,e.endColumn=r-1-c))}computeNewColumn(e,t){return e+t}createOffsetOnlyToken(e,t,n,o){return{image:e,startOffset:t,tokenTypeIdx:n,tokenType:o}}createStartOnlyToken(e,t,n,o,i,r){return{image:e,startOffset:t,startLine:i,startColumn:r,tokenTypeIdx:n,tokenType:o}}createFullToken(e,t,n,o,i,r,s){return{image:e,startOffset:t,endOffset:t+s-1,startLine:i,endLine:i,startColumn:r,endColumn:r+s-1,tokenTypeIdx:n,tokenType:o}}addTokenUsingPush(e,t,n){return e.push(n),t}addTokenUsingMemberAccess(e,t,n){return e[t]=n,++t}handlePayloadNoCustom(e,t){}handlePayloadWithCustom(e,t){null!==t&&(e.payload=t)}matchWithTest(e,t,n){return!0===e.test(t)?t.substring(n,e.lastIndex):null}matchWithExec(e,t){const n=e.exec(t);return null!==n?n[0]:null}}Ee.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.",Ee.NA=/NOT_APPLICABLE/},73590:(e,t,n)=>{n.d(t,{E8:()=>I,Jx:()=>m,SF:()=>E,xU:()=>d,yJ:()=>A});var o=n(8058),i=n(50053),r=n(39241),s=n(34098),a=n(74722),c=n(17089),h=n(66401),u=n(92049),l=n(42531),T=n(48585);function d(e,t){const n=e.tokenTypeIdx;return n===t.tokenTypeIdx||!0===t.isParent&&!0===t.categoryMatchesMap[n]}function A(e,t){return e.tokenTypeIdx===t.tokenTypeIdx}let f=1;const p={};function E(e){const t=function(e){let t=(0,i.A)(e),n=e,o=!0;for(;o;){n=(0,r.A)((0,s.A)((0,a.A)(n,(e=>e.CATEGORIES))));const e=(0,c.A)(n,t);t=t.concat(e),(0,h.A)(e)?o=!1:n=e}return t}(e);!function(e){(0,o.A)(e,(e=>{var t;m(e)||(p[f]=e,e.tokenTypeIdx=f++),g(e)&&!(0,u.A)(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),g(e)||(e.CATEGORIES=[]),t=e,(0,T.A)(t,"categoryMatches")||(e.categoryMatches=[]),function(e){return(0,T.A)(e,"categoryMatchesMap")}(e)||(e.categoryMatchesMap={})}))}(t),function(e){(0,o.A)(e,(e=>{_([],e)}))}(t),function(e){(0,o.A)(e,(e=>{e.categoryMatches=[],(0,o.A)(e.categoryMatchesMap,((t,n)=>{e.categoryMatches.push(p[n].tokenTypeIdx)}))}))}(t),(0,o.A)(t,(e=>{e.isParent=e.categoryMatches.length>0}))}function _(e,t){(0,o.A)(e,(e=>{t.categoryMatchesMap[e.tokenTypeIdx]=!0})),(0,o.A)(t.CATEGORIES,(n=>{const o=e.concat(t);(0,l.A)(o,n)||_(o,n)}))}function m(e){return(0,T.A)(e,"tokenTypeIdx")}function g(e){return(0,T.A)(e,"CATEGORIES")}function I(e){return(0,T.A)(e,"tokenTypeIdx")}},91620:(e,t,n)=>{n.d(t,{Ey:()=>m,G:()=>N,LT:()=>g,Q:()=>h,Sk:()=>c,fx:()=>I});var o=n(9703),i=n(69592),r=n(48585),s=n(6495),a=n(73590);function c(e){return h(e)?e.LABEL:e.name}function h(e){return(0,o.A)(e.LABEL)&&""!==e.LABEL}const u="parent",l="categories",T="label",d="group",A="push_mode",f="pop_mode",p="longer_alt",E="line_breaks",_="start_chars_hint";function m(e){return function(e){const t=e.pattern,n={};n.name=e.name,(0,i.A)(t)||(n.PATTERN=t);if((0,r.A)(e,u))throw"The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";(0,r.A)(e,l)&&(n.CATEGORIES=e[l]);(0,a.SF)([n]),(0,r.A)(e,T)&&(n.LABEL=e[T]);(0,r.A)(e,d)&&(n.GROUP=e[d]);(0,r.A)(e,f)&&(n.POP_MODE=e[f]);(0,r.A)(e,A)&&(n.PUSH_MODE=e[A]);(0,r.A)(e,p)&&(n.LONGER_ALT=e[p]);(0,r.A)(e,E)&&(n.LINE_BREAKS=e[E]);(0,r.A)(e,_)&&(n.START_CHARS_HINT=e[_]);return n}(e)}const g=m({name:"EOF",pattern:s.J.NA});function I(e,t,n,o,i,r,s,a){return{image:t,startOffset:n,endOffset:o,startLine:i,endLine:r,startColumn:s,endColumn:a,tokenTypeIdx:e.tokenTypeIdx,tokenType:e}}function N(e,t){return(0,a.xU)(e,t)}(0,a.SF)([g])},92566:(e,t,n)=>{n.d(t,{P:()=>o});const o={buildUnableToPopLexerModeMessage:e=>`Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`,buildUnexpectedCharactersMessage:(e,t,n,o,i)=>`unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${n} characters.`}}}]);
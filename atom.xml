<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Land of Free</title>
  
  <subtitle>Joker&#39;s Blog</subtitle>
  <link href="https://xigou.github.io/atom.xml" rel="self"/>
  
  <link href="https://xigou.github.io/"/>
  <updated>2022-04-27T02:22:55.027Z</updated>
  <id>https://xigou.github.io/</id>
  
  <author>
    <name>Joker.Goode</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为你写诗</title>
    <link href="https://xigou.github.io/2022/01/21/poetry/"/>
    <id>https://xigou.github.io/2022/01/21/poetry/</id>
    <published>2022-01-21T14:35:04.000Z</published>
    <updated>2022-04-27T02:22:55.027Z</updated>
    
    <content type="html"><![CDATA[<p>不许伸着脖子偷看</p><a id="more"></a><hr><p>不要因为害怕失望</p><p>而放弃追逐太阳</p><p>它的光芒之下有繁星</p><p>Don’t give up chasing the sun</p><p>for fear of disappointment,</p><p>There are stars under its light.</p><pre><code>-- Xi 2022.01.21 仿泰戈尔</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;不许伸着脖子偷看&lt;/p&gt;</summary>
    
    
    
    
    <category term="poetry" scheme="https://xigou.github.io/tags/poetry/"/>
    
  </entry>
  
  <entry>
    <title>&lt;i&gt;[Literature Reading]&lt;/i&gt; Modern Code Review: A Case Study at Google</title>
    <link href="https://xigou.github.io/2021/12/14/Modern-Code-Review-A-Case-Study-at-Google/"/>
    <id>https://xigou.github.io/2021/12/14/Modern-Code-Review-A-Case-Study-at-Google/</id>
    <published>2021-12-14T21:35:04.000Z</published>
    <updated>2022-04-27T02:22:55.027Z</updated>
    
    <content type="html"><![CDATA[<p>Recently, after called some code review meetings in my daily work, I got interested about code review practice, so I read this excellent article on the weekend. </p><a id="more"></a><h2 id="Hisroty-of-code-review-practice"><a href="#Hisroty-of-code-review-practice" class="headerlink" title="Hisroty of code review practice"></a>Hisroty of code review practice</h2><ol><li>Code Inspections</li></ol><p>It’s a very  structured process style code review, when developers finished code, they shoud working on planning, overview, preparation, inspection meeting, reworking, and follow-up for code review, reviewers and code authors will sitting in the same room, and they can talk with the author face to face to understand the code and find the defects.</p><ol start="2"><li>Asynchronous review via email</li></ol><p>Until the late 2000s, most large OSS projects adopted a form of remote, asynchronous reviews, relying on patches sent to communication channels such as mailing lists and issue tracking systems. So this method broke the limitations of “sitting toghter” and authors don’t need to do a presentation to explain the code, instead they should explain the code in the length of one email.</p><ol start="3"><li>Tool-based review</li></ol><p>The main-streamd code review practice nowdays is tool-based, the representative of review systems are Gerrit, CodeFlow, ReviewBoard and Phabricator.</p><p><em>Typical workflow of tool-based review</em>:</p><pre><code>1. author submit code patch to review system,2. reviewers review code and post comment on specific lines of code,3. authors reply comments or submit new patch to review system,4. repeat step 2-3 until all reviewers or specific role of your team think the patch is ready for testing or merging.</code></pre><ol start="4"><li>Pull-based development model</li></ol><p>Mainly used in Github or similar code repo website, very similar to Tool-based review.</p><h2 id="This-research-answered-three-Research-Questions-about-code-review"><a href="#This-research-answered-three-Research-Questions-about-code-review" class="headerlink" title="This research answered three Research Questions about code review:"></a>This research answered three Research Questions about code review:</h2><h3 id="RQ1-What-are-the-motivations-for-code-review-at-Google"><a href="#RQ1-What-are-the-motivations-for-code-review-at-Google" class="headerlink" title="RQ1: What are the motivations for code review at Google?"></a>RQ1: What are the motivations for code review at Google?</h3><blockquote><p>Finding 1. Expectations for code review at Google do not center around problem solving. Reviewing was introduced at Google to ensure code readability and maintainability. Today’s developers also perceive this educational aspect, in addition to maintaining norms, tracking history, gatekeeping, and accident prevention. Defect finding is welcomed but not the only focus.</p></blockquote><p>This is in line with my daily experience, when fixing bug it very useful to search for a similar bugfix patch in review system, and the review system contains some auto process to do static check and testing.</p><p>Besides, The most important aim in business view is to grab out the knowledge out of the brain of the developer and make others easy to learn it, this makes every piece of code at least read by 2-3 employee inside organization, when some empolyee leave the organization, negative impact will be small.</p><h3 id="RQ2-What-is-the-practice-of-code-review-at-Google"><a href="#RQ2-What-is-the-practice-of-code-review-at-Google" class="headerlink" title="RQ2: What is the practice of code review at Google?"></a>RQ2: What is the practice of code review at Google?</h3><blockquote><p>Finding 3. The Google code review process is aligned with the convergent practice of being lightweight and flexible. In contrast to other studied systems, however, ownership and readability are explicit and play a key role. The review tool includes reviewer recommendation and code analysis result</p></blockquote><p>The most impressive part for me is: In Google, every code directory has owner(a set of people), when you change the code of that directory, owner should review and approve the code. </p><h2 id="Something-interesting"><a href="#Something-interesting" class="headerlink" title="Something interesting"></a>Something interesting</h2><blockquote><p>At Google, over 35% of<br>the changes under consideration modify only a single file and<br>about 90% modify fewer than 10 files. Over 10% of changes<br>modify only a single line of code, and the median number of<br>lines modified is 24. The median change size is significantly<br>lower than reported by Rigby and Bird for companies such as<br>AMD (44 lines), Lucent (263 lines), and Bing, Office and SQL<br>Server at Microsoft (somewhere between those boundaries),<br>but in line for change sizes in open source projects.</p></blockquote><p>Even in big and fast-developing company like Google, most of the code modification is “small”, when you usually need to change hundreds lines of code, that means something wrong with your company, please start to post your resume as soon as possible. </p><h2 id="Write-at-the-end"><a href="#Write-at-the-end" class="headerlink" title="Write at the end"></a>Write at the end</h2><p>In my team now, I’d rather define the code review process as “Tool-based Code Inspections”, we are using Gerrit to track code patch for review, but almost nobody will post comments or reply on it,  the reviewer have no interest to read others’ code, developer should call a meeting and do a presentation to explain the code to reviewers, then reviewers will propose some comments in the meeting. </p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><div id="refer-anchor-1"></div></p><ul><li>[1] Caitlin Sadowski, Emma Söderberg, Luke Church, Michal Sipko and Alberto Bacchelli. 2018. Modern Code Review: A Case Study at Google. In Proceedings of 40th International Conference on Software Engineering: Software Engineering in Practice Track, Gothenburg, Sweden, May 27-June 3, 2018 (ICSE-SEIP ’18), 10 pages. DOI: 10.1145/3183519.3183525</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Recently, after called some code review meetings in my daily work, I got interested about code review practice, so I read this excellent article on the weekend. &lt;/p&gt;</summary>
    
    
    
    
    <category term="Software Engineering" scheme="https://xigou.github.io/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark experements of &lt;i&gt;Computer Networks: Top-Down Approach&lt;/i&gt;</title>
    <link href="https://xigou.github.io/2021/09/04/Computer-Networks-Top-Down-Approach-s-wireshark-experements%20copy/"/>
    <id>https://xigou.github.io/2021/09/04/Computer-Networks-Top-Down-Approach-s-wireshark-experements%20copy/</id>
    <published>2021-09-04T21:35:04.000Z</published>
    <updated>2022-04-27T02:22:55.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intruduction"><a href="#intruduction" class="headerlink" title="intruduction"></a>intruduction</h1><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>“Tell me and I forget. Show me and I remember. Involve me and I understand.”<br><em>Chinese proverb</em></p>            <i class="fa fa-quote-right"></i>          </blockquote><hr><p>I read the <em>Computer Networks: Top-Down Approach</em> about 3 years ago preparing for my CN-GRE, after read this book, I learned a lot about computer network, the reading helped me to fill in the blanks on the test paper, but I don’t have the confidence to tell others I know the principles behind computer network, expecially after years of forgetting process.</p><p>So I decide to do a wireshark homework in this weekend.</p><a id="more"></a><h1 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h1><h2 id="Basic-skill-capturing-packets-using-Wireshark"><a href="#Basic-skill-capturing-packets-using-Wireshark" class="headerlink" title="Basic skill: capturing packets using Wireshark"></a>Basic skill: capturing packets using Wireshark</h2><p><em>Wiresharks</em> is a powerful tools to capture, mastering it needs much time, but I think knowing three steps below is enough to start these labs:</p><ol><li>select an interface, and click the “shark fin” icon to start capturing packets;</li><li>do something can trigger the protocal you want to observe;</li><li>click stop icon to stop capturing and start research.</li></ol><p>Need to know more, just go to reference<a href="#refer-anchor-1"><sup>1</sup></a>.</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="The-Basic-HTTP-GET-response-interaction"><a href="#The-Basic-HTTP-GET-response-interaction" class="headerlink" title="The Basic HTTP GET/response interaction"></a>The Basic HTTP GET/response interaction</h3><p>What I did:<br>Open Microsoft Edge browser and open this url:  <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html</a>.</p><p>Captured packets:</p><table><thead><tr><th>“No.”</th><th>“Time”</th><th>“Source”</th><th>“Destination”</th><th>“Protocol”</th><th>“Length”</th><th>“Info”</th></tr></thead><tbody><tr><td>“370872”</td><td>“899.553481”</td><td>“192.168.1.3”</td><td>“128.119.245.12”</td><td>“HTTP”</td><td>“581”</td><td>“GET /wireshark-labs/HTTP-wireshark-file1.html HTTP/1.1 “</td></tr><tr><td>“372140”</td><td>“899.824395”</td><td>“128.119.245.12”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“540”</td><td>“HTTP/1.1 200 OK  (text/html)”</td></tr></tbody></table><p>Detail of packets:<br>Request:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Frame 370872: 581 bytes on wire (4648 bits), 581 bytes captured (4648 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.3, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 17536, Dst Port: 80, Seq: 1, Ack: 1, Len: 527</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    GET /wireshark-labs/HTTP-wireshark-file1.html HTTP/1.1\r\n</span><br><span class="line">    Host: gaia.cs.umass.edu\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Cache-Control: max-age=0\r\n</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38\r\n</span><br><span class="line">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n</span><br><span class="line">    Accept-Encoding: gzip, deflate\r\n</span><br><span class="line">    Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [Full request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html]</span><br><span class="line">    [HTTP request 1/1]</span><br><span class="line">    [Response in frame: 372140]</span><br></pre></td></tr></table></figure></p><p>Response:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Frame 372140: 540 bytes on wire (4320 bits), 540 bytes captured (4320 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">Internet Protocol Version 4, Src: 128.119.245.12, Dst: 192.168.1.3</span><br><span class="line">Transmission Control Protocol, Src Port: 80, Dst Port: 17536, Seq: 1, Ack: 528, Len: 486</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    HTTP/1.1 200 OK\r\n</span><br><span class="line">    Date: Sun, 05 Sep 2021 09:03:10 GMT\r\n</span><br><span class="line">    Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.22 mod_perl/2.0.11 Perl/v5.16.3\r\n</span><br><span class="line">    Last-Modified: Sun, 05 Sep 2021 05:59:01 GMT\r\n</span><br><span class="line">    ETag: &quot;80-5cb393aaf07a9&quot;\r\n</span><br><span class="line">    Accept-Ranges: bytes\r\n</span><br><span class="line">    Content-Length: 128\r\n</span><br><span class="line">    Keep-Alive: timeout=5, max=100\r\n</span><br><span class="line">    Connection: Keep-Alive\r\n</span><br><span class="line">    Content-Type: text/html; charset=UTF-8\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [HTTP response 1/1]</span><br><span class="line">    [Time since request: 0.270914000 seconds]</span><br><span class="line">    [Request in frame: 370872]</span><br><span class="line">    [Request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html]</span><br><span class="line">    File Data: 128 bytes</span><br><span class="line">Line-based text data: text/html (4 lines)</span><br><span class="line">    &lt;html&gt;\n</span><br><span class="line">    Congratulations.  You&apos;ve downloaded the file \n</span><br><span class="line">    http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html!\n</span><br><span class="line">    &lt;/html&gt;\n</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol><li><p>Is your browser running HTTP version 1.0, 1.1, or 2?  What version of HTTP is the server running?<br>From the header of request packet, I can see the HTTP version of my browser and server are both HTTP/1.1.</p></li><li><p>What languages (if any) does your browser indicate that it can accept to the server?<br>It is in the “Accept-Language” of the request packet.</p></li><li><p>What is the IP address of your computer?  What is the IP address of the gaia.cs.umass.edu server?<br>The Internet Protocal layer indicates my IP(Src) is 192.168.1.3, IP of gaia.cs.umass.edu server(Dst) is 128.119.245.12.</p></li><li><p>What is the status code returned from the server to your browser?<br>200 OK.</p></li><li><p>When was the HTML file that you are retrieving last modified at the server?<br>Last-Modified: Sun, 05 Sep 2021 05:59:01 GMT\r\n</p></li><li><p>How many bytes of content are being returned to your browser?<br>540 bytes.</p></li><li><p>By inspecting the raw data in the packet content window, do you see any headers within the data that are not displayed in the packet-listing window?  If so, name one.<br>Content-Length.</p></li></ol><h3 id="The-HTTP-CONDITIONAL-GET-response-interaction"><a href="#The-HTTP-CONDITIONAL-GET-response-interaction" class="headerlink" title="The HTTP CONDITIONAL GET/response interaction"></a>The HTTP CONDITIONAL GET/response interaction</h3><p>Operations:</p><ul><li>Enter the following URL into your browser<br><a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html</a><br>Your browser should display a very simple five-line HTML file. </li><li>Quickly enter the same URL into your browser again (or simply select the refresh button on your browser)</li></ul><p>Captured packets:</p><table><thead><tr><th>“No.”</th><th>“Time”</th><th>“Source”</th><th>“Destination”</th><th>“Protocol”</th><th>“Length”</th><th>“Info”</th></tr></thead><tbody><tr><td>“142”</td><td>“6.368786”</td><td>“192.168.1.3”</td><td>“128.119.245.12”</td><td>“HTTP”</td><td>“555”</td><td>“GET /wireshark-labs/HTTP-wireshark-file2.html HTTP/1.1 “</td></tr><tr><td>“183”</td><td>“6.633550”</td><td>“128.119.245.12”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“784”</td><td>“HTTP/1.1 200 OK  (text/html)”</td></tr><tr><td>“237”</td><td>“8.389410”</td><td>“192.168.1.3”</td><td>“128.119.245.12”</td><td>“HTTP”</td><td>“667”</td><td>“GET /wireshark-labs/HTTP-wireshark-file2.html HTTP/1.1 “</td></tr><tr><td>“268”</td><td>“8.655003”</td><td>“128.119.245.12”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“293”</td><td>“HTTP/1.1 304 Not Modified “</td></tr></tbody></table><p>Detail of packets:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Frame 142: 555 bytes on wire (4440 bits), 555 bytes captured (4440 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.3, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 1053, Dst Port: 80, Seq: 1, Ack: 1, Len: 501</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    GET /wireshark-labs/HTTP-wireshark-file2.html HTTP/1.1\r\n</span><br><span class="line">    Host: gaia.cs.umass.edu\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38\r\n</span><br><span class="line">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n</span><br><span class="line">    Accept-Encoding: gzip, deflate\r\n</span><br><span class="line">    Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [Full request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html]</span><br><span class="line">    [HTTP request 1/2]</span><br><span class="line">    [Response in frame: 183]</span><br><span class="line">    [Next request in frame: 237]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Frame 183: 784 bytes on wire (6272 bits), 784 bytes captured (6272 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">Internet Protocol Version 4, Src: 128.119.245.12, Dst: 192.168.1.3</span><br><span class="line">Transmission Control Protocol, Src Port: 80, Dst Port: 1053, Seq: 1, Ack: 502, Len: 730</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    HTTP/1.1 200 OK\r\n</span><br><span class="line">    Date: Sun, 05 Sep 2021 12:49:23 GMT\r\n</span><br><span class="line">    Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.22 mod_perl/2.0.11 Perl/v5.16.3\r\n</span><br><span class="line">    Last-Modified: Sun, 05 Sep 2021 05:59:01 GMT\r\n</span><br><span class="line">    ETag: &quot;173-5cb393aaefbf1&quot;\r\n</span><br><span class="line">    Accept-Ranges: bytes\r\n</span><br><span class="line">    Content-Length: 371\r\n</span><br><span class="line">    Keep-Alive: timeout=5, max=100\r\n</span><br><span class="line">    Connection: Keep-Alive\r\n</span><br><span class="line">    Content-Type: text/html; charset=UTF-8\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [HTTP response 1/2]</span><br><span class="line">    [Time since request: 0.264764000 seconds]</span><br><span class="line">    [Request in frame: 142]</span><br><span class="line">    [Next request in frame: 237]</span><br><span class="line">    [Next response in frame: 268]</span><br><span class="line">    [Request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html]</span><br><span class="line">    File Data: 371 bytes</span><br><span class="line">Line-based text data: text/html (10 lines)</span><br><span class="line">    \n</span><br><span class="line">    &lt;html&gt;\n</span><br><span class="line">    \n</span><br><span class="line">    Congratulations again!  Now you&apos;ve downloaded the file lab2-2.html. &lt;br&gt;\n</span><br><span class="line">    This file&apos;s last modification date will not change.  &lt;p&gt;\n</span><br><span class="line">    Thus  if you download this multiple times on your browser, a complete copy &lt;br&gt;\n</span><br><span class="line">    will only be sent once by the server due to the inclusion of the IN-MODIFIED-SINCE&lt;br&gt;\n</span><br><span class="line">    field in your browser&apos;s HTTP GET request to the server.\n</span><br><span class="line">    \n</span><br><span class="line">    &lt;/html&gt;\n</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Frame 237: 667 bytes on wire (5336 bits), 667 bytes captured (5336 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.3, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 1053, Dst Port: 80, Seq: 502, Ack: 731, Len: 613</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    GET /wireshark-labs/HTTP-wireshark-file2.html HTTP/1.1\r\n</span><br><span class="line">    Host: gaia.cs.umass.edu\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Cache-Control: max-age=0\r\n</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38\r\n</span><br><span class="line">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n</span><br><span class="line">    Accept-Encoding: gzip, deflate\r\n</span><br><span class="line">    Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\r\n</span><br><span class="line">    If-None-Match: &quot;173-5cb393aaefbf1&quot;\r\n</span><br><span class="line">    If-Modified-Since: Sun, 05 Sep 2021 05:59:01 GMT\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [Full request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html]</span><br><span class="line">    [HTTP request 2/2]</span><br><span class="line">    [Prev request in frame: 142]</span><br><span class="line">    [Response in frame: 268]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Frame 268: 293 bytes on wire (2344 bits), 293 bytes captured (2344 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">Internet Protocol Version 4, Src: 128.119.245.12, Dst: 192.168.1.3</span><br><span class="line">Transmission Control Protocol, Src Port: 80, Dst Port: 1053, Seq: 731, Ack: 1115, Len: 239</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    HTTP/1.1 304 Not Modified\r\n</span><br><span class="line">    Date: Sun, 05 Sep 2021 12:49:25 GMT\r\n</span><br><span class="line">    Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.22 mod_perl/2.0.11 Perl/v5.16.3\r\n</span><br><span class="line">    Connection: Keep-Alive\r\n</span><br><span class="line">    Keep-Alive: timeout=5, max=99\r\n</span><br><span class="line">    ETag: &quot;173-5cb393aaefbf1&quot;\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [HTTP response 2/2]</span><br><span class="line">    [Time since request: 0.265593000 seconds]</span><br><span class="line">    [Prev request in frame: 142]</span><br><span class="line">    [Prev response in frame: 183]</span><br><span class="line">    [Request in frame: 237]</span><br><span class="line">    [Request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html]</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol start="8"><li><p>Inspect the contents of the first HTTP GET request from your browser to the server.  Do you see an “IF-MODIFIED-SINCE” line in the HTTP GET?<br>No.</p></li><li><p>Inspect the contents of the server response. Did the server explicitly return the contents of the file?   How can you tell?<br>Yes, in the File Data field of the response packet.</p></li><li><p>Now inspect the contents of the second HTTP GET request from your browser to the server.  Do you see an “IF-MODIFIED-SINCE:” line in the HTTP GET ? If so, what information follows the “IF-MODIFIED-SINCE:” header?<br>Yes,  “If-Modified-Since: Sun, 05 Sep 2021 05:59:01 GMT\r\n”.</p></li><li><p>What is the HTTP status code and phrase returned from the server in response to this second HTTP GET?  Did the server explicitly return the contents of the file?   Explain.<br>Status code is 304(Not Modified), server didn’t return the contents of the file explicitly,  because the browser keep a copy of this file last modified at  “Sun, 05 Sep 2021 05:59:01 GMT”, and put this timestamp in “IF-MODIFIED-SINCE:” header field to inform the server no need to return the file didn’t modified after the timestamp.</p></li></ol><h3 id="Retrieving-Long-Documents"><a href="#Retrieving-Long-Documents" class="headerlink" title="Retrieving Long Documents"></a>Retrieving Long Documents</h3><p>Operations:</p><ul><li>Enter the following URL into your browser<br><a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html</a><br>Your browser should display the rather lengthy US Bill of Rights.</li></ul><p>Packets Captured:</p><table><thead><tr><th>“No.”</th><th>“Time”</th><th>“Source”</th><th>“Destination”</th><th>“Protocol”</th><th>“Length”</th><th>“Info”</th></tr></thead><tbody><tr><td>“146”</td><td>“4.150099”</td><td>“192.168.1.3”</td><td>“128.119.245.12”</td><td>“HTTP”</td><td>“555”</td><td>“GET /wireshark-labs/HTTP-wireshark-file3.html HTTP/1.1 “</td></tr><tr><td>“176”</td><td>“4.411527”</td><td>“128.119.245.12”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“679”</td><td>“HTTP/1.1 200 OK  (text/html)”</td></tr></tbody></table><p>Packets Details:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Frame 146: 555 bytes on wire (4440 bits), 555 bytes captured (4440 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.3, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 1028, Dst Port: 80, Seq: 1, Ack: 1, Len: 501</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    GET /wireshark-labs/HTTP-wireshark-file3.html HTTP/1.1\r\n</span><br><span class="line">        [Expert Info (Chat/Sequence): GET /wireshark-labs/HTTP-wireshark-file3.html HTTP/1.1\r\n]</span><br><span class="line">        Request Method: GET</span><br><span class="line">        Request URI: /wireshark-labs/HTTP-wireshark-file3.html</span><br><span class="line">        Request Version: HTTP/1.1</span><br><span class="line">    Host: gaia.cs.umass.edu\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38\r\n</span><br><span class="line">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n</span><br><span class="line">    Accept-Encoding: gzip, deflate\r\n</span><br><span class="line">    Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [Full request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html]</span><br><span class="line">    [HTTP request 1/1]</span><br><span class="line">    [Response in frame: 176]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Frame 176: 679 bytes on wire (5432 bits), 679 bytes captured (5432 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">    Destination: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">    Source: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">    Type: IPv4 (0x0800)</span><br><span class="line">Internet Protocol Version 4, Src: 128.119.245.12, Dst: 192.168.1.3</span><br><span class="line">Transmission Control Protocol, Src Port: 80, Dst Port: 1028, Seq: 4237, Ack: 502, Len: 625</span><br><span class="line">[4 Reassembled TCP Segments (4861 bytes): #172(1412), #173(1412), #175(1412), #176(625)]</span><br><span class="line">    [Frame: 172, payload: 0-1411 (1412 bytes)]</span><br><span class="line">    [Frame: 173, payload: 1412-2823 (1412 bytes)]</span><br><span class="line">    [Frame: 175, payload: 2824-4235 (1412 bytes)]</span><br><span class="line">    [Frame: 176, payload: 4236-4860 (625 bytes)]</span><br><span class="line">    [Segment count: 4]</span><br><span class="line">    [Reassembled TCP length: 4861]</span><br><span class="line">    [Reassembled TCP Data: 485454502f312e3120323030204f4b0d0a446174653a2053756e2c203035205365702032…]</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    HTTP/1.1 200 OK\r\n</span><br><span class="line">        [Expert Info (Chat/Sequence): HTTP/1.1 200 OK\r\n]</span><br><span class="line">        Response Version: HTTP/1.1</span><br><span class="line">        Status Code: 200</span><br><span class="line">        [Status Code Description: OK]</span><br><span class="line">        Response Phrase: OK</span><br><span class="line">    Date: Sun, 05 Sep 2021 13:12:00 GMT\r\n</span><br><span class="line">    Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.22 mod_perl/2.0.11 Perl/v5.16.3\r\n</span><br><span class="line">    Last-Modified: Sun, 05 Sep 2021 05:59:01 GMT\r\n</span><br><span class="line">    ETag: &quot;1194-5cb393aaeb1b8&quot;\r\n</span><br><span class="line">    Accept-Ranges: bytes\r\n</span><br><span class="line">    Content-Length: 4500\r\n</span><br><span class="line">    Keep-Alive: timeout=5, max=100\r\n</span><br><span class="line">    Connection: Keep-Alive\r\n</span><br><span class="line">    Content-Type: text/html; charset=UTF-8\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [HTTP response 1/1]</span><br><span class="line">    [Time since request: 0.261428000 seconds]</span><br><span class="line">    [Request in frame: 146]</span><br><span class="line">    [Request URI: http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html]</span><br><span class="line">    File Data: 4500 bytes</span><br><span class="line">Line-based text data: text/html (98 lines)</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol start="12"><li><p>How many HTTP GET request messages did your browser send?  Which packet number in the trace contains the GET message for the Bill or Rights?<br>Only one, packet 146.</p></li><li><p>Which packet number in the trace contains the status code and phrase associated with the response to the HTTP GET request?<br>Packet 176.</p></li><li><p>What is the status code and phrase in the response?<br>200(OK).</p></li><li><p>How many data-containing TCP segments were needed to carry the single HTTP response and the text of the Bill of Rights?<br>4.</p></li></ol><h3 id="HTML-Documents-with-Embedded-Objects"><a href="#HTML-Documents-with-Embedded-Objects" class="headerlink" title="HTML Documents with Embedded Objects"></a>HTML Documents with Embedded Objects</h3><p>Operations:</p><ul><li>Enter the following URL into your browser<br><a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html</a><br>Your browser should display a short HTML file with two images. These two images are referenced in the base HTML file.  That is, the images themselves are not contained in the HTML; instead the URLs for the images are contained in the downloaded HTML file. As discussed in the textbook, your browser will have to retrieve these logos from the indicated web sites.   Our publisher’s logo is retrieved from the gaia.cs.umass.edu web site.   The image of our 8th edition cover (one of our favorite covers) is stored at a server in France. </li></ul><p>Packets Captured:</p><table><thead><tr><th>“No.”</th><th>“Time”</th><th>“Source”</th><th>“Destination”</th><th>“Protocol”</th><th>“Length”</th><th>“Info”</th></tr></thead><tbody><tr><td>“28”</td><td>“2.033457”</td><td>“192.168.1.3”</td><td>“128.119.245.12”</td><td>“HTTP”</td><td>“581”</td><td>“GET /wireshark-labs/HTTP-wireshark-file4.html HTTP/1.1 “</td></tr><tr><td>“41”</td><td>“2.304704”</td><td>“128.119.245.12”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“1355”</td><td>“HTTP/1.1 200 OK  (text/html)”</td></tr><tr><td>“42”</td><td>“2.338977”</td><td>“192.168.1.3”</td><td>“128.119.245.12”</td><td>“HTTP”</td><td>“501”</td><td>“GET /pearson.png HTTP/1.1 “</td></tr><tr><td>“47”</td><td>“2.530706”</td><td>“192.168.1.3”</td><td>“178.79.137.164”</td><td>“HTTP”</td><td>“468”</td><td>“GET /8E_cover_small.jpg HTTP/1.1 “</td></tr><tr><td>“55”</td><td>“2.609925”</td><td>“128.119.245.12”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“841”</td><td>“HTTP/1.1 200 OK  (PNG)”</td></tr><tr><td>“58”</td><td>“2.695694”</td><td>“178.79.137.164”</td><td>“192.168.1.3”</td><td>“HTTP”</td><td>“225”</td><td>“HTTP/1.1 301 Moved Permanently “</td></tr></tbody></table><p>Packets Details:<br>…</p><p>Q&amp;As:</p><ol start="16"><li><p>How many HTTP GET request messages did your browser send?  To which Internet addresses were these GET requests sent?<br>Totally 3 GET requests, 2 to 128.119.245.12 to get html file and pearson.png, 1 to 178.79.137.164 for the 8E_cover_small.jpg.</p></li><li><p>Can you tell whether your browser downloaded the two images serially, or whether they were downloaded from the two web sites in parallel?  Explain.<br>In parallel.</p></li></ol><pre class="mermaid" style="text-align: center;">            sequenceDiagram            participant Browserparticipant ServerBrowser ->> Server: GET /pearson.png time:2.338977Browser -->> Server: GET /8E_cover_small.jpg time:2.530706Server ->> Browser: pearson.png time:2.609925Server -->>Browser: 8E_cover_small.jpg time:2.695694          </pre><h3 id="HTTP-Authentication"><a href="#HTTP-Authentication" class="headerlink" title="HTTP Authentication"></a>HTTP Authentication</h3><p>Operations:</p><ul><li>Enter the following URL into your browser<br><a href="http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html</a><br>Type the requested user name and password into the pop up box.  The username is “wireshark-students” (without the quotes), and the password is “network” (again, without the quotes).</li></ul><p>Packets Captured:</p><table><thead><tr><th>No.</th><th>Time</th><th>Source</th><th>Destination</th><th>Protocol</th><th>Length</th><th>Info</th></tr></thead><tbody><tr><td>125</td><td>5.558621</td><td>192.168.1.3</td><td>128.119.245.12</td><td>HTTP</td><td>597</td><td>GET /wireshark-labs/protected_pages/HTTP-wireshark-file5.html HTTP/1.1</td></tr><tr><td>140</td><td>5.823233</td><td>128.119.245.12</td><td>192.168.1.3</td><td>HTTP</td><td>771</td><td>HTTP/1.1 401 Unauthorized  (text/html)</td></tr><tr><td>726</td><td>26.553076</td><td>192.168.1.3</td><td>128.119.245.12</td><td>HTTP</td><td>656</td><td>GET /wireshark-labs/protected_pages/HTTP-wireshark-file5.html HTTP/1.1</td></tr><tr><td>737</td><td>26.823450</td><td>128.119.245.12</td><td>192.168.1.3</td><td>HTTP</td><td>544</td><td>HTTP/1.1 200 OK  (text/html)</td></tr></tbody></table><p>Packets Details:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Frame 125: 597 bytes on wire (4776 bits), 597 bytes captured (4776 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.3, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 28007, Dst Port: 80, Seq: 1, Ack: 1, Len: 543</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    GET /wireshark-labs/protected_pages/HTTP-wireshark-file5.html HTTP/1.1\r\n</span><br><span class="line">        [Expert Info (Chat/Sequence): GET /wireshark-labs/protected_pages/HTTP-wireshark-file5.html HTTP/1.1\r\n]</span><br><span class="line">        Request Method: GET</span><br><span class="line">        Request URI: /wireshark-labs/protected_pages/HTTP-wireshark-file5.html</span><br><span class="line">        Request Version: HTTP/1.1</span><br><span class="line">    Host: gaia.cs.umass.edu\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Cache-Control: max-age=0\r\n</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38\r\n</span><br><span class="line">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n</span><br><span class="line">    Accept-Encoding: gzip, deflate\r\n</span><br><span class="line">    Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [Full request URI: http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html]</span><br><span class="line">    [HTTP request 1/1]</span><br><span class="line">    [Response in frame: 140]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Frame 726: 656 bytes on wire (5248 bits), 656 bytes captured (5248 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.3, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 1028, Dst Port: 80, Seq: 1, Ack: 1, Len: 602</span><br><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    GET /wireshark-labs/protected_pages/HTTP-wireshark-file5.html HTTP/1.1\r\n</span><br><span class="line">        [Expert Info (Chat/Sequence): GET /wireshark-labs/protected_pages/HTTP-wireshark-file5.html HTTP/1.1\r\n]</span><br><span class="line">        Request Method: GET</span><br><span class="line">        Request URI: /wireshark-labs/protected_pages/HTTP-wireshark-file5.html</span><br><span class="line">        Request Version: HTTP/1.1</span><br><span class="line">    Host: gaia.cs.umass.edu\r\n</span><br><span class="line">    Connection: keep-alive\r\n</span><br><span class="line">    Cache-Control: max-age=0\r\n</span><br><span class="line">    Authorization: Basic d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=\r\n</span><br><span class="line">        Credentials: wireshark-students:network</span><br><span class="line">    Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line">    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38\r\n</span><br><span class="line">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n</span><br><span class="line">    Accept-Encoding: gzip, deflate\r\n</span><br><span class="line">    Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\r\n</span><br><span class="line">    \r\n</span><br><span class="line">    [Full request URI: http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html]</span><br><span class="line">    [HTTP request 1/1]</span><br><span class="line">    [Response in frame: 737]</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol start="18"><li>What is the server’s response (status code and phrase) in response to the initial HTTP GET message from your browser?</li></ol><p>401 Unauthorized.</p><ol start="19"><li>When your browser’s sends the HTTP GET message for the second time, what new field is included in the HTTP GET message?<br>Authorization: Basic d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=\r\n</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="Trace-DNS-from-web-browser"><a href="#Trace-DNS-from-web-browser" class="headerlink" title="Trace DNS from web browser"></a>Trace DNS from web browser</h3><p>Operations:</p><ul><li>Clear DNS cache by ‘ipconfig’ command</li><li>Open the following URL into your browser<br><a href="http://gaia.cs.umass.edu/kurose_ross/index.php" target="_blank" rel="noopener">http://gaia.cs.umass.edu/kurose_ross/index.php</a></li></ul><p>Captured packets:</p><table><thead><tr><th>No.</th><th>Time</th><th>Source</th><th>Destination</th><th>Protocol</th><th>Length</th><th>Info</th></tr></thead><tbody><tr><td>20</td><td>4.898665</td><td>fe80::604d:b1a2:55ef:5877</td><td>fe80::1</td><td>DNS</td><td>97</td><td>Standard query 0xcba9 A gaia.cs.umass.edu</td></tr><tr><td>29</td><td>4.908337</td><td>fe80::1</td><td>fe80::604d:b1a2:55ef:5877</td><td>DNS</td><td>113</td><td>Standard query response 0xcba9 A gaia.cs.umass.edu A 128.119.245.12</td></tr></tbody></table><p>Detail of packets:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Frame 20: 97 bytes on wire (776 bits), 97 bytes captured (776 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 6, Src: fe80::604d:b1a2:55ef:5877, Dst: fe80::1</span><br><span class="line">User Datagram Protocol, Src Port: 61277, Dst Port: 53</span><br><span class="line">Domain Name System (query)</span><br><span class="line">    Transaction ID: 0xcba9</span><br><span class="line">    Flags: 0x0100 Standard query</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 0</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        gaia.cs.umass.edu: type A, class IN</span><br><span class="line">            Name: gaia.cs.umass.edu</span><br><span class="line">            [Name Length: 17]</span><br><span class="line">            [Label Count: 4]</span><br><span class="line">            Type: A (Host Address) (1)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    [Response In: 29]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Frame 29: 113 bytes on wire (904 bits), 113 bytes captured (904 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">Internet Protocol Version 6, Src: fe80::1, Dst: fe80::604d:b1a2:55ef:5877</span><br><span class="line">User Datagram Protocol, Src Port: 53, Dst Port: 61277</span><br><span class="line">Domain Name System (response)</span><br><span class="line">    Transaction ID: 0xcba9</span><br><span class="line">    Flags: 0x8180 Standard query response, No error</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 1</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        gaia.cs.umass.edu: type A, class IN</span><br><span class="line">            Name: gaia.cs.umass.edu</span><br><span class="line">            [Name Length: 17]</span><br><span class="line">            [Label Count: 4]</span><br><span class="line">            Type: A (Host Address) (1)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    Answers</span><br><span class="line">        gaia.cs.umass.edu: type A, class IN, addr 128.119.245.12</span><br><span class="line">    [Request In: 20]</span><br><span class="line">    [Time: 0.009672000 seconds]</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol><li>Locate the first DNS query message resolving the name gaia.cs.umass.edu. What is the packet number  in the trace for the DNS query message?  Is this query message sent over UDP or TCP?</li></ol><p>20, UDP.</p><ol start="2"><li>Now locate the corresponding DNS response to the initial DNS query. What is the packet number in the trace for the DNS response message?  Is this response message received via UDP or TCP?   </li></ol><p>29, UDP.</p><ol start="3"><li>What is the destination port for the DNS query message? What is the source port of the DNS response message?</li></ol><p>53 .</p><ol start="4"><li>To what IP address is the DNS query message sent? </li></ol><p>fe80::1.</p><ol start="5"><li>Examine the DNS query message. How many “questions” does this DNS message contain? How many “answers” answers does it contain?</li></ol><p>Questions: 1<br>Answer RRs: 0</p><ol start="6"><li>Examine the DNS response message to the initial query message. How many “questions” does this DNS message contain? How many “answers” answers does it contain?</li></ol><p>Questions: 1<br>Answer RRs: 1</p><h3 id="Trace-DNS-from-nslookup"><a href="#Trace-DNS-from-nslookup" class="headerlink" title="Trace DNS from nslookup"></a>Trace DNS from nslookup</h3><p>Operations:</p><ul><li>Clear DNS cache by ‘ipconfig’ command</li><li>Do an nslookup on <a href="http://www.cs.umass.edu" target="_blank" rel="noopener">www.cs.umass.edu</a></li></ul><p>Captured packets:</p><table><thead><tr><th>No.</th><th>Time</th><th>Source</th><th>Destination</th><th>Protocol</th><th>Length</th><th>Info</th></tr></thead><tbody><tr><td>56</td><td>10.981691</td><td>fe80::604d:b1a2:55ef:5877</td><td>fe80::1</td><td>DNS</td><td>96</td><td>Standard query 0x7a54 A <a href="http://www.cs.umass.edu" target="_blank" rel="noopener">www.cs.umass.edu</a></td></tr><tr><td>57</td><td>10.981916</td><td>fe80::604d:b1a2:55ef:5877</td><td>fe80::1</td><td>DNS</td><td>96</td><td>Standard query 0xd102 AAAA <a href="http://www.cs.umass.edu" target="_blank" rel="noopener">www.cs.umass.edu</a></td></tr><tr><td>58</td><td>11.232144</td><td>fe80::1</td><td>fe80::604d:b1a2:55ef:5877</td><td>DNS</td><td>96</td><td>Standard query response 0xd102 AAAA <a href="http://www.cs.umass.edu" target="_blank" rel="noopener">www.cs.umass.edu</a></td></tr><tr><td>59</td><td>11.255062</td><td>fe80::1</td><td>fe80::604d:b1a2:55ef:5877</td><td>DNS</td><td>112</td><td>Standard query response 0x7a54 A <a href="http://www.cs.umass.edu" target="_blank" rel="noopener">www.cs.umass.edu</a> A 128.119.240.84</td></tr></tbody></table><p>Detail of packets:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Frame 56: 96 bytes on wire (768 bits), 96 bytes captured (768 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 6, Src: fe80::604d:b1a2:55ef:5877, Dst: fe80::1</span><br><span class="line">User Datagram Protocol, Src Port: 51185, Dst Port: 53</span><br><span class="line">Domain Name System (query)</span><br><span class="line">    Transaction ID: 0x7a54</span><br><span class="line">    Flags: 0x0100 Standard query</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 0</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        www.cs.umass.edu: type A, class IN</span><br><span class="line">            Name: www.cs.umass.edu</span><br><span class="line">            [Name Length: 16]</span><br><span class="line">            [Label Count: 4]</span><br><span class="line">            Type: A (Host Address) (1)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    [Response In: 59]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Frame 59: 112 bytes on wire (896 bits), 112 bytes captured (896 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">Internet Protocol Version 6, Src: fe80::1, Dst: fe80::604d:b1a2:55ef:5877</span><br><span class="line">User Datagram Protocol, Src Port: 53, Dst Port: 51185</span><br><span class="line">Domain Name System (response)</span><br><span class="line">    Transaction ID: 0x7a54</span><br><span class="line">    Flags: 0x8180 Standard query response, No error</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 1</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        www.cs.umass.edu: type A, class IN</span><br><span class="line">            Name: www.cs.umass.edu</span><br><span class="line">            [Name Length: 16]</span><br><span class="line">            [Label Count: 4]</span><br><span class="line">            Type: A (Host Address) (1)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    Answers</span><br><span class="line">        www.cs.umass.edu: type A, class IN, addr 128.119.240.84</span><br><span class="line">    [Request In: 56]</span><br><span class="line">    [Time: 0.273371000 seconds]</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol start="7"><li>What is the destination port for the DNS query message? What is the source port of the DNS response message?</li></ol><p>53</p><ol start="8"><li>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</li></ol><p>fe80::1, yes.</p><ol start="9"><li>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</li></ol><p>No.</p><ol start="10"><li>Examine the DNS response message to the query message. How many “questions” does this DNS response message contain? How many “answers”?</li></ol><p>Questions: 1<br>Answer RRs: 1</p><h3 id="Trace-DNS-from-nslookup-with-NS-type-record"><a href="#Trace-DNS-from-nslookup-with-NS-type-record" class="headerlink" title="Trace DNS from nslookup with NS type record"></a>Trace DNS from nslookup with NS type record</h3><p>Operations:</p><ul><li>Clear DNS cache by ‘ipconfig’ command</li><li>Do an nslookup -type=NS umass.edu</li></ul><p>Captured packets:</p><table><thead><tr><th>No.</th><th>Time</th><th>Source</th><th>Destination</th><th>Protocol</th><th>Length</th><th>Info</th></tr></thead><tbody><tr><td>37</td><td>1.731935</td><td>fe80::604d:b1a2:55ef:5877</td><td>fe80::1</td><td>DNS</td><td>89</td><td>Standard query 0x0002 NS umass.edu</td></tr><tr><td>38</td><td>1.738860</td><td>fe80::1</td><td>fe80::604d:b1a2:55ef:5877</td><td>DNS</td><td>143</td><td>Standard query response 0x0002 NS umass.edu NS ns2.umass.edu NS ns1.umass.edu NS ns3.umass.edu</td></tr></tbody></table><p>Detail of packets:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Frame 37: 89 bytes on wire (712 bits), 89 bytes captured (712 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Micro-St_06:62:ec (00:d8:61:06:62:ec), Dst: Fiberhom_35:92:b1 (74:5d:68:35:92:b1)</span><br><span class="line">Internet Protocol Version 6, Src: fe80::604d:b1a2:55ef:5877, Dst: fe80::1</span><br><span class="line">User Datagram Protocol, Src Port: 56756, Dst Port: 53</span><br><span class="line">Domain Name System (query)</span><br><span class="line">    Transaction ID: 0x0002</span><br><span class="line">    Flags: 0x0100 Standard query</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 0</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        umass.edu: type NS, class IN</span><br><span class="line">            Name: umass.edu</span><br><span class="line">            [Name Length: 9]</span><br><span class="line">            [Label Count: 2]</span><br><span class="line">            Type: NS (authoritative Name Server) (2)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    [Response In: 38]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Frame 38: 143 bytes on wire (1144 bits), 143 bytes captured (1144 bits) on interface \Device\NPF_&#123;0A0B317B-E1D8-4D27-9D8A-9E3EC63057D4&#125;, id 0</span><br><span class="line">Ethernet II, Src: Fiberhom_35:92:b1 (74:5d:68:35:92:b1), Dst: Micro-St_06:62:ec (00:d8:61:06:62:ec)</span><br><span class="line">Internet Protocol Version 6, Src: fe80::1, Dst: fe80::604d:b1a2:55ef:5877</span><br><span class="line">User Datagram Protocol, Src Port: 53, Dst Port: 56756</span><br><span class="line">Domain Name System (response)</span><br><span class="line">    Transaction ID: 0x0002</span><br><span class="line">    Flags: 0x8180 Standard query response, No error</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 3</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        umass.edu: type NS, class IN</span><br><span class="line">            Name: umass.edu</span><br><span class="line">            [Name Length: 9]</span><br><span class="line">            [Label Count: 2]</span><br><span class="line">            Type: NS (authoritative Name Server) (2)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    Answers</span><br><span class="line">        umass.edu: type NS, class IN, ns ns2.umass.edu</span><br><span class="line">        umass.edu: type NS, class IN, ns ns1.umass.edu</span><br><span class="line">        umass.edu: type NS, class IN, ns ns3.umass.edu</span><br><span class="line">    [Request In: 37]</span><br><span class="line">    [Time: 0.006925000 seconds]</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol start="11"><li>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</li></ol><p>fe80::1, yes.</p><ol start="12"><li>Examine the DNS query message. How many questions does the query have? Does the query message contain any “answers”?</li></ol><p>No.</p><ol start="13"><li>Examine the DNS response message.  How many answers does the response have?  What information is contained in the answers? </li></ol><p>3 answers, name servers of the name in query.</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="Upload-a-150-KB-file"><a href="#Upload-a-150-KB-file" class="headerlink" title="Upload a 150+ KB file"></a>Upload a 150+ KB file</h3><p>Captured data:</p><p>Answer the following questions , either from your own live trace, or by opening the Wireshark captured packet file tcp-wireshark-trace1-1 in  <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip</a>  </p><table><thead><tr><th>No.</th><th>Time</th><th>Source</th><th>Destination</th><th>Protocol</th><th>Length</th><th>Info</th></tr></thead><tbody><tr><td>1</td><td>0.000000</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>78</td><td>55639  &gt;  80 [SYN] Seq=0 Win=65535 Len=0 MSS=1460 WS=64 TSval=725607509 TSecr=0 SACK_PERM=1</td></tr><tr><td>2</td><td>0.022414</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>74</td><td>80  &gt;  55639 [SYN, ACK] Seq=0 Ack=1 Win=28960 Len=0 MSS=1460 SACK_PERM=1 TSval=3913851370 TSecr=725607509 WS=128</td></tr><tr><td>3</td><td>0.022505</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>66</td><td>55639  &gt;  80 [ACK] Seq=1 Ack=1 Win=131712 Len=0 TSval=725607531 TSecr=3913851370</td></tr><tr><td>4</td><td>0.024047</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=1 Ack=1 Win=131712 Len=1448 TSval=725607532 TSecr=3913851370 [TCP segment of a reassembled PDU]</td></tr><tr><td>5</td><td>0.024048</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=1449 Ack=1 Win=131712 Len=1448 TSval=725607532 TSecr=3913851370 [TCP segment of a reassembled PDU]</td></tr><tr><td>6</td><td>0.024049</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=2897 Ack=1 Win=131712 Len=1448 TSval=725607532 TSecr=3913851370 [TCP segment of a reassembled PDU]</td></tr><tr><td>7</td><td>0.052671</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=1449 Win=31872 Len=0 TSval=3913851399 TSecr=725607532</td></tr><tr><td>8</td><td>0.052676</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=2897 Win=34816 Len=0 TSval=3913851400 TSecr=725607532</td></tr><tr><td>9</td><td>0.052774</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=4345 Ack=1 Win=131712 Len=1448 TSval=725607560 TSecr=3913851399 [TCP segment of a reassembled PDU]</td></tr><tr><td>10</td><td>0.052775</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=5793 Ack=1 Win=131712 Len=1448 TSval=725607560 TSecr=3913851399 [TCP segment of a reassembled PDU]</td></tr><tr><td>11</td><td>0.052854</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=7241 Ack=1 Win=131712 Len=1448 TSval=725607560 TSecr=3913851400 [TCP segment of a reassembled PDU]</td></tr><tr><td>12</td><td>0.052855</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=8689 Ack=1 Win=131712 Len=1448 TSval=725607560 TSecr=3913851400 [TCP segment of a reassembled PDU]</td></tr><tr><td>13</td><td>0.053626</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=4345 Win=37760 Len=0 TSval=3913851400 TSecr=725607532</td></tr><tr><td>14</td><td>0.053710</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=10137 Ack=1 Win=131712 Len=1448 TSval=725607560 TSecr=3913851400 [TCP segment of a reassembled PDU]</td></tr><tr><td>15</td><td>0.053711</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=11585 Ack=1 Win=131712 Len=1448 TSval=725607560 TSecr=3913851400 [TCP segment of a reassembled PDU]</td></tr><tr><td>16</td><td>0.080768</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=5793 Win=40576 Len=0 TSval=3913851421 TSecr=725607560</td></tr><tr><td>17</td><td>0.080771</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=7241 Win=43520 Len=0 TSval=3913851422 TSecr=725607560</td></tr><tr><td>18</td><td>0.080772</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=8689 Win=46336 Len=0 TSval=3913851422 TSecr=725607560</td></tr><tr><td>19</td><td>0.080772</td><td>128.119.245.12</td><td>192.168.86.68</td><td>TCP</td><td>66</td><td>80  &gt;  55639 [ACK] Seq=1 Ack=10137 Win=49280 Len=0 TSval=3913851422 TSecr=725607560</td></tr><tr><td>20</td><td>0.080845</td><td>192.168.86.68</td><td>128.119.245.12</td><td>TCP</td><td>1514</td><td>55639  &gt;  80 [ACK] Seq=13033 Ack=1 Win=131712 Len=1448 TSval=725607588 TSecr=3913851421 [TCP segment of a reassembled PDU]</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Frame 1: 78 bytes on wire (624 bits), 78 bytes captured (624 bits) on interface en0, id 0</span><br><span class="line">Ethernet II, Src: Apple_98:d9:27 (78:4f:43:98:d9:27), Dst: Google_89:0e:c8 (3c:28:6d:89:0e:c8)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.86.68, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 55639, Dst Port: 80, Seq: 0, Len: 0</span><br><span class="line">    Source Port: 55639</span><br><span class="line">    Destination Port: 80</span><br><span class="line">    [Stream index: 0]</span><br><span class="line">    [TCP Segment Len: 0]</span><br><span class="line">    Sequence Number: 0    (relative sequence number)</span><br><span class="line">    Sequence Number (raw): 4236649187</span><br><span class="line">    [Next Sequence Number: 1    (relative sequence number)]</span><br><span class="line">    Acknowledgment Number: 0</span><br><span class="line">    Acknowledgment number (raw): 0</span><br><span class="line">    1011 .... = Header Length: 44 bytes (11)</span><br><span class="line">    Flags: 0x002 (SYN)</span><br><span class="line">    Window: 65535</span><br><span class="line">    [Calculated window size: 65535]</span><br><span class="line">    Checksum: 0xa1e4 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    Urgent Pointer: 0</span><br><span class="line">    Options: (24 bytes), Maximum segment size, No-Operation (NOP), Window scale, No-Operation (NOP), No-Operation (NOP), Timestamps, SACK permitted, End of Option List (EOL)</span><br><span class="line">        TCP Option - Maximum segment size: 1460 bytes</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">        TCP Option - Window scale: 6 (multiply by 64)</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">        TCP Option - Timestamps: TSval 725607509, TSecr 0</span><br><span class="line">        TCP Option - SACK permitted</span><br><span class="line">        TCP Option - End of Option List (EOL)</span><br><span class="line">    [Timestamps]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Frame 2: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface en0, id 0</span><br><span class="line">Ethernet II, Src: Google_89:0e:c8 (3c:28:6d:89:0e:c8), Dst: Apple_98:d9:27 (78:4f:43:98:d9:27)</span><br><span class="line">Internet Protocol Version 4, Src: 128.119.245.12, Dst: 192.168.86.68</span><br><span class="line">Transmission Control Protocol, Src Port: 80, Dst Port: 55639, Seq: 0, Ack: 1, Len: 0</span><br><span class="line">    Source Port: 80</span><br><span class="line">    Destination Port: 55639</span><br><span class="line">    [Stream index: 0]</span><br><span class="line">    [TCP Segment Len: 0]</span><br><span class="line">    Sequence Number: 0    (relative sequence number)</span><br><span class="line">    Sequence Number (raw): 1068969752</span><br><span class="line">    [Next Sequence Number: 1    (relative sequence number)]</span><br><span class="line">    Acknowledgment Number: 1    (relative ack number)</span><br><span class="line">    Acknowledgment number (raw): 4236649188</span><br><span class="line">    1010 .... = Header Length: 40 bytes (10)</span><br><span class="line">    Flags: 0x012 (SYN, ACK)</span><br><span class="line">    Window: 28960</span><br><span class="line">    [Calculated window size: 28960]</span><br><span class="line">    Checksum: 0x47b4 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    Urgent Pointer: 0</span><br><span class="line">    Options: (20 bytes), Maximum segment size, SACK permitted, Timestamps, No-Operation (NOP), Window scale</span><br><span class="line">        TCP Option - Maximum segment size: 1460 bytes</span><br><span class="line">        TCP Option - SACK permitted</span><br><span class="line">        TCP Option - Timestamps: TSval 3913851370, TSecr 725607509</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">        TCP Option - Window scale: 7 (multiply by 128)</span><br><span class="line">    [SEQ/ACK analysis]</span><br><span class="line">    [Timestamps]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Frame 4: 1514 bytes on wire (12112 bits), 1514 bytes captured (12112 bits) on interface en0, id 0</span><br><span class="line">Ethernet II, Src: Apple_98:d9:27 (78:4f:43:98:d9:27), Dst: Google_89:0e:c8 (3c:28:6d:89:0e:c8)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.86.68, Dst: 128.119.245.12</span><br><span class="line">Transmission Control Protocol, Src Port: 55639, Dst Port: 80, Seq: 1, Ack: 1, Len: 1448</span><br><span class="line">    Source Port: 55639</span><br><span class="line">    Destination Port: 80</span><br><span class="line">    [Stream index: 0]</span><br><span class="line">    [TCP Segment Len: 1448]</span><br><span class="line">    Sequence Number: 1    (relative sequence number)</span><br><span class="line">    Sequence Number (raw): 4236649188</span><br><span class="line">    [Next Sequence Number: 1449    (relative sequence number)]</span><br><span class="line">    Acknowledgment Number: 1    (relative ack number)</span><br><span class="line">    Acknowledgment number (raw): 1068969753</span><br><span class="line">    1000 .... = Header Length: 32 bytes (8)</span><br><span class="line">    Flags: 0x010 (ACK)</span><br><span class="line">    Window: 2058</span><br><span class="line">    [Calculated window size: 131712]</span><br><span class="line">    [Window size scaling factor: 64]</span><br><span class="line">    Checksum: 0xbd21 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    Urgent Pointer: 0</span><br><span class="line">    Options: (12 bytes), No-Operation (NOP), No-Operation (NOP), Timestamps</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">        TCP Option - Timestamps: TSval 725607532, TSecr 3913851370</span><br><span class="line">    [SEQ/ACK analysis]</span><br><span class="line">    [Timestamps]</span><br><span class="line">    TCP payload (1448 bytes)</span><br><span class="line">    [Reassembled PDU in frame: 153]</span><br><span class="line">    TCP segment data (1448 bytes)</span><br></pre></td></tr></table></figure><p>Q&amp;As:</p><ol><li>What is the sequence number of the TCP SYN segment that is used to initiate the TCP connection between the client computer and gaia.cs.umass.edu? (Note: this is the “raw” sequence number carried in the TCP segment itself; it is NOT the packet # in the “No.” column in the Wireshark window.  Remember there is no such thing as a “packet number” in TCP or UDP; as you know, there are sequence numbers in TCP and that’s what we’re after here.  Also note that this is not the relative sequence number with respect to the starting sequence number of this TCP session.). What is it in this TCP segment that identifies the segment as a SYN segment? Will the TCP receiver in this session be able to use Selective Acknowledgments (allowing TCP to function a bit more like a “selective repeat” receiver, see section 3.4.5 in the text)?</li></ol><p>Sequence Number (raw): 4236649187. </p><p>The ‘Flags: 0x002 (SYN)’ identifies the segment as a SYN segment.</p><p>Yes, there is an option ‘SACK permitted’.</p><ol start="2"><li>What is the sequence number of the SYNACK segment sent by gaia.cs.umass.edu to the client computer in reply to the SYN? What is it in the segment that identifies the segment as a SYNACK segment? What is the value of the Acknowledgement field in the SYNACK segment? How did gaia.cs.umass.edu determine that value? </li></ol><p>Sequence Number (raw): 1068969752</p><p>Flags: 0x012 (SYN, ACK) identifies the segment as a SYNACK segment.</p><p>Acknowledgment number (raw): 4236649188</p><p>Ack = Seq<sub>(peer)</sub> + 1.</p><ol start="3"><li>What is the sequence number of the TCP segment containing the header of the HTTP POST command?  Note that in order to find the POST message header, you’ll need to dig into the packet content field at the bottom of the Wireshark window, looking for a segment with the ASCII text “POST” within its DATA field , .  How many bytes of data are contained in the payload (data) field of this TCP segment? Did all of the data in the transferred file alice.txt fit into this single segment?</li></ol><p>Sequence Number (raw): 4236649188. </p><p>TCP payload (1448 bytes).</p><p>No.</p><ol start="4"><li>Consider the TCP segment containing the HTTP “POST” as the first segment in the data transfer part of the TCP connection.<br>•    At what time was the first segment (the one containing the HTTP POST) in the<br>data-transfer part of the TCP connection sent?  </li></ol><p>0.024047s.</p><p>•    At what time was the ACK for this first data-containing segment received?  </p><p>0.052671s.</p><p>•    What is the RTT for this first data-containing segment? </p><p>[The RTT to ACK the segment was: 0.028624000 seconds]</p><p>•    What is the RTT value the second data-carrying TCP segment and its ACK? </p><p>[The RTT to ACK the segment was: 0.028628000 seconds]</p><p>•    What is the EstimatedRTT value (see Section 3.5.3, in the text) after the ACK for the second data-carrying segment is received? Assume that in making this calculation after the received of the ACK for the second segment, that the initial value of EstimatedRTT is equal to the measured RTT for the first segment, and then is computed using the EstimatedRTT equation on page 242, and a value of $\alpha$ = 0.125.<br>Note: Wireshark has a nice feature that allows you to plot the RTT for each of the TCP segments sent.  Select a TCP segment in the “listing of captured packets” window that is being sent from the client to the gaia.cs.umass.edu server.  Then select: Statistics-&gt;TCP Stream Graph-&gt;Round Trip Time Graph.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mesured RTT for these two packets.</span><br><span class="line">[The RTT to ACK the segment was: 0.028624000 seconds]</span><br><span class="line">[The RTT to ACK the segment was: 0.028628000 seconds]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EstimatedRTT = (1 – α) • EstimatedRTT + α • SampleRTT</span><br><span class="line"></span><br><span class="line">So EstimatedRTT is $0.875*0.028624000 + 0.125*0.028628000 = 0.02862449s$.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.What is the length (header plus payload) of each of the first four data-carrying TCP segments?</span><br></pre></td></tr></table></figure><p>Transmission Control Protocol, Src Port: 55639, Dst Port: 80, Seq: 1, Ack: 1, Len: 1448<br>    TCP segment data (1448 bytes)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1448 Bytes.</span><br><span class="line"></span><br><span class="line">6.What is the minimum amount of available buffer space advertised to the client by gaia.cs.umass.edu among these first four data-carrying TCP segments ?  Does the lack of receiver buffer space ever throttle the sender for these first four data-carrying segments?</span><br></pre></td></tr></table></figure></p><p>[Calculated window size: 31872]<br>[Calculated window size: 34816]<br>[Calculated window size: 37760]<br>[Calculated window size: 40576]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">The lack of receiver buffer space **never** throttle the sender for these first four data-carrying segments</span><br><span class="line"></span><br><span class="line">7.Are there any retransmitted segments in the trace file? What did you check for (in the trace) in order to answer this question?</span><br><span class="line"></span><br><span class="line"> In the TimeSequence-Graph (Stevens) of this trace (if it&apos;s a straight line, click the reset direction button), all sequence numbers are incresing monotonically.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.How much data does the receiver typically acknowledge in an ACK among the first ten data-carrying segments sent from the client to gaia.cs.umass.edu?  Can you identify cases where the receiver is ACKing every other received segment (see Table 3.2 in the text) among these first ten data-carrying segments?</span><br><span class="line"></span><br><span class="line">1448 bytes, No.8 packet Ack=2897, and No.7 Ack=1449, it is Acking 1448 bytes.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.What is the throughput (bytes transferred per unit time) for the TCP connection?  Explain how you calculated this value.</span><br><span class="line"></span><br><span class="line">The last Ack is 153426, time is 0.191496s, and the first data carrying packet&apos;s time is 0.024047, so $bandwidth = 153426 byte / (0.191496s -  0.024047s) \approx 916255 byte/s$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.Use the Time-Sequence-Graph(Stevens) plotting tool to view the sequence number versus time plot of segments being sent from the client to the gaia.cs.umass.edu server.  Consider the “fleets” of packets sent around t = 0.025, t = 0.053, t = 0.082 and t = 0.1. Comment on whether this looks as if TCP is in its slow start phase, congestion avoidance phase or some other phase. Figure 6 shows a slightly different view of this data.</span><br><span class="line"></span><br><span class="line">Yes, in $t=0.025$ about 4 packets received, $t=0.053$ about 6 packets received, $t=0.082$ about 12 packets received, $t=0.1$ about 24 packets received, It is &apos;slow start&apos; mechanism of TCP, the window size grows up exponentially.</span><br><span class="line"></span><br><span class="line">11.These “fleets” of segments appear to have some periodicity. What can you say about the period?</span><br><span class="line"></span><br><span class="line">The period is close to the RTT, because the TCP need a RTT time at averange to calculate the new Esitimated RTT and decides how many packets will be sent.</span><br><span class="line"></span><br><span class="line">## UDP</span><br><span class="line"></span><br><span class="line">### Trigger UDP packets through nslookup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Captured data:</span><br><span class="line"></span><br><span class="line">Answer the following questions , either from your own live trace, or by opening the Wireshark captured packet trace file dns-wireshark-trace1-1 in  http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.Select the first UDP segment in your trace. What is the packet number  of this segment in the trace file?  What type of application-layer payload or protocol message is being carried in this UDP segment?  Look at the details of this packet in Wireshark.  How many fields there are in the UDP header? (You shouldn’t look in the textbook! Answer these questions directly from what you observe in the packet trace.) What are the names of these fields?</span><br></pre></td></tr></table></figure></p><p>User Datagram Protocol, Src Port: 47931, Dst Port: 1900<br>    Source Port: 47931<br>    Destination Port: 1900<br>    Length: 283<br>    Checksum: 0xf7a8 [unverified]<br>    [Checksum Status: Unverified]<br>    [Stream index: 0]<br>    [Timestamps]<br>        [Time since first frame: 0.000000000 seconds]<br>        [Time since previous frame: 0.000000000 seconds]<br>    UDP payload (275 bytes)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">5th, SSDP(Simple Service Discovery Protocol), There are 4 fields in UDP Header: Source Port, Destination Port, Length, Checksum.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.By consulting the displayed information in Wireshark’s packet content field for this packet (or by consulting the textbook), what is the length (in bytes) of each of the UDP header fields?</span><br><span class="line"></span><br><span class="line">Through observation, length of each field is 2 bytes.</span><br><span class="line"></span><br><span class="line">3.The value in the Length field is the length of what? (You can consult the text for this answer). Verify your claim with your captured UDP packet. </span><br><span class="line"></span><br><span class="line">The value of the length field is 283, which is  (UDP payload (275 bytes) + Header length(8 bytes) ).</span><br><span class="line"></span><br><span class="line">4.What is the maximum number of bytes that can be included in a UDP payload?  (Hint: the answer to this question can be determined by your answer to 2. above)</span><br><span class="line"></span><br><span class="line">The Maximum value of length field is 0xFFFF(65535 in decimal), so maximum bytes of payload is $65535 - 8 = 65527bytes$.</span><br><span class="line"></span><br><span class="line">5.What is the largest possible source port number? (Hint: see the hint in 4.)</span><br><span class="line"></span><br><span class="line">It is 65535.</span><br><span class="line"></span><br><span class="line">6.What is the protocol number for UDP? Give your answer in decimal notation. To answer this question, you’ll need to look into the Protocol field of the IP datagram containing this UDP segment (see Figure 4.13 in the text, and the discussion of IP header fields).</span><br></pre></td></tr></table></figure><p>Internet Protocol Version 4, Src: 10.0.0.254, Dst: 239.255.255.250<br>    0100 …. = Version: 4<br>    …. 0101 = Header Length: 20 bytes (5)<br>    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)<br>    Total Length: 303<br>    Identification: 0xa1c3 (41411)<br>    Flags: 0x40, Don’t fragment<br>    Fragment Offset: 0<br>    Time to Live: 4<br>    Protocol: UDP (17)<br>    Header Checksum: 0xd902 [validation disabled]<br>    [Header checksum status: Unverified]<br>    Source Address: 10.0.0.254<br>    Destination Address: 239.255.255.250</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">It is 17.</span><br><span class="line"></span><br><span class="line">7.Examine the pair of UDP packets in which your host sends the first UDP packet and the second UDP packet is a reply to this first UDP packet. (Hint: for a second packet to be sent in response to a first packet, the sender of the first packet should be the destination of the second packet).  What is the packet number  of the first of these two UDP segments in the trace file?  What is the packet number  of the second of these two UDP segments in the trace file? Describe the relationship between the port numbers in the two packets.</span><br></pre></td></tr></table></figure><p>request:<br>User Datagram Protocol, Src Port: 58350, Dst Port: 53<br>    Source Port: 58350<br>    Destination Port: 53<br>    Length: 43<br>    Checksum: 0xc31d [unverified]<br>    [Checksum Status: Unverified]<br>    [Stream index: 1]<br>    [Timestamps]<br>        [Time since first frame: 0.000000000 seconds]<br>        [Time since previous frame: 0.000000000 seconds]<br>    UDP payload (35 bytes)</p><p>response:<br>User Datagram Protocol, Src Port: 53, Dst Port: 58350<br>    Source Port: 53<br>    Destination Port: 58350<br>    Length: 59<br>    Checksum: 0x4af2 [unverified]<br>    [Checksum Status: Unverified]<br>    [Stream index: 1]<br>    [Timestamps]<br>        [Time since first frame: 0.023908000 seconds]<br>        [Time since previous frame: 0.023908000 seconds]<br>    UDP payload (51 bytes)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The destination port of the response packet is same as the request packet&apos;s source port, reverse is also true.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## IP</span><br><span class="line"></span><br><span class="line">### Capturing packets from an execution of traceroute</span><br><span class="line"></span><br><span class="line">Captured data:</span><br><span class="line"></span><br><span class="line">Answer the following questions , either from your own live trace, or by opening the Wireshark captured packet trace file ip-wireshark-trace1-1.pcapng in  http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip  </span><br><span class="line"></span><br><span class="line">#### Part 1: Basic IPv4</span><br><span class="line"></span><br><span class="line">1.Select the first UDP segment sent by your computer via the traceroute command to gaia.cs.umass.edu. (Hint: this is 44th packet in the trace file in the ip-wireshark-trace1-1.pcapng file in footnote 2). Expand the Internet Protocol part of the packet in the packet details window.  What is the IP address of your computer?</span><br></pre></td></tr></table></figure><p>Internet Protocol Version 4, Src: 192.168.86.61, Dst: 128.119.245.12<br>    0100 …. = Version: 4<br>    …. 0101 = Header Length: 20 bytes (5)<br>    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)<br>    Total Length: 56<br>    Identification: 0xfda1 (64929)<br>    Flags: 0x00<br>    Fragment Offset: 0<br>    Time to Live: 1<br>    Protocol: UDP (17)<br>    Header Checksum: 0x2faa [validation disabled]<br>    [Header checksum status: Unverified]<br>    Source Address: 192.168.86.61<br>    Destination Address: 128.119.245.12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IP of local computer is 192.168.86.61 .</span><br><span class="line"></span><br><span class="line">2.What is the value in the time-to-live (TTL) field in this IPv4 datagram’s header?</span><br><span class="line"></span><br><span class="line">1 .</span><br><span class="line"></span><br><span class="line">3.What is the value in the upper layer protocol field in this IPv4 datagram’s header? [Note: the answers for Linux/MacOS differ from Windows here].</span><br><span class="line"></span><br><span class="line">Protocol: UDP (17).</span><br><span class="line"></span><br><span class="line">4.How many bytes are in the IP header? </span><br><span class="line"></span><br><span class="line">.... 0101 = Header Length: 20 bytes (5).</span><br><span class="line"></span><br><span class="line">5.How many bytes are in the payload of the IP datagram?  Explain how you determined the number of payload bytes.</span><br><span class="line"></span><br><span class="line">$Payload Length = Total Length - Header Length = 56 - 20 = 36 Bytes$</span><br><span class="line"></span><br><span class="line">6.Has this IP datagram been fragmented?  Explain how you determined whether or not the datagram has been fragmented.</span><br><span class="line"></span><br><span class="line">No, if it is fragmented, the payload length of IP layer should be less than the Length of upper layer.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.Which fields in the IP datagram always change from one datagram to the next within this series of UDP segments sent by your computer destined to 128.119.245.12, via traceroute?  Why?</span><br><span class="line"></span><br><span class="line">TTL and destination port, because traceroute set the TTL to n to trigger a ICMP response packet (ttl exceeded) on the $n_&#123;th&#125;$ hot of the route of the packet. destination port is used to track the coresponding response of each packet. </span><br><span class="line"></span><br><span class="line">8.Which fields in this sequence of IP datagrams (containing UDP segments) stay constant? Why?</span><br><span class="line"></span><br><span class="line">The destination IP and the source port/IP, because the function of traceroute is to trace the route between the source IP and a specific destination IP.</span><br><span class="line"></span><br><span class="line">9.Describe the pattern you see in the values in the Identification field of the IP datagrams being sent by your computer.</span><br><span class="line"></span><br><span class="line">Plus 1 after every packet sent.</span><br><span class="line"></span><br><span class="line">10.What is the upper layer protocol specified in the IP datagrams returned from the routers? [Note: the answers for Linux/MacOS differ from Windows here].</span><br></pre></td></tr></table></figure><p>Internet Protocol Version 4, Src: 192.168.86.1, Dst: 192.168.86.61<br>    0100 …. = Version: 4<br>    …. 0101 = Header Length: 20 bytes (5)<br>    Differentiated Services Field: 0xc0 (DSCP: CS6, ECN: Not-ECT)<br>    Total Length: 84<br>    Identification: 0x6889 (26761)<br>    Flags: 0x00<br>    Fragment Offset: 0<br>    Time to Live: 64<br>    Protocol: ICMP (1)<br>    Header Checksum: 0xe3d0 [validation disabled]<br>    [Header checksum status: Unverified]<br>    Source Address: 192.168.86.1<br>    Destination Address: 192.168.86.61</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Protocol: ICMP (1).</span><br><span class="line"></span><br><span class="line">11.Are the values in the Identification fields (across the sequence of all of ICMP packets from all of the routers) similar in behavior to your answer to question 9 above?</span><br><span class="line"></span><br><span class="line">Yes.</span><br><span class="line"></span><br><span class="line">12. Are the values of the TTL fields similar, across all of ICMP packets from all of the routers?</span><br><span class="line"></span><br><span class="line">All equals to 1.</span><br><span class="line"></span><br><span class="line">#### Part 2: Fragmentation</span><br><span class="line"></span><br><span class="line">14.What information in the IP header indicates that this datagram been fragmented?</span><br></pre></td></tr></table></figure><p>Internet Protocol Version 4, Src: 192.168.86.61, Dst: 128.119.245.12<br>    0100 …. = Version: 4<br>    …. 0101 = Header Length: 20 bytes (5)<br>    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)<br>    Total Length: 1500<br>    Identification: 0xfda2 (64930)<br>    Flags: 0x20, More fragments<br>        0… …. = Reserved bit: Not set<br>        .0.. …. = Don’t fragment: Not set<br>        ..1. …. = More fragments: Set<br>    Fragment Offset: 0<br>    Time to Live: 1<br>    Protocol: UDP (17)<br>    Header Checksum: 0x0a05 [validation disabled]<br>    [Header checksum status: Unverified]<br>    Source Address: 192.168.86.61<br>    Destination Address: 128.119.245.12<br>    [Reassembled IPv4 in frame: 181]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Flags: 0x20, More fragments.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">15.What information in the IP header for this packet indicates whether this is the first fragment versus a latter fragment?  </span><br><span class="line"></span><br><span class="line">Fragment Offset: 0 indicates it is the first fragment, offset is non-zero value indicates it is a latter fragment.</span><br><span class="line"></span><br><span class="line">16.How many bytes are there in is this IP datagram (header plus payload)?</span><br><span class="line"></span><br><span class="line">Total Length: 1500.</span><br><span class="line"></span><br><span class="line">17.Now inspect the datagram containing the second fragment of the fragmented UDP segment. What information in the IP header indicates that this is not the first datagram fragment?  </span><br><span class="line"></span><br><span class="line">Fragment Offset: 1480.</span><br><span class="line"></span><br><span class="line">18.What fields change in the IP header between the first and second fragment?</span><br><span class="line"></span><br><span class="line">Fragment Offset and Header checksum.</span><br><span class="line"></span><br><span class="line">19.Now find the IP datagram containing the third fragment of the original UDP segment. What information in the IP header indicates that this is the last fragment of that segment?</span><br></pre></td></tr></table></figure></p><p>Internet Protocol Version 4, Src: 192.168.86.61, Dst: 128.119.245.12<br>    0100 …. = Version: 4<br>    …. 0101 = Header Length: 20 bytes (5)<br>    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)<br>    Total Length: 40<br>    Identification: 0xfda2 (64930)<br>    Flags: 0x01<br>        0… …. = Reserved bit: Not set<br>        .0.. …. = Don’t fragment: Not set<br>        ..0. …. = More fragments: Not set<br>    Fragment Offset: 2960<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Flags: 0x01, ..0. .... = More fragments: Not set.</span><br><span class="line"></span><br><span class="line">### Capturing IPV6 packets</span><br><span class="line"></span><br><span class="line">Captured data:</span><br><span class="line"></span><br><span class="line">Answer the following questions , either from your own live trace, or by opening the Wireshark captured packet trace file  ip-wireshark-trace2-1.pcapng in  http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip  </span><br><span class="line"></span><br><span class="line">#### Part 3: IPv6</span><br><span class="line"></span><br><span class="line">Let’s start by taking a closer look at the 20th packet in this trace, sent at t=3.814489.  This is a DNS request (contained in an IPv6 datagram) to an IPv6 DNS server for the IPv6 address of youtube.com.</span><br><span class="line"></span><br><span class="line">20.What is the IPv6 address of the computer making the DNS AAAA request?  This is the source address of the 20th packet in the trace. Give the IPv6 source address for this datagram in the exact same form as displayed in the Wireshark window .</span><br></pre></td></tr></table></figure></p><p>Internet Protocol Version 6, Src: 2601:193:8302:4620:215c:f5ae:8b40:a27a, Dst: 2001:558:feed::1<br>    0110 …. = Version: 6<br>    …. 0000 0000 …. …. …. …. …. = Traffic Class: 0x00 (DSCP: CS0, ECN: Not-ECT)<br>    …. …. …. 0110 0011 1110 1101 0000 = Flow Label: 0x63ed0<br>    Payload Length: 37<br>    Next Header: UDP (17)<br>    Hop Limit: 255<br>    Source Address: 2601:193:8302:4620:215c:f5ae:8b40:a27a<br>    Destination Address: 2001:558:feed::1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2601:193:8302:4620:215c:f5ae:8b40:a27a</span><br><span class="line"></span><br><span class="line">21.What is the IPv6 destination address for this datagram? Give this IPv6 address in the exact same form as displayed in the Wireshark window.  </span><br><span class="line"></span><br><span class="line">2001:558:feed::1</span><br><span class="line"></span><br><span class="line">22.What is the value of the flow label for this datagram?</span><br><span class="line"></span><br><span class="line">.... .... .... 0110 0011 1110 1101 0000 = Flow Label: 0x63ed0</span><br><span class="line"></span><br><span class="line">23.How much payload data is carried in this datagram?</span><br><span class="line"></span><br><span class="line">Payload Length: 37</span><br><span class="line"></span><br><span class="line">24.What is the upper layer protocol to which this datagram’s payload will be delivered at the destination?</span><br><span class="line"></span><br><span class="line">Next Header: UDP (17)</span><br><span class="line"></span><br><span class="line">Lastly,  find the IPv6 DNS response to the IPv6 DNS AAAA request made in the 20th packet in this trace.  This DNS response contains IPv6 addresses for youtube.com.</span><br><span class="line"></span><br><span class="line">25.How many IPv6 addresses are returned in the response to this AAAA request?</span><br></pre></td></tr></table></figure><p>Domain Name System (response)<br>    Transaction ID: 0x920d<br>    Flags: 0x8180 Standard query response, No error<br>    Questions: 1<br>    Answer RRs: 1<br>    Authority RRs: 0<br>    Additional RRs: 0<br>    Queries<br>    Answers<br>        youtube.com: type AAAA, class IN, addr 2607:f8b0:4006:815::200e<br>    [Request In: 20]<br>    [Time: 0.140916000 seconds]</p><p><code>`</code><br>Only one.</p><ol start="26"><li>What is the first of the IPv6 addresses returned by the DNS for youtube.com (in the ip-wireshark-trace2-1.pcapng trace file, this is also the address that is numerically the smallest)? Give this IPv6 address in the exact same shorthand form as displayed in the Wireshark window.</li></ol><p>2607:f8b0:4006:815::200e.</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><h3 id="Capturing-packets-from-an-execution-of-traceroute"><a href="#Capturing-packets-from-an-execution-of-traceroute" class="headerlink" title="Capturing packets from an execution of traceroute"></a>Capturing packets from an execution of traceroute</h3><p>Captured data:</p><p>Answer the following questions, either from your own live trace, or by opening the Wireshark captured packet trace file nat-inside-wireshark-trace1-1.pcapng and nat-outside-wireshark-trace1-1.pcapng in  <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip" target="_blank" rel="noopener">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces-8.1.zip</a>  </p><p>Let’s first take a look at what’s happening on the LAN side of the NAT router. Open the nat-inside-wireshark-trace1-1.pcapng trace file. In this file, you should see an HTTP GET request addressed to the external web server at IP address 138.76.29.8, as well as the subsequent HTTP response message (“200 OK”). Both of these messages in the trace file were captured on the LAN side of the router. </p><ol><li>What is the IP address of the client that sends the HTTP GET request in the nat-inside-wireshark-trace1-1.pcapng trace? What is the source port number of the TCP segment in this datagram containing the HTTP GET request? What is the destination IP address of this HTTP GET request? What is the destination port number of the TCP segment in this datagram containing the HTTP GET request?</li></ol><p>Internet Protocol Version 4, Src: 192.168.10.11, Dst: 138.76.29.8</p><p>Transmission Control Protocol, Src Port: 53924, Dst Port: 80, Seq: 1, Ack: 1, Len: 330</p><ol start="2"><li>At what time  is the corresponding HTTP 200 OK message from the webserver forwarded by the NAT router to the client on the router’s LAN side? </li></ol><p>[Time since first frame in this TCP stream: 0.030672101 seconds]<br>.</p><ol start="3"><li>What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP 200 OK message?</li></ol><p>Internet Protocol Version 4, Src: 138.76.29.8, Dst: 192.168.10.11</p><p>Transmission Control Protocol, Src Port: 80, Dst Port: 53924, Seq: 1, Ack: 331, Len: 547</p><p>In the following we’ll focus on these two HTTP messages (GET and 200 OK). Our goal below will be to locate these two HTTP messages in the trace file nat-outside-wireshark-trace1-1.pcapng, captured on the Internet-side link between the router and the ISP. Because the captured packets heading towards the server will have already been forwarded through the NAT router, some of the IP address and port numbers will have been changed as a result of NAT translation.</p><p>Open the trace file nat-outside-wireshark-trace1-1.pcapng. Note that the time stamps in this file and the nat-inside-wireshark-trace1-1.pcapng file are not necessarily synchronized. </p><p>In the nat-outside-wireshark-trace1-1.pcapng trace file, find the HTTP GET message that corresponds to the HTTP GET message that was sent from the client to the 138.76.29.8 server at time t=0.27362245, where t=0.27362245 is the time at which this message was sent, as recorded in the nat-inside-wireshark-trace1-1.pcapng trace file.  </p><ol start="4"><li>At what time does this HTTP GET message appear in the nat-outside-wireshark-trace1-1.pcapng trace file? </li></ol><p>[Time since first frame in this TCP stream: 0.027356291 seconds]<br>.</p><ol start="5"><li>What are the source and destination IP addresses and TCP source and destination port numbers on the IP datagram carrying this HTTP GET (as recorded in the nat-outside-wireshark-trace1-1.pcapng trace file)? </li></ol><p>Internet Protocol Version 4, Src: 10.0.1.254, Dst: 138.76.29.8<br>Transmission Control Protocol, Src Port: 53924, Dst Port: 80, Seq: 1, Ack: 1, Len: 330</p><ol start="6"><li>Which of these four fields are different than in your answer to question 1 above?</li></ol><p>The source IP changed.</p><ol start="7"><li>Are any fields in the HTTP GET message changed? </li></ol><p>None.</p><ol start="8"><li>Which of the following fields in the IP datagram carrying the HTTP GET are changed from the datagram received on the local area network (inside) to the corresponding datagram forwarded on the Internet side (outside) of the NAT router: Version, Header Length, Flags, Checksum?</li></ol><p>Checksum changed.</p><p>Let’s continue to look at the nat-outside-wireshark-trace1-1.pcapng trace file. Find the HTTP reply containing the “200 OK” message that was received in response to the HTTP GET request you just examined in questions 4-8 above.</p><ol start="9"><li>At what time does this message appear in the nat-outside-wireshark-trace1-1.pcapng trace file? </li></ol><p>[Time since first frame in this TCP stream: 0.030625966 seconds]<br>.</p><ol start="10"><li>What are the source and destination IP addresses and TCP source and destination port numbers on the IP datagram carrying this HTTP reply (“200 OK”) message (as recorded in the nat-outside-wireshark-trace1-1.pcapng trace file)? </li></ol><p>Internet Protocol Version 4, Src: 138.76.29.8, Dst: 10.0.1.254</p><p>Transmission Control Protocol, Src Port: 80, Dst Port: 53924, Seq: 1, Ack: 331, Len: 547</p><p>Lastly, let’s consider what happens when the NAT router receives this datagram that you examined in questions 9 and 10, performs NAT translation, and finally forwards that datagram to the destination host on the LAN side. Based on your answers to questions 1 through 10 above and your knowledge of how NAT works, you should be able to answer the following question without actually looking at the nat-inside-wireshark-trace1-1.pcapng trace file:</p><ol start="11"><li>What are the source and destination IP addresses and TCP source and destination port numbers on the IP datagram carrying the HTTP reply (“200 OK”) that is forwarded from the router to the destination host in the right of Figure 1?</li></ol><p>Internet Protocol Version 4, Src: 138.76.29.8, Dst: 192.168.10.11</p><p>Transmission Control Protocol, Src Port: 80, Dst Port: 53924</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><h2 id="Ethernet-and-ARP"><a href="#Ethernet-and-ARP" class="headerlink" title="Ethernet and ARP"></a>Ethernet and ARP</h2><h2 id="802-11-WiFi"><a href="#802-11-WiFi" class="headerlink" title="802.11 WiFi"></a>802.11 WiFi</h2><h2 id="SSL-currently-being-updated-to-TLS"><a href="#SSL-currently-being-updated-to-TLS" class="headerlink" title="SSL (currently being updated to TLS)"></a>SSL (currently being updated to TLS)</h2><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><div id="refer-anchor-1"></div></p><ul><li>[1] <a href="https://gaia.cs.umass.edu/kurose_ross/wireshark.php" target="_blank" rel="noopener">Umass Wireshark labs</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;intruduction&quot;&gt;&lt;a href=&quot;#intruduction&quot; class=&quot;headerlink&quot; title=&quot;intruduction&quot;&gt;&lt;/a&gt;intruduction&lt;/h1&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;“Tell me and I forget. Show me and I remember. Involve me and I understand.”&lt;br&gt;&lt;em&gt;Chinese proverb&lt;/em&gt;&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;I read the &lt;em&gt;Computer Networks: Top-Down Approach&lt;/em&gt; about 3 years ago preparing for my CN-GRE, after read this book, I learned a lot about computer network, the reading helped me to fill in the blanks on the test paper, but I don’t have the confidence to tell others I know the principles behind computer network, expecially after years of forgetting process.&lt;/p&gt;
&lt;p&gt;So I decide to do a wireshark homework in this weekend.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer Network" scheme="https://xigou.github.io/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>[Group testing]群组测试：毒药谜题</title>
    <link href="https://xigou.github.io/2019/04/28/2019-04-28-Group-testing/"/>
    <id>https://xigou.github.io/2019/04/28/2019-04-28-Group-testing/</id>
    <published>2019-04-28T17:53:41.000Z</published>
    <updated>2022-04-27T02:22:55.027Z</updated>
    
    <content type="html"><![CDATA[<h5 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h5><p>这个问题在统计学和组合数学领域被称为群组测试问题(Group testing),问题源于二战时期，美国需要通过血样检测美军是否携带梅毒，但是血液检测耗时耗钱，将每个士兵的血液都检查一遍效率很低。考虑到携带梅毒的总归是少数，Rosenblatt和Dorfman提出将全部待检测士兵的血样分组混合后再检测，如果混合后的血样没有病毒，可以推定整个组都没有病毒，如此便能够减少不必要的检测。</p><a id="more"></a><p>  将以上问题标准化描述如下：</p><ul><li>给定集合<strong>N</strong>，其中有<strong>n</strong>个个体，每个个体要么是正例(Positive)要么是负例(Negative)，记其中正例个数为<strong>d</strong>。</li><li>目标：通过尽量少的测试次数，找出所有的负例。</li><li>群组测试(Group testing)：在<strong>N</strong> 的一个子集上测试（与在每个个体上测试相对）。</li></ul><p>这样做有一个前提：d&lt;&lt; n；可以设想，如果一个集合N当中大多数都是正例，那你随便找个子集，大概率都是含有正例的， 那么就不能达到排除一个子集的效果，这个方法就失去意义了。</p><p>Katona在1976年介绍了一种矩阵表示法，只需要$ \log_2{n} $次测试即可检测出n个样本中的一个正例，并且证明的其最优性。这个方法就是被各个互联网公司面试题疯狂引用的1000瓶药中有一瓶有毒，要求用最少的小白鼠检测出这一瓶毒药的题目。我也刷过，但是不得不吐槽，起码对我来讲，倘若没见过这个题目的解法，要想自己独立思考出来，可以说是难如登天，即使有些人能够写下解法，但是这个“最优”一词，可能很少有人能说上来其中的原因。反正大加面试题抄来抄去，也没有认真想过为什么要出这么个面试题，可能面试官觉得自己已经背过了，不出给别人觉得浪费。</p><p>吐槽完了还是简单说说这个题目的解法，就免得部分同学再点到其他网页游览一圈了。将1000只老鼠用二进制的$ (1) _{10} $到$ (1000) _{10} $编上序号，需要10位二进制码，然后把序号第1位为1的药混合在一起喂给老鼠1，….然后把序号第10位为1的药混合在一起喂给老鼠10。假设老鼠i死掉了，那么可以推定毒药的编号的第i位是1，把每只老鼠的实验结果综合起来，就能得到毒药编号的每一位，毒药就找出来了。另外，前述的此法所需测试次数 $ \log_2{n} $ 实际上就是所需二进制编码的位数。</p><p>一般，对上述从n个样本中寻找一个正例的问题，很容易能想到的就是采用二分法去寻找，把样本分成两份，分别进行群组测试，那么只有一个能包含正例，所以，排除一半，对另一半进行检测····使用此法也能在$ \log_2{n} $次检测结束后找到解。不过此法与Katona的方法区别在于，此法是多阶段的决策(adaptive Algorithm)，比如第二次对哪一拨进行测试，要根据第一次的测试结果来确定。但是Katona方法则不同，其在测试开始前即可确定全部的测试群组的划分(non-adaptive Algorithm)。</p><hr><p>以上的只是一些老生常谈的问题，可能大家都看过无数遍了，我为甚么又要提起这个问题，还要谁个博文呢？主要是我昨天参加了IGG的线上笔试题，这个公司不走寻常路，出了一个这个问题的加强版，也就是在n个样本中寻找d个正例。这种题一下子就触及到我这样的刷题党的知识盲区了，因为之前没见过，要现场想出个解法太难了。</p><p>但是当时我还是大致写了个方法，不过不严密，当时也想的比较混乱。大致思想如下，既然已知其中有d个正例，我直接把样本随机分为d份，然后分别进行群组测试，按照鸽笼原理和统计学常识，这些正例恰好每组一个的概率是不太大的，所以能够淘汰掉一些群组。一直重复这个过程就能够排除掉很多负例。但是达到一定程度(在剩余样本里正例占比很大的时候)，就不能再采用分组测试了，应该采用单独测试。后来我去查阅文献，发现这个思想和文章[1]类似。</p><h5 id="信息论下界"><a href="#信息论下界" class="headerlink" title="-信息论下界"></a>-信息论下界</h5><p>从信息论讲，这个问题(仅有一个正例)一定有一个下界。因为每次测试只有两个输出信息—正例or负例，因此进行k次测试最多表示$2^k$种信息状态，因此，至少要$ \log_2{n} $次测试才能获得足够的信息，因此，下界为$ \log_2{n} $。<br>同理，对于d个正例的情况，下界为$ \log_2{n \choose d} $。当然，下界一般而言是难以达到的。</p><p>解法1：可以简单地想到一种解法，利用二分法去解决，首先把n个样本分成两份进行检测，有毒（正例）的群组继续检测，没毒的部分排除，一直重复这个过程直到剩下的样本总数等于d，就找到所有的正例了。这个方法实际上就是算法中常用的剪枝的思想，剪枝越早，效率越高，假设你运气好，没走几步就只剩下d个可疑样本了，那就直接求出结果了。再来看看它的复杂度，由于其中只有d个样本是正例，那么在二叉搜索树的某一个层上最多只有d个节点能被检测出正例，而二叉树的深度是$ \log_2{n} $，所以复杂度为$O(d \log_2{n} )$。而哪个IGG笔试的题目实际上就是要求这个复杂度，只能说考试总是这样，交卷了思维才会清晰起来，呵呵。</p><p>但是这个方法也不是没有问题，因为它是adaptive的，需要的时间复杂度是$ \log_2{n} $，也就是要进行至多$ \log_2{n} $次的试验。如果题目要求一次就测出来，那么就还需要一个提前决定测试分组的编码方案，并且在测试结果出来之后能够解码得出到底哪些是正例。由于我对类问题兴趣不大，所以暂时不想深究,有兴趣的可以去文献[3]尝试寻找答案。</p><p><em>最近比较忙，倘若日后有空再去看这个问题，如果你有了自己的见解欢迎分享给我，万分感谢。</em></p><p>//TODO</p><p>[1]: Li, Chou Hsiung (June 1962). “A sequential method for screening experimental variables”. Journal of the American Statistical Association. 57 (298): 455–477. doi:10.1080/01621459.1962.10480672<br>[2]:<a href="https://en.wikipedia.org/wiki/Group_testing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Group_testing</a><br>[3]:Ding-Zhu, Du; Hwang, Frank K. (1993). Combinatorial group testing and its applications. Singapore: World Scientific. ISBN 978-9810212933.</p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h5&gt;&lt;p&gt;这个问题在统计学和组合数学领域被称为群组测试问题(Group testing),问题源于二战时期，美国需要通过血样检测美军是否携带梅毒，但是血液检测耗时耗钱，将每个士兵的血液都检查一遍效率很低。考虑到携带梅毒的总归是少数，Rosenblatt和Dorfman提出将全部待检测士兵的血样分组混合后再检测，如果混合后的血样没有病毒，可以推定整个组都没有病毒，如此便能够减少不必要的检测。&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="https://xigou.github.io/categories/面试题/"/>
    
    
    <category term="面试题" scheme="https://xigou.github.io/tags/面试题/"/>
    
  </entry>
  
  <entry>
    <title>（大合集）各种排序算法的介绍与实现</title>
    <link href="https://xigou.github.io/2017/06/04/2017-06-5-sort_agrithon/"/>
    <id>https://xigou.github.io/2017/06/04/2017-06-5-sort_agrithon/</id>
    <published>2017-06-04T17:14:31.000Z</published>
    <updated>2022-04-27T02:22:55.027Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前边</strong>：这篇文章又臭又长，纯属个人无聊总结之作。</p><p>[TOC]</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>排序算法在计算机界是很基础，很重要的，对人类也是至关重要的，没有排序算法，就难以把人类分成三六九等区别对待了，那样的世界真是无法想象啊。</p>            <i class="fa fa-quote-right"></i>          </blockquote><a id="more"></a><p>为了演示方便，此文排序的对象都是一个int类型的vector，其中交换两个元素，采用了位运算，至于为什么，第一是我恰好会，第二是，我认为这三行写在一起有一种独特的美感。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec[i]=vec[j]^vec[i];</span><br><span class="line">vec[j]=vec[j]^vec[i];</span><br><span class="line">vec[i]=vec[j]^vec[i];</span><br></pre></td></tr></table></figure></p><p> (看起来似乎有点画蛇添足了，还不如。sort()……)。</p><h2 id="1-菜鸟排序"><a href="#1-菜鸟排序" class="headerlink" title="1.菜鸟排序"></a>1.菜鸟排序</h2><p>这个排序算法，是所有学生最开始接触编程的时候碰到的一个算法，其地位就像是&gt;hello world！&lt;在IT界的地位一般，所以必须放在开头。</p><p>其思想相当接近大多数常人的思维，从前向后，对每个位置，都从当前位置开始，向后面扫描，如果发现一个元素比当前位置的值大，就把它，交换过来。</p><p>这个算法，大约进行（n到1求和）次比较操作，所以复杂度是O(n^2)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">noob sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noob_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size()<span class="number">-1</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;vec.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[j]&gt;vec[i])</span><br><span class="line">&#123;</span><br><span class="line">vec[i]=vec[j]^vec[i];</span><br><span class="line">vec[j]=vec[j]^vec[i];</span><br><span class="line">vec[i]=vec[j]^vec[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-选择排序（selected-sort）"><a href="#2-选择排序（selected-sort）" class="headerlink" title="2. 选择排序（selected sort）"></a>2. 选择排序（selected sort）</h2><p>一般同学们学到了上面那个算法，老师们就会指出，其中的很多交换是不必要的，如果我们先找出当前元素后面最大或者最小的元素，就能只用一次交换将一个元素放到正确的位置。于是就有了如下算法，用一个变量存储，后边的元素中最大或最小的元素下标，在遍历完之后才进行交换操作，减少了交换的次数，提高了效率。</p><p>不过它的复杂度依然是O(n^2)，因为这种优化带来的效果是操作次数常数倍的减少，决定这个算法效率的关键是比较的次数，这一类依赖于比较的算法，可以严格证明它们的复杂度是有下限的，稍后将会看到这样的算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">selected sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selected_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i,j,k;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size()<span class="number">-1</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line"> k= i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;vec.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(vec[j]&gt;vec[k])</span><br><span class="line">&#123;</span><br><span class="line">k=j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vec[i]=vec[k]^vec[i];</span><br><span class="line">vec[k]=vec[k]^vec[i];</span><br><span class="line">vec[i]=vec[k]^vec[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-冒泡排序（bubble-sort）"><a href="#3-冒泡排序（bubble-sort）" class="headerlink" title="3. 冒泡排序（bubble sort）"></a>3. 冒泡排序（bubble sort）</h2><p>这个算法的思想是从左往右去遍历数组，每次比较相邻两个元素的大小，如果其大小和你需要的大小关系相反（假设需要从大到小排序，那么你需要的排序结果左边的元素一定大于等于右边的元素），就交换两个元素的位置，这样一次从左到右的遍历，就能把最小的元素放到最后面去，这个最小的元素也就走到了它该去的地方，完成了历史的使命。第二次遍历的时候也就不用考虑这个元素了，具体来讲就是遍历范围的右边界减去1.</p><p>这个过程类似于每次把一个比较轻的泡泡冒出水面，所以这个算法叫做冒泡法。对于一个长度为n的数组，这个算法第i趟的时候需要比较n-i次，所以算法的复杂度依然是O(n^2)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bubble sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=vec.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i+<span class="number">1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[j]&gt;vec[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[j]=vec[j<span class="number">-1</span>]^vec[j];</span><br><span class="line">vec[j<span class="number">-1</span>]=vec[j<span class="number">-1</span>]^vec[j];</span><br><span class="line">vec[j]=vec[j<span class="number">-1</span>]^vec[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-鸡尾酒排序（cocktail-sort）"><a href="#3-鸡尾酒排序（cocktail-sort）" class="headerlink" title="3. 鸡尾酒排序（cocktail sort）"></a>3. 鸡尾酒排序（cocktail sort）</h2><p>这个算法是冒泡排序的一个变种，它的具体做法就是来回冒泡，每次把一个泡泡冒到右边，然后把一个石子沉到水底，代码实现方面，用两个变量存储遍历的左右边界，每次从左向右遍历到头就将右边界减一后向左遍历，如此，直到左右边界重合，排序就完成了。这个算法相比于冒泡排序，性能上没有优化，复杂度依然是n^2只是过程显得更加酷炫狂拽，估计也就因此得名鸡尾酒，如果是中国人发明的估计应该命名洗剪吹算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cocktail sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cocktail_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=vec.size()<span class="number">-1</span>,k;</span><br><span class="line"><span class="keyword">while</span>(j&gt;i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=i;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[k]&lt;vec[k+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[k]=vec[k+<span class="number">1</span>]^vec[k];</span><br><span class="line">vec[k+<span class="number">1</span>]=vec[k+<span class="number">1</span>]^vec[k];</span><br><span class="line">vec[k]=vec[k+<span class="number">1</span>]^vec[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">if</span>(j&gt;i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=j<span class="number">-1</span>;k&gt;=i;k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[k]&lt;vec[k+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[k]=vec[k+<span class="number">1</span>]^vec[k];</span><br><span class="line">vec[k+<span class="number">1</span>]=vec[k+<span class="number">1</span>]^vec[k];</span><br><span class="line">vec[k]=vec[k+<span class="number">1</span>]^vec[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-插入排序（insertion-sort）"><a href="#4-插入排序（insertion-sort）" class="headerlink" title="4. 插入排序（insertion sort）"></a>4. 插入排序（insertion sort）</h2><p>这个算法的思想依次选取待排数组中间的元素，插入到已经有序的数组内合适的位置，最终得到的元素序列就是有序的。初始的时候，我们从待排数组左边选择一个元素当作是已经有序的数组。</p><p>分析它的复杂度我们主要看发生的比较的次数，插入的时候我们是有序数列的从一侧向另一侧遍历，如果运气好，比较一次就找到了它应该在的位置，如果数组本身是反序的，你每次都要从左到右把已经有序的部分比较完才能找到其应该的位置。所以这个算法的复杂度和以上几个有了不一样的地方，有最好的和最坏的情况，这种情形用复杂度的期望来衡量复杂度是比较自然而然的做法。</p><p>总共需要插入n次，第i次插入操作平均会比较（i-1）2次，所以他的期望的复杂度为O（n^2/2）==O(n^2).</p><p>插入排序实际上可以优化到O(nlog(n),插入的时候采用二分法插入即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insertion sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;vec.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[j]&gt;vec[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[j]=vec[j<span class="number">-1</span>]^vec[j];</span><br><span class="line">vec[j<span class="number">-1</span>]=vec[j<span class="number">-1</span>]^vec[j];</span><br><span class="line">vec[j]=vec[j<span class="number">-1</span>]^vec[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-堆排序（heap-sort）"><a href="#5-堆排序（heap-sort）" class="headerlink" title="5. 堆排序（heap sort）"></a>5. 堆排序（heap sort）</h2><p>堆排序是利用了堆的特性，根据大根堆的定义，堆的根就是整个堆当中最大的一个元素，那么我们不断的去取出这个根（由于取出后会重建堆，导致新的根被选出来），那么得到的数列就是有序的了。</p><p>所以说这个算法关键在建一个堆，此处采用线性存储结构，直接用数组存储堆，为了原地排序，我们取出堆的根之后，重建堆，这样尾端就会空出一个位置，把取出的元素放到这个位置，等堆的元素个数为1的时候，数组就有序了。</p><p>若我们不看堆的操作，这个算法就需要n-1次操作就能完成任务啦，现实是我们必须考虑每次取出堆头后堆的重建。由于堆是完全二叉树，所以这个树的深度最多log(n)+1,根据堆调整过程，最多log(n)次的比较交换就能完成调整。所以算法复杂度为O（n*log(n)），这个数字就是比较类算法的复杂度的下限，可见它是一种很快的算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> heap sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebuild_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> n,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> largest=n;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*n&gt;size)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">2</span>*n&lt;=size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[n]&lt;vec[<span class="number">2</span>*n])</span><br><span class="line">&#123;</span><br><span class="line">largest=<span class="number">2</span>*n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> largest=n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">2</span>*n+<span class="number">1</span>&lt;=size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[<span class="number">2</span>*n+<span class="number">1</span>]&gt;vec[largest])</span><br><span class="line">&#123;</span><br><span class="line">largest=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(largest!=n)</span><br><span class="line">&#123;</span><br><span class="line">vec[n]=vec[n]^vec[largest];</span><br><span class="line">vec[largest]=vec[n]^vec[largest];</span><br><span class="line">vec[n]=vec[n]^vec[largest];</span><br><span class="line">rebuild_heap(vec,largest,size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=vec.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">rebuild_heap(vec,i,vec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i,size;</span><br><span class="line">size=vec.size()<span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*build  heap*/</span></span><br><span class="line">build_heap(vec);</span><br><span class="line">  <span class="keyword">for</span>(i=size;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">vec[<span class="number">1</span>]=vec[size]^vec[<span class="number">1</span>];</span><br><span class="line">vec[size]=vec[size]^vec[<span class="number">1</span>];</span><br><span class="line">vec[<span class="number">1</span>]=vec[size]^vec[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/*1和size位置的值交换*/</span></span><br><span class="line">size--;</span><br><span class="line">rebuild_heap(vec, <span class="number">1</span>, size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="桶排序（-bucket-sort）"><a href="#桶排序（-bucket-sort）" class="headerlink" title="桶排序（ bucket sort）"></a>桶排序（ bucket sort）</h2><p>这个算法的思想是，给出一列有顺序的桶，每个桶编上号，从待排数列中取出一个元素，放到对应标号的桶里，这个操作在程序实现的时候极其方便，用数组的下标作为桶号，只需要一个赋值语句即可，对应桶的位置上的数字，用来标记桶号在待排数组内出现的次数。</p><p>输出的时候，按顺序扫描桶，若桶是空的，就跳过，若不空就根据桶中的数字输出相应个数的元素。</p><p>根据原理，很显然，只需要一次遍历就能把元素放进桶内，再一次便利桶即可输出有序的元素，为保证每个元素都能找到属于自己的桶，桶的个数需要包含待排数组的最小和最大值中间的所以情况。倘若待排数组长度n，桶个数m，那么算法的空间复杂度就是O(m)，时间复杂度就是O(n+m).</p><p>这似乎打破了前述的nlog(n)的复杂度下限，其实不然，之前说的复杂度下限，是直的基于比较的排序算法，而桶排序是不需要比较的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> bucket sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bucket_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket;</span><br><span class="line">bucket.resize(vec.size(),<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*造桶*/</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">bucket[vec[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bucket.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(bucket[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i);</span><br><span class="line">bucket[i]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="proxmap-sort"><a href="#proxmap-sort" class="headerlink" title="proxmap sort"></a>proxmap sort</h2><p>这东西没找着中文翻译，据我猜测 proximal是近似的意思，map是映射，它的中文应该是近似映射排序吧。</p><p>这是桶排序的升级版，桶排序最大的缺点就是浪费空间，因为桶排序中，大部分的桶都是空着的，所以有人提出每个桶装某个范围内的元素，所以它直接指定定一个桶的范围，然后在入桶的时候采用插入排序，最后遍历桶输出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">proxmap sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proxmap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</span><br><span class="line">bucket.resize(vec.size()/<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*造桶*/</span></span><br><span class="line">  <span class="keyword">int</span> i,j,k,* n,* m;</span><br><span class="line"><span class="comment">//入桶</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=bucket.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[i]&lt;<span class="number">10</span>*j)</span><br><span class="line">&#123;</span><br><span class="line">bucket[j<span class="number">-1</span>].push_back(vec[i]);</span><br><span class="line"><span class="keyword">for</span>(k=bucket[j<span class="number">-1</span>].size()<span class="number">-1</span>;k&gt;<span class="number">0</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">m=&amp;bucket[j<span class="number">-1</span>][k];</span><br><span class="line">n=&amp;bucket[j<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(*n&lt;*m)</span><br><span class="line">&#123;</span><br><span class="line">*n=*n^(*m);</span><br><span class="line">*m=*n^(*m);</span><br><span class="line">*n=*n^(*m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出桶</span></span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bucket.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(bucket[j].size())</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(bucket[j].back());</span><br><span class="line">bucket[j].pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h2><p>这个基数也就是数学中各种进制数字表示法的基数，由于我们用的是十进制，在此处，基数就是10。</p><p>这个算法分配十个桶，标号0到9，先按照个位数入桶，然后从左到右遍历桶，将元素取出，按照十位数字入桶，以此类推。</p><p>分析一下这个操作，就知道，按照个位数入桶的时候，个位数小的第二轮会先入桶，也就是说，第二轮完毕之后，每个桶内十位数相同，但是个位数小的被压在下面。继续分析，到百位数入桶的时候，每个桶十位数小的被压在下面，那这些被压在下边的十位数相同的一组，他们的个位数是否有序呢？显然是有的，其大小方向，取决于我们上一层的桶的取出方式为保持小的压在下面的性质，出桶应该采用先进先出的方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">radix sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,temp=vec.size();</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</span><br><span class="line">bucket.resize(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/*造桶*/</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">bucket[vec[i]%<span class="number">10</span>].push_back(vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(bucket[i].size()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(bucket[i].back());</span><br><span class="line">bucket[i].pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=vec.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">bucket[(vec[i]/<span class="number">10</span>)%<span class="number">10</span>].push_back(vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(bucket[i].size()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(bucket[i].back());</span><br><span class="line">bucket[i].pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="耐心排序（patience-sort）"><a href="#耐心排序（patience-sort）" class="headerlink" title="耐心排序（patience sort）"></a>耐心排序（patience sort）</h2><p>这个排序的思想是依次取出待排数组元素，从左往右查找桶，只有小于桶底元素才能入桶，如果没有桶或者元素不小于任何一个桶的桶底元素，就新建一个桶，把这个元素放到桶底部。</p><p>这一边操作结束的结果就是，把待排数组分成了很多段，在每个桶分别插入排序就能得到有序数组。</p><p>插入排序的最坏情况是在反序的时候出现的，这个算法相比插入排序，将那些反序得太离谱的元素进行了调整，减小了问题规模。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">patience sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">patience_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</span><br><span class="line"><span class="keyword">int</span> i,j,k,cur_bucket,len=vec.size();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">cur_bucket=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bucket.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(bucket[j][<span class="number">0</span>]&gt;=vec[i])</span><br><span class="line">&#123;</span><br><span class="line">cur_bucket=j;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur_bucket==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bucket.push_back(*(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;));</span><br><span class="line">bucket.back().push_back(vec[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bucket[cur_bucket].push_back(vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;bucket.size();k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(bucket[k].size()!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(bucket[k].back());</span><br><span class="line">bucket[k].pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;len;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=k;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[j]&lt;vec[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[j]=vec[j]^vec[j<span class="number">-1</span>];</span><br><span class="line">vec[j<span class="number">-1</span>]=vec[j]^vec[j<span class="number">-1</span>];</span><br><span class="line">vec[j]=vec[j]^vec[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闪电排序（flash-sort）"><a href="#闪电排序（flash-sort）" class="headerlink" title="闪电排序（flash sort）"></a>闪电排序（flash sort）</h2><p>这也是proximap排序的一种升级算法，对于长度为n的桶，它把数组最大值和最小值之间分成n个区间，落在同个区间的放进同一个桶，入桶的时候进行插入排序，最后按顺序遍历桶，得到的数组就是有序的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> flash sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flash_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</span><br><span class="line">bucket.resize(vec.size());</span><br><span class="line"><span class="comment">/*造桶*/</span></span><br><span class="line">  <span class="keyword">int</span> i,j,max=<span class="number">0</span>,min=<span class="number">0</span>,*m,*n,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[i]&gt;max)max=vec[i];</span><br><span class="line"><span class="keyword">if</span>(vec[i]&lt;min)min=vec[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">j=(vec.size()<span class="number">-1</span>)*(vec[i]-min)/(max-min);</span><br><span class="line">bucket[j].push_back(vec[i]);</span><br><span class="line"><span class="keyword">for</span>(k=bucket[j].size()<span class="number">-1</span>;k&gt;<span class="number">0</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">m=&amp;bucket[j][k];</span><br><span class="line">n=&amp;bucket[j][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(*n&lt;*m)</span><br><span class="line">&#123;</span><br><span class="line">*n=*n^(*m);</span><br><span class="line">*m=*n^(*m);</span><br><span class="line">*n=*n^(*m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bucket.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(bucket[j].size())</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(bucket[j].back());</span><br><span class="line">bucket[j].pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计数排序（-counting-sort）"><a href="#计数排序（-counting-sort）" class="headerlink" title="计数排序（ counting sort）"></a>计数排序（ counting sort）</h2><p>这个算法的核心思想是，如果待排数组中比一个元素小的有k个，那么这个元素就该放在第k+1个位置上。</p><p>当然对待重复的元素，需要特殊处理，假设有m个元素都发现数组中有k个元素比自己小，他们肯定不能全部挤在k+1号坑，显然，它们应该占据k+1到k+m这m个坑。</p><p>由于对每个元素，我们都需要遍历整个数组来统计比它小的元素个数，所以这个算法复杂度应该为O(n^2).<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> counting sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">counting_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,count;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket;</span><br><span class="line">bucket.resize(vec.size(),<span class="number">-1000</span>);</span><br><span class="line"><span class="comment">/*造桶*/</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;vec.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[j]&lt;vec[i]&amp;&amp;(j!=i))</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(bucket[count]!=(<span class="number">-1000</span>))</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">bucket[count]=vec[i];</span><br><span class="line">&#125;</span><br><span class="line">vec=bucket;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="圈排序（-cycle-sort）"><a href="#圈排序（-cycle-sort）" class="headerlink" title="圈排序（ cycle sort）"></a>圈排序（ cycle sort）</h2><p>如果你看懂了计数排序，你也许会想到，它并不是原地算法，因为通过对某个元素计数之后，你知道了这个元素应该去的位置，但是在原地那个位置上还占着一个不知该放在哪里的元素。所以我们的做法是建立一个新的数组来安放排好序的元素，最后赋值给原数组。当然为了节约能源，你也可以建一个数组用于保存每个位置应该放的元素的标号（因为实际排序不可能只排关键字，必然有数据域），最后再根据标号去让各个元素归位，不过这样操作依然不是最理想的。</p><p>圈排序解决了这个问题，把计数排序升级成了原地排序。</p><p>它的思想是这样的：当你找到一个a元素应该放在1号位，而1号位被另一个元素b占着，你就把b元素取出，然后把a放到1号位，给a本来的位置放一个空标记。接着寻找b应该放在哪里。最终你一定会找到一个元素应该放在a原来的位置，由于这个位置是空的，直接把元素放在此处就结束了，这样的一系列操作构成一个圈，每个元素移动一次，就能让一个圈上所有元素归位。</p><p>这里有个confused的地方，就是，你为什么知道能够找到这样的圈？</p><p>这背后是有数学原理的，这种排序前和排序之后的映射关系在抽象代数中称作置换，而上述的圈称作轮换，就是一个集合到自身的映射，可以严格证明，每个置换都能写成几个不相交的轮换乘积形式，此处只摆出结论，不做证明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cycle sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cycle_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp,count;</span><br><span class="line"><span class="comment">/*造桶*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;vec.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = vec[i];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;vec.size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vec[j]&lt;temp &amp;&amp; (j != i))</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (vec[count] == temp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count == i)<span class="keyword">break</span>;</span><br><span class="line">count++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">temp = temp^vec[count];</span><br><span class="line">vec[count] = temp^vec[count];</span><br><span class="line">temp = temp^vec[count];</span><br><span class="line"><span class="keyword">if</span> (i == count)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="地精-排序（gnome-sort）"><a href="#地精-排序（gnome-sort）" class="headerlink" title="地精 排序（gnome sort）"></a>地精 排序（gnome sort）</h2><p>这个算法我认为跟他的名字很搭调，地精就是生活在花园里的一种精灵，他们喜欢在土里钻来钻去。</p><p>这个算法具体操作概括为，先从左往右进行相邻元素比较，当发现一个元素不满足需要的大小关系的时候，就交换他们然后调转方向向左边冒泡，直到相邻元素满足大小关系的时候，停止冒泡。</p><p>按照这个过程，左边的一部分元素总是有序的，每次地精抓住一个元素把它插入到有序的序列内，所以这其实是插入排序的低配版，因为插入排序实际上在插入操作的时候可以优化到O(log(n),也就是二分法插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> gnome sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gnome_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)(vec.size())<span class="number">-1</span>;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">-1</span>)i++;</span><br><span class="line"><span class="keyword">if</span>(vec[i]&lt;vec[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[i]=vec[i+<span class="number">1</span>]^vec[i];</span><br><span class="line">vec[i+<span class="number">1</span>]=vec[i+<span class="number">1</span>]^vec[i];</span><br><span class="line">vec[i]=vec[i+<span class="number">1</span>]^vec[i];</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="珠排序（bead-sort）"><a href="#珠排序（bead-sort）" class="headerlink" title="珠排序（bead sort）"></a>珠排序（bead sort）</h2><p>这个算法有种让人眼前一亮的感觉，<a href="https://zh.wikipedia.org/wiki/%E7%8F%A0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科页面</a><br>讲的会更加清楚，这个算法按照理论，只需要把珠子穿在一系列棍子上，在‘duang’的一敲，排序就完成了。不过现实很骨感，它只能排整数列，并且在编程的时候，复杂度也是n^2级别，但是这种想法的确让人惊叹，发明这个算法的人真的是天才。</p><p>这个算法实际上基本是不可用的，不过我还是写了一个实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bead sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bead_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.resize(vec.size(),<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*下落*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;vec.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vec[j] &gt;= i + <span class="number">1</span>)temp[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line">vec.resize(temp.size(),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;vec.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp[j] &gt;= i + <span class="number">1</span>)vec[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##　快速排序（quick sort）<br>这个算法采用的是分治法的思想，选取一个元素，然后遍历整个数组，小于等于这个元素的都放在这个元素左边，其余的放在它右边。这样数组就被分为三部分，这个元素本身已经处于正确的位置上，不需要再移动，而左右两部分都是无序的，但是左边部分的元素的正确位置只可能在左边，所以只要将左右两边分别排序，整个数组都有序了。</p><p>实现的时候，数组头尾各放一个指针（抽象意义的），左边指针向右移动直到有大于指定元素的时候停下来，右边指针也类似，等两边指针都停下来了，就进行一次交换，最终两个指针相遇的时候,再中间放上之前指定的那个元素，就完成了数组的分片操作。</p><p>递归的调用这个过程，最终得到的数组就是有序的。</p><p>由于这个算法递归深度为log（n）到n之间，它的复杂度也在n^2到nlogn之间，实际上他的平均复杂度是O（nlogn），既然他的名字叫做快速排序它总不能打自己脸来个n^2复杂度吧。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">quick sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=left+<span class="number">1</span>,j=right,k,temp;</span><br><span class="line"><span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">temp=vec[left];</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(vec[left]&gt;=vec[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)<span class="keyword">break</span>;</span><br><span class="line">vec[i<span class="number">-1</span>]=vec[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(vec[left]&lt;vec[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)<span class="keyword">break</span>;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line">vec[i]=vec[i]^vec[j];</span><br><span class="line">vec[j]=vec[i]^vec[j];</span><br><span class="line">vec[i]=vec[i]^vec[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec[k]=temp;</span><br><span class="line">quick_sort(vec,left,i<span class="number">-2</span>);</span><br><span class="line">quick_sort(vec,i,right);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h2><p>归并排序的思想也是挺直观的，对于已经有序的两个（或者n个）数列，我们只需要比较队列头部两个元素就能找出最终合并后数列的最大or最小元素。</p><p>假设我们需要从大到小排列，每次比较后把两个队头中大的那个放到新的队列，然后从待排队列中剔除它，直到其中一个列没有元素之后，就把另一列全部接到已经排序好的数列后边。</p><p>算法实现上，通过设置两个队头指针（抽象意义），用移动指针来表示元素的剔除，实现原地操作（当然就增加了时间复杂度）。</p><p>同时也用了分治法，先归并排序左半个数列，再归并排序右半边数列，最后归并排序整个数列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">merge sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=h)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i,j,k,m,n;</span><br><span class="line">i=(h-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">j=h-l+<span class="number">1</span>-i;</span><br><span class="line">m=l;</span><br><span class="line">n=l+i;</span><br><span class="line">merge_sort(vec,l,l+i<span class="number">-1</span>);</span><br><span class="line">merge_sort(vec,l+i,h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;(m&lt;n)&amp;&amp;(n&lt;=h);)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[m]&gt;=vec[n])</span><br><span class="line">&#123;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=n;k&gt;m;k--)</span><br><span class="line">&#123;</span><br><span class="line">vec[k]=vec[k]^vec[k<span class="number">-1</span>];</span><br><span class="line">vec[k<span class="number">-1</span>]=vec[k]^vec[k<span class="number">-1</span>];</span><br><span class="line">vec[k]=vec[k]^vec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="strand-sort"><a href="#strand-sort" class="headerlink" title="strand sort"></a>strand sort</h2><p>这个算法首先给出一个有序数组（实际上选取待排数组中的第一个，就是一个有序数组了），然后遍历数组中余下的部分找到一个有序子列，具体做法是选一个元素作为子列开头，往后遍历若找到一个元素小于子列的尾部元素（这里是指的从大到小排列的情形），就从待排数组剔除这个元素，然后将它接到子列尾部。</p><p>最后将有序数组和子列归并排序，直到待排数组为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strand sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strand_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;<span class="comment">//'有序列'</span></span><br><span class="line">temp.push_back(vec[<span class="number">0</span>]);</span><br><span class="line">vec.erase(vec.begin());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"><span class="keyword">int</span> j,k,m,n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">n=temp.size();</span><br><span class="line"><span class="keyword">if</span> (vec.size() == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(i=vec.begin();i!=vec.end();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==vec.begin())</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(*i);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(*i&lt;=temp.back())</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(*i);</span><br><span class="line">i=vec.erase(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==temp.size())<span class="keyword">break</span>;</span><br><span class="line">vec.erase(vec.begin());</span><br><span class="line">m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;(m&lt;n)&amp;&amp;(n&lt;=temp.size()<span class="number">-1</span>);)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp[m]&gt;=temp[n])</span><br><span class="line">&#123;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=n;k&gt;m;k--)</span><br><span class="line">&#123;</span><br><span class="line">temp[k]=temp[k]^temp[k<span class="number">-1</span>];</span><br><span class="line">temp[k<span class="number">-1</span>]=temp[k]^temp[k<span class="number">-1</span>];</span><br><span class="line">temp[k]=temp[k]^temp[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">vec = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h2><p>希尔排序是选择一系列的间隔，对每个间隔把元素等距离的分为若干组，每组分别进行插入排序。</p><p>这个间隔序列的选取应该是递减的，并且最后一个间隔是1.这个算法相比于插入排序，优势在于当间隔不为1的时候进行的排序，实际上相当于在整个数列中，让元素跨过多元素进行移动，这样解决了逆序带来的复杂度的提升。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shell sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> interval=<span class="number">10</span>,i,j,k,len=vec.size(),cur_len;</span><br><span class="line"><span class="keyword">while</span>(interval&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;interval;i++)</span><br><span class="line">&#123;</span><br><span class="line">cur_len=(len/interval)+(i&lt;len%interval?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;cur_len<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;cur_len<span class="number">-1</span>-i;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[i+interval*k]&lt;vec[i+interval*(k+<span class="number">1</span>)])</span><br><span class="line">&#123;</span><br><span class="line">vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k+<span class="number">1</span>)];</span><br><span class="line">vec[i+interval*(k+<span class="number">1</span>)]=vec[i+interval*k]^vec[i+interval*(k+<span class="number">1</span>)];</span><br><span class="line">vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k+<span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interval=interval/<span class="number">1.3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="梳子排序（comb-sort）"><a href="#梳子排序（comb-sort）" class="headerlink" title="梳子排序（comb sort）"></a>梳子排序（comb sort）</h2><p>这个算法就是希尔排序的冒泡版本，因为他按照等距离的方法把元素分为很多组，分别冒泡排序，就像梳子的齿一样，所以得名comb sort。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">comb sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> interval=<span class="number">10</span>,i,j,k,len=vec.size(),cur_len;</span><br><span class="line"><span class="keyword">while</span>(interval&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;interval;i++)</span><br><span class="line">&#123;</span><br><span class="line">cur_len=(len/interval)+(i&lt;len%interval?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;cur_len;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=j;k&gt;<span class="number">0</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[i+interval*k]&lt;vec[i+interval*(k<span class="number">-1</span>)])</span><br><span class="line">&#123;</span><br><span class="line">vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k<span class="number">-1</span>)];</span><br><span class="line">vec[i+interval*(k<span class="number">-1</span>)]=vec[i+interval*k]^vec[i+interval*(k<span class="number">-1</span>)];</span><br><span class="line">vec[i+interval*k]=vec[i+interval*k]^vec[i+interval*(k<span class="number">-1</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interval=interval/<span class="number">1.3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="奇偶排序（odd-even-sort）"><a href="#奇偶排序（odd-even-sort）" class="headerlink" title="奇偶排序（odd_even sort）"></a>奇偶排序（odd_even sort）</h2><p>这个算法将元素按照下标的奇偶分为两组，首先在第一组进行相邻两个元素的比较，然后在第二组进行相邻两个元素比较（相邻的定义要一致，可以都用后一个相邻，也可以都用前一个乡邻，绝对不能一个前一个后），如此循环。直到某一次进行完检查后，第一组和第二组都没有改动，这时候就说明元素已经有序了。</p><p>这个算法一看就知道只是花拳绣腿，改变一下冒泡排序的顺序而已，性能没有任何变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">odd_even sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">odd_even_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> odd_len,even_len,len,j,flag=<span class="number">1</span>;</span><br><span class="line">len=vec.size();</span><br><span class="line">odd_len=len/<span class="number">2</span>+(len%<span class="number">2</span>==<span class="number">0</span>?(<span class="number">-1</span>):<span class="number">0</span>);</span><br><span class="line">even_len=len/<span class="number">2</span>+(len%<span class="number">2</span>==<span class="number">0</span>?<span class="number">0</span>:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;even_len;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[<span class="number">2</span>*j]&lt;vec[<span class="number">2</span>*j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[<span class="number">2</span>*j]=vec[<span class="number">2</span>*j]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</span><br><span class="line">vec[<span class="number">2</span>*j+<span class="number">1</span>]=vec[<span class="number">2</span>*j]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</span><br><span class="line">vec[<span class="number">2</span>*j]=vec[<span class="number">2</span>*j]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;odd_len;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vec[<span class="number">2</span>*j+<span class="number">1</span>]&lt;vec[<span class="number">2</span>*j+<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">vec[<span class="number">2</span>*j+<span class="number">2</span>]=vec[<span class="number">2</span>*j+<span class="number">2</span>]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</span><br><span class="line">vec[<span class="number">2</span>*j+<span class="number">1</span>]=vec[<span class="number">2</span>*j+<span class="number">2</span>]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</span><br><span class="line">vec[<span class="number">2</span>*j+<span class="number">2</span>]=vec[<span class="number">2</span>*j+<span class="number">2</span>]^vec[<span class="number">2</span>*j+<span class="number">1</span>];</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图书馆排序（library-sort）"><a href="#图书馆排序（library-sort）" class="headerlink" title="图书馆排序（library sort）"></a>图书馆排序（library sort）</h2><p>这个算法是二十一世纪才提出的，由此便看出计算机科学的活力，在数学上，那些让你觉得深不可测的东西，你一看年代，往往在几百年前就被大师上课的时候在草稿纸上解决了，等你学到21世纪的数学，你就是大师了。</p><p>这个算法灵感源于在图书馆放书的时候在书之间留下空隙，当你需要插入一本书的时候就不必移动整个架子的书。</p><p>所以我们在数组元素间留一些空隙，插入的时候就能够减少对其他元素的移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">library sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">library_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> empty_flag = <span class="number">-1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.resize(vec.size()*<span class="number">2</span>,empty_flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j, k,l, indicator;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">2</span>*i;j&gt;=<span class="number">-1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( j == <span class="number">-1</span>||(temp[j] &gt;= vec[i]&amp;&amp;temp[j]!= empty_flag))</span><br><span class="line">&#123;</span><br><span class="line">indicator = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(l=<span class="number">2</span>*i;l&gt;j;l--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp[l] != empty_flag)</span><br><span class="line">&#123;</span><br><span class="line">indicator = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (indicator == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp[j + <span class="number">1</span>] != empty_flag)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">k = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (temp[k] != empty_flag)</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; k &gt; j + <span class="number">1</span>; k--)</span><br><span class="line">&#123;</span><br><span class="line">temp[k] = temp[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">temp[k] = vec[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[j + <span class="number">1</span>] = vec[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[i * <span class="number">2</span>] = vec[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vec.resize(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; temp.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp[i] != empty_flag)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(temp[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bogo-sort"><a href="#bogo-sort" class="headerlink" title="bogo sort"></a>bogo sort</h2><p>这个算法也没有中文翻译，不过我把它作为压轴算法，它必然有过人之处，它的过人之处就是，超级慢。</p><p>这个算法思想类似于把一副牌扔向空中，掉到地上后去看看它是不是有序的，如果不是，再扔一次。</p><p>它的复杂度是O（n!）,这个东西和n^n是同阶的。可见其相当恐怖。</p><p>数学说起来太抽象，假设排十个数需要时间t，那么排20个就需要2^20*10^10*t，也就是大约2*10^16*t，我实测了一下，半分钟才能排11个数字。</p><p>这个算法存在的意义估计是挑战运算的极限吧，等有朝一日，这个算法能用于生产生活，人类文明估计就会进入新纪元了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bogo sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bogo_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> randa=<span class="number">1</span>, randb=<span class="number">2</span>,count=<span class="number">0</span>,i,flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">randa = (time(<span class="literal">NULL</span>)+rand())%vec.size();</span><br><span class="line">randb = (time(<span class="literal">NULL</span>)+rand())% vec.size();</span><br><span class="line"><span class="keyword">if</span> (randb != randa)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec[randa] = vec[randa] ^ vec[randb];</span><br><span class="line">vec[randb] = vec[randa] ^ vec[randb];</span><br><span class="line">vec[randa] = vec[randa] ^ vec[randb];</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; vec.size()<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i] &lt; vec[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;写在前边&lt;/strong&gt;：这篇文章又臭又长，纯属个人无聊总结之作。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;排序算法在计算机界是很基础，很重要的，对人类也是至关重要的，没有排序算法，就难以把人类分成三六九等区别对待了，那样的世界真是无法想象啊。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术" scheme="https://xigou.github.io/categories/技术/"/>
    
    
  </entry>
  
  <entry>
    <title>秘技---------气象操控术！！</title>
    <link href="https://xigou.github.io/2017/04/10/2017-04-10-jzm_and_weather/"/>
    <id>https://xigou.github.io/2017/04/10/2017-04-10-jzm_and_weather/</id>
    <published>2017-04-10T13:14:32.000Z</published>
    <updated>2022-04-27T02:22:55.027Z</updated>
    
    <content type="html"><![CDATA[<p>气象学是一门极其困难的科学，究其原因，主要是气象学模型复杂，扰动条件相当多，导致时常有不符合模型的情况出现，这在专业上称作‘奇点’。<br>今天我们讲讲中国气象学上几个著名的奇点。</p><a id="more"></a><p>1985年5月，戈尔巴乔夫访华，国家主席杨尚昆和未来的总书记江先生一同接见了这位苏共总书记。<br>江主席亲切的说：“由于您的到来，上海的天气好转了。”戈尔巴乔夫回应：“特别令人高兴的是，中苏关系好转了”。<br><img src="https://i.imgur.com/Wjyl0b5.png" alt="戈尔巴乔夫访华"></p><p>2009年，江主席视察旧部国机二院。会议中，中国著名气象专家徐嘉诰笑着说：“天气预报本来说今天有雨，结果江主席一来，天气晴朗”。</p><p><img src="https://i.imgur.com/XEjuXps.png" alt="二院天气变化"></p><p>科学研究需要敏锐的嗅觉，通过对以上两个案例的分析，很多人发现两个事件中共同点就是有他在场，于是便草率做出结论：他拥有“气象操控术”这样一种失传已久的秘技，上一次这个秘技展示在众人眼前，还是东汉末年。</p><p>斗转星移，到了2017年，我看到这样一篇新闻报道：</p><blockquote><p>中新社记者 孙宇挺<br>中国国家副主席习近平15日到访美国艾奥瓦州东部小镇马斯卡廷，与27年前的老友聚面。<br>习近平当日下午抵达马斯卡廷兰迪夫人家门口时，阴雨天气短暂放晴。今天的老友聚会将在兰迪家举行。14名当地高中生用中文向习近平致意。<br>“我喜欢你的笑容。”兰迪夫人对走进屋子的习近平说。她今天穿了一袭中国红的中式上衣。<br>兰迪家今天打扮得有点中国风，墙上挂起了中国书法，角落摆着中国瓷器，甚至桌上餐巾纸也是印着孔雀的图案。<br>习近平在起居室火炉边的沙发上落座，左右两侧坐着兰迪夫妇俩。习近平落座以后，双手放在膝盖上。他的身后和面前围坐着当年的那些老友，有些人甚至站着。<br>当兰迪夫人开场白结束后，习近平站到火炉前，面对左右两侧的老朋友们开始发言。</p></blockquote><p><img src="https://imgur.com/xKEHF89.png" alt="习近平主席在马斯卡廷兰迪夫人家"></p><p>之前网友盛传他拥有秘技的谣言不攻自破，倘若真是秘技重现江湖，就目前的情形来看，他并不是唯一掌握这种秘技的人，至少他那位超凡的继任者也拥有同样的能力。<br>历史的脉搏是这么的有力，在波澜壮阔的长河里一次又一次不紧不慢的展示出自己的迷人之处。</p><p>无论真相如何，我们作为芸芸众生中微不足道的一员，只能感叹一句：历史就像是抽着兰州的董小姐，她不是一个没有故事的女同学，嘴上一笔带过，心里却一直重复。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;气象学是一门极其困难的科学，究其原因，主要是气象学模型复杂，扰动条件相当多，导致时常有不符合模型的情况出现，这在专业上称作‘奇点’。&lt;br&gt;今天我们讲讲中国气象学上几个著名的奇点。&lt;/p&gt;</summary>
    
    
    
    <category term="幽默" scheme="https://xigou.github.io/categories/幽默/"/>
    
    
  </entry>
  
</feed>
